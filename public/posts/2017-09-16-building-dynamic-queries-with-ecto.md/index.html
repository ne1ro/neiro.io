<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://neiro.io/images/favicon.png" />
<title>Building dynamic queries with Ecto | neiro blog</title>
<meta name="title" content="Building dynamic queries with Ecto" />
<meta name="description" content="Ecto is the most popular,
robust and solid solution to work with databases in Elixir ecosystem.
Ecto is not ORM, ODM nor it is a Repository patern library. Ecto is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.
Ecto.Query is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted." />
<meta name="author" content="[neiro]" />
<meta name="keywords" content="elixir,ecto,query," />






  





  













<meta property="og:title" content="Building dynamic queries with Ecto" />
<meta property="og:description" content="Ecto is the most popular,
robust and solid solution to work with databases in Elixir ecosystem.
Ecto is not ORM, ODM nor it is a Repository patern library. Ecto is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.
Ecto.Query is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neiro.io/posts/2017-09-16-building-dynamic-queries-with-ecto.md/" />

<meta property="og:image" content="https://neiro.io/images/social_card_bg_hu8864780498390034054.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-16T10:00:00+02:00" />
<meta property="article:modified_time" content="2017-09-16T10:00:00+02:00" /><meta property="og:site_name" content="neiro" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://neiro.io/images/social_card_bg_hu8864780498390034054.webp"/>
<meta name="twitter:title" content="Building dynamic queries with Ecto"/>
<meta name="twitter:description" content="Ecto is the most popular,
robust and solid solution to work with databases in Elixir ecosystem.
Ecto is not ORM, ODM nor it is a Repository patern library. Ecto is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.
Ecto.Query is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted."/>



<meta itemprop="name" content="Building dynamic queries with Ecto">
<meta itemprop="description" content="Ecto is the most popular,
robust and solid solution to work with databases in Elixir ecosystem.
Ecto is not ORM, ODM nor it is a Repository patern library. Ecto is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.
Ecto.Query is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted."><meta itemprop="datePublished" content="2017-09-16T10:00:00+02:00" />
<meta itemprop="dateModified" content="2017-09-16T10:00:00+02:00" />
<meta itemprop="wordCount" content="1167">

<meta itemprop="image" content="https://neiro.io/images/social_card_bg_hu8864780498390034054.webp"/>


<meta itemprop="keywords" content="elixir,ecto,query," />

<meta name="referrer" content="no-referrer-when-downgrade" />

  
  <link href="/herman.min.css" rel="stylesheet">

  
    
    <link href="/syntax.min.css" rel="stylesheet">
  

  

  
</head>

<body>
  <header><a class="skip-link" href="#main-content">Skip to main content</a>

<a href="/" class="title"><h1>neiro blog</h1></a>
<nav>
  <a href="/">Home</a>

  <a href="/blog/">Blog</a>

<a href='https://neiro.io/index.xml'>RSS</a>







</nav>
</header>
  <main id="main-content">

<h1>Building dynamic queries with Ecto</h1>
<p class="byline">
  <time datetime='2017-09-16' pubdate>
    2017-09-16
  </time>
  · [neiro]
</p>

<content>
  <p><a href="https://github.com/elixir-ecto/ecto">Ecto</a> is the most popular,
robust and solid solution to work with databases in <strong>Elixir</strong> ecosystem.
Ecto is not ORM, ODM nor it is a <em>Repository patern</em> library. <em>Ecto</em> is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.</p>
<p><strong>Ecto.Query</strong> is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted.</p>
<p>But what if we want to build a <em>really</em> dynamic query? A common case can
be filtering by list of attributes.</p>
<p>Imagine a situation when you have a large set of users in your database.
Your customers want to filter or exclude users by any attributes that
can be allowed: <code>name, nickname, gender</code> etc. Writing code for all of
model attributes can be tedious and annoying.</p>
<p>So what can we do about it?</p>
<h2 id="filter-query">Filter Query</h2>
<p>Let&rsquo;s create a new Elixir module that will implement logic of our future
dynamic query. I will name it <code>FilterQuery</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln">4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>This module should have just one public function called <code>filter</code> that
accepts incoming query, inclusion and exclusion parameters as the
arguments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def filter(query, inclusion, exclusion)</span></span></code></pre></div><p>Now let&rsquo;s implement the core of our future filter function. Assume that
we need to build two lists of dynamic queries both for inclusion and
exclusion parameters:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)</span></span></code></pre></div><p>Now we need to merge all these dynamic queries into a new big one. It
can be implemented using <code>Enum.reduce</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)</span></span></code></pre></div><p>Now our <code>filter</code> function returns a new complex query that can be easily
composed with another queries using <code>Ecto.Query</code> functions or macroses.</p>
<h2 id="dynamic-filter-query">Dynamic filter query</h2>
<p>We have just created a basic prototype for our future dynamic filter
query. However, the devil&rsquo;s always in the details. We need to hide
implementation in private functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">3</span><span class="cl">      do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">4</span><span class="cl">  end
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">  defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">    for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>We suppose that inclusion and exclusion filters are keyword lists with
keys as model attributes and lists as the filter values. Therefore, we
need to check if these lists contain values or we shall skip building
query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">2</span><span class="cl">  defp present?(_), do: false</span></span></code></pre></div><p>Now we need to go straight to the implementation. <code>dynamic_query/3</code>
should finally return for us the result.</p>
<p>We will use <code>dynamic</code> macro from Ecto.Query that takes any query as
first argument and builds dynamic query for the second one. Also notice
that we need to use <code>field</code> macro to dynamically access attribute name:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">6</span><span class="cl">    dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><h2 id="restriction-of-filter-keys">Restriction of filter keys</h2>
<p>So, looks like our filter query is fully functional and dynamic! But
this is not enough when you are building a complex logic that
desperately needs to leave some attributes <strong>unfiltered</strong>.</p>
<p>For example, imagine the case when your <code>User</code> model has a
<code>relationships_status</code> attribute. If you&rsquo;re allowing your API customers
to filter any attributes they are likely to find out lonely users by
using this loophole. Therefore your customers will be dating, engaging,
tying the knots and finally will be lost for your application. Is this
what you really wished? Guess not :)</p>
<p>So let&rsquo;s restrict filtered attributes by using <code>__using__</code> macro:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  ...
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    end
</span></span><span class="line"><span class="ln">10</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">13</span><span class="cl">      do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">     defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">17</span><span class="cl">  end</span></span></code></pre></div><p>Voila! No one ever will find out how your users relationships are going.</p>
<p>Now let&rsquo;s take a quick look at our dynamic filter query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      quote do
</span></span><span class="line"><span class="ln">10</span><span class="cl">        import FilterQuery
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">13</span><span class="cl">        def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln">14</span><span class="cl">          [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">          queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln">17</span><span class="cl">          Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        end
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">        def filter(query, _) do
</span></span><span class="line"><span class="ln">21</span><span class="cl">          query
</span></span><span class="line"><span class="ln">22</span><span class="cl">        end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">25</span><span class="cl">          for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">26</span><span class="cl">            do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">27</span><span class="cl">        end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">          for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">31</span><span class="cl">        end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">34</span><span class="cl">          dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">35</span><span class="cl">        end
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">        defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">          dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">39</span><span class="cl">        end
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl">        defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">42</span><span class="cl">          do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">43</span><span class="cl">
</span></span><span class="line"><span class="ln">44</span><span class="cl">        defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">45</span><span class="cl">
</span></span><span class="line"><span class="ln">46</span><span class="cl">        defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">47</span><span class="cl">        defp present?(_), do: false
</span></span><span class="line"><span class="ln">48</span><span class="cl">      end
</span></span><span class="line"><span class="ln">49</span><span class="cl">    end
</span></span><span class="line"><span class="ln">50</span><span class="cl">  end</span></span></code></pre></div><h2 id="usage">Usage</h2>
<p>It&rsquo;s a piece of cake to use our query in another modules. Just include
our query and set the list of allowed attributes through <code>use</code>
construction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  {:ok, _} = Application.ensure_all_started(:ex_machina)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Example of using dynamic ecto queries
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    import Factory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    use FilterQuery, attributes: ~w(proficiency name)a
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def run do
</span></span><span class="line"><span class="ln">12</span><span class="cl">      insert_users()
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      IO.inspect(count([])) # 3
</span></span><span class="line"><span class="ln">15</span><span class="cl">      [relationships_status: [&#34;married&#34;]] |&gt; count([]) |&gt; IO.inspect # 3
</span></span><span class="line"><span class="ln">16</span><span class="cl">      [proficiency: [&#34;developer&#34;]] |&gt; count([]) |&gt; IO.inspect # 1
</span></span><span class="line"><span class="ln">17</span><span class="cl">      [proficiency: [&#34;soldier&#34;]] |&gt; count([]) |&gt; IO.inspect # 0
</span></span><span class="line"><span class="ln">18</span><span class="cl">      IO.inspect(count([], %{proficiency: [&#34;politic&#34;]})) # 2
</span></span><span class="line"><span class="ln">19</span><span class="cl">    end
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    defp insert_users do
</span></span><span class="line"><span class="ln">22</span><span class="cl">      Repo.delete_all(User)
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      insert(:user, relationships_status: &#34;single&#34;, proficiency: &#34;developer&#34;)
</span></span><span class="line"><span class="ln">25</span><span class="cl">      insert(:user, relationships_status: &#34;married&#34;, proficiency: &#34;politic&#34;)
</span></span><span class="line"><span class="ln">26</span><span class="cl">      insert(:user, relationships_status: &#34;dating&#34;, proficiency: &#34;thief&#34;)
</span></span><span class="line"><span class="ln">27</span><span class="cl">    end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    defp count(inclusion, exclusion \\ []) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">      User
</span></span><span class="line"><span class="ln">31</span><span class="cl">      |&gt; filter(inclusion, exclusion)
</span></span><span class="line"><span class="ln">32</span><span class="cl">      |&gt; Repo.aggregate(:count, :id)
</span></span><span class="line"><span class="ln">33</span><span class="cl">    end
</span></span><span class="line"><span class="ln">34</span><span class="cl">  end</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>However, this is not at all that we can achieve by using <code>dynamic</code> macro
in Ecto.</p>
<p>You can filter by regex, type or even your own query; sort by ascending
and descending; do aggregation or pagination; whatever comes to your
head - it all depends on your imagination and skills. Ecto provides you
a great tool to build any complex queries by writing minimal lines of
code without any duplication.</p>
<p>What&rsquo;s next? See the <a href="https://github.com/ne1ro/dynamic_ecto_query">full
example</a> for this article or read
<a href="https://hexdocs.pm/ecto/Ecto.Query.html">Ecto documentation</a> to
deepen your knowledge a little bit more.</p>
<p>Happy hacking!</p>

</content>
<p>
  
    <a class="blog-tags" href="/tags/elixir/">#elixir</a>
  
    <a class="blog-tags" href="/tags/ecto/">#ecto</a>
  
    <a class="blog-tags" href="/tags/query/">#query</a>
  
</p>




  </main>
  <footer><small>
  neiro © 2012-2025 | Made with <a href="https://github.com/clente/hugo-bearcub">Bear Cub</a>
</small></footer>

    
</body>

</html>
