<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Elixir on neiro blog</title>
    <link>https://neiro.io/tags/elixir/</link>
    <description>Recent content in Elixir on neiro blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <copyright>neiro Â© 2012-2025</copyright>
    <lastBuildDate>Wed, 19 Jul 2023 15:45:00 +0200</lastBuildDate>
    <atom:link href="https://neiro.io/tags/elixir/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Taming the time: how to run XTDB in production</title>
      <link>https://neiro.io/blog/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</link>
      <pubDate>Wed, 19 Jul 2023 15:45:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd&#34;&gt;The article was originally published in MarleySpoon DevBlog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-xtdb&#34;&gt;What is XTDB&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/ne1ro/series/22497&#34;&gt;In the previous articles&lt;/a&gt;, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&amp;rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.&lt;/p&gt;&#xA;&lt;h3 id=&#34;xtdb-1&#34;&gt;XTDB 1&lt;/h3&gt;&#xA;&lt;p&gt;Before we proceed, it&amp;rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.&#xA;It&amp;rsquo;s worth mentioning that your experience may vary, especially with the introduction of &lt;a href=&#34;https://www.xtdb.com/v2&#34;&gt;XTDB 2.0&lt;/a&gt; and subsequent versions.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<hr>
<p><a href="https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd">The article was originally published in MarleySpoon DevBlog</a></p>
<h2 id="what-is-xtdb">What is XTDB</h2>
<p><a href="https://dev.to/ne1ro/series/22497">In the previous articles</a>, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.</p>
<h3 id="xtdb-1">XTDB 1</h3>
<p>Before we proceed, it&rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.
It&rsquo;s worth mentioning that your experience may vary, especially with the introduction of <a href="https://www.xtdb.com/v2">XTDB 2.0</a> and subsequent versions.</p>
<h2 id="deploying-xtdb">Deploying XTDB</h2>
<p>Deploying XTDB in a production environment offers several options, each with its advantages and considerations:</p>
<ul>
<li>run as a part of your JVM application</li>
<li>run separately, but on the same server together with your application</li>
<li>run on a standalone node or in a separate container</li>
<li>run a cluster of XTDB nodes</li>
</ul>
<p>To achieve a resilient and scalable setup, I recommend running a cluster of XTDB nodes, with each node deployed as a separate Docker container managed by Kubernetes. This allows easy orchestration, automatic scaling, and simplified management of the XTDB cluster.</p>
<h3 id="containerised-xtdb">Containerised XTDB</h3>
<p>In this section, we will explore how to build and run a Docker container with a custom configured XTDB application <em>(Clojure project)</em> in a Kubernetes cluster. However, in case you don&rsquo;t need to have a custom build and can simply use a <a href="https://hub.docker.com/r/juxt/xtdb-standalone-rocksdb">standalone Docker image</a>, you can skip right to the &ldquo;Authentication&rdquo; section.</p>
<h4 id="uberjar">Uberjar</h4>
<p>If we want to run the XTDB in Docker the most fitting way to run it in a container would be to compile our preconfigured XT application into a single &ldquo;uberjar&rdquo; file.</p>
<p>This can be done by employing <a href="https://github.com/tonsky/uberdeps">Uberdeps</a> in our Clojure project:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="ss">:aliases</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"> <span class="p">{</span><span class="ss">:uberdeps</span> <span class="p">{</span><span class="ss">:replace-deps</span> <span class="p">{</span><span class="nv">uberdeps/uberdeps</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.1.0&#34;</span><span class="p">}}</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">             <span class="ss">:replace-paths</span> <span class="p">[]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">             <span class="ss">:main-opts</span> <span class="p">[</span><span class="s">&#34;-m&#34;</span> <span class="s">&#34;uberdeps.uberjar&#34;</span><span class="p">]}}</span></span></span></code></pre></div><p>Once you have it installed, you can compile your project into a single Uberjar file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">clj -M:uberdeps</span></span></code></pre></div><h4 id="dockerfile">Dockerfile</h4>
<p>We want our XTDB Docker image to be as lightweight as possible, so the best approach would be to have a multi-stage build image that builds and runs the Uberjar on the selected JVM image:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c"># Build clojure uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> clojure:openjdk-17-tools-deps-alpine AS BUILD</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">COPY</span> . /xtdb<span class="err">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk add --no-cache libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="err"></span><span class="k">RUN</span> clojure -M:uberdeps<span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err"></span><span class="c"># Copy and run uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> openjdk:17-alpine3.14</span><span class="err">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /usr/local/lib/xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk --no-cache add bash libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/resources /usr/local/lib/xtdb/resources<span class="err">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/target .<span class="err">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">MALLOC_ARENA_MAX</span><span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;java&#34;</span><span class="p">,</span> <span class="s2">&#34;-cp&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.jar&#34;</span><span class="p">,</span> <span class="s2">&#34;clojure.main&#34;</span><span class="p">,</span> <span class="s2">&#34;-m&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.core&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 3000</span></span></span></code></pre></div><h4 id="graceful-shutdown">Graceful shutdown</h4>
<p>Another requirement for running XT in Kubernetes is to gracefully shut down, e.g., on killing containers or Kubernetes deployment restart. To ensure that, we have to change our `xtdb.clj` file by adding a `SIGTERM` signal handler:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">;; Stop the system on SIGTERM</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="nf">with-handler</span> <span class="ss">:term</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;Caught SIGTERM, quitting&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="p">(</span><span class="nf">.close</span> <span class="o">@</span><span class="nv">xt-node</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;All components shut down&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">0</span><span class="p">))</span></span></span></code></pre></div><h3 id="authentication">Authentication</h3>
<p>Since we run our XTDB separately from our application containers, we might want to ensure that the requests from services to the database are properly authenticated.</p>
<p>In order to ensure that we need to change the way we start XTDB by providing JWKS (<a href="https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets">JSON Web Token key set</a>) as an environment variable to the XTDB node:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; core.clj</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.http-server/server</span> <span class="p">{</span><span class="ss">:port</span> <span class="mi">3000</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">                             <span class="ss">:jwks</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;XTDB_JWKS&#34;</span><span class="p">)}</span> <span class="nv">...</span></span></span></code></pre></div><p>The next step is to send the compatible JWT token from your application requests:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">{</span><span class="s2">&#34;Authorization&#34;</span><span class="p">,</span> <span class="s2">&#34;Bearer </span><span class="si">#{</span><span class="n">your_jwt</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">}</span></span></span></code></pre></div><h3 id="kubernetes">Kubernetes</h3>
<p>As we&rsquo;ve decided to go with the running XT nodes as Docker containers in a Kubernetes cluster, we need to prepare Kubernetes manifests for that purpose.</p>
<p>The simplest way to achieve that is to create a Kubernetes stateful set of multiple XT containers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-headless</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">      </span><span class="nt">terminationGracePeriodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">$REGISTRY/xtdb:1.21.0</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Always</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">          </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">            </span><span class="nt">tcpSocket</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">              </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">120</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">            </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w">          </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w">            </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">              </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">                </span>- <span class="l">bash</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">                </span><span class="c"># custom readiness check script</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">                </span>- <span class="l">scripts/readiness.sh</span><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">            </span>- <span class="nt">secretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-secrets</span></span></span></code></pre></div><p>As for the configuration, you can create a configmap with environment variables required for configuring XTDB and a secrets resource for providing secrets to your XT nodes.</p>
<h2 id="running-xt-in-production">Running XT in production</h2>
<p>XTDB is an <em>unbundled database</em> which means that it has a lot of components that can be swapped or changed â and it might work with different technologies and other databases.</p>
<p>In general, it consists of 3 parts:</p>
<ol>
<li>Transaction log</li>
<li>Document store</li>
<li>Index store</li>
</ol>
<p>We had an experience using PostgreSQL and JDBC adapter for our XTDB setup, as well as experimenting with Kafka for transaction log â and using RocksDB as an index storage.</p>
<p>However, there are many more other ways and modules to setup the database â you can find them in <a href="https://docs.xtdb.com/administration/configuring/">the documentation.</a></p>
<h3 id="jdbc">JDBC</h3>
<p>The transaction log and document store are considered to be <strong>golden stores</strong> in XTDB â which means that they should be reliably persisted, unlike the index storage that can be rebuilt from scratch on node restart.</p>
<p>XT supports JDBC (Java Database Connectivity) which allows us to connect to various SQL databases like PostgreSQL, MySQL, SQLite, and others.
In our example, we were using PostgreSQL + JDBC for both transaction log and document store.</p>
<p>To use PostgreSQL and JDBC together, you have to provide these modules in your <em>deps.edn</em> first:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="ss">:deps</span> <span class="p">{</span><span class="nv">org.postgresql/postgresql</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;42.2.18&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">        <span class="nv">com.xtdb/xtdb-jdbc</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">       <span class="nv">...</span></span></span></code></pre></div><p>If you want to use environment variables for connecting to PostgreSQL from the XTDB deployment you can also pass them in <strong>core.clj</strong> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="p">{</span><span class="ss">:host</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_HOST&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="ss">:port</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;POSTGRES_PORT&#34;</span> <span class="s">&#34;5432&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="ss">:dbname</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_DB&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="ss">:user</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_USER&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="ss">:password</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_PASSWORD&#34;</span><span class="p">)})</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.jdbc/connection-pool</span> <span class="p">{</span><span class="ss">:dialect</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc.psql/-&gt;dialect</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                               <span class="ss">:pool-opts</span> <span class="p">{</span><span class="ss">:maximumPoolSize</span> <span class="mi">10</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                               <span class="ss">:db-spec</span> <span class="nv">db-spec</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">   <span class="ss">:xtdb/tx-log</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;tx-log</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                 <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">   <span class="ss">:xtdb/document-store</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;document-store</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                         <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}})</span></span></span></code></pre></div><p>That way we can also re-use the same connection pool for both transaction and document store.</p>
<h3 id="kafka">Kafka</h3>
<p>However, the recommended option (and also most often used in production) is to leverage Kafka for the transaction store.</p>
<p>During node restarts <em>(e.g. on new deployments)</em> XTDB has to rebuild the transaction log from zero or the latest saved checkpoint, which means reading the whole transaction table in PostgreSQL â and in our experience, this process was slower than expected.</p>
<p>Kafka seems to be a better fit for the very purpose of the transaction log because:</p>
<ul>
<li>it&rsquo;s basically a log of events</li>
<li>we only need to use just one partition and one topic</li>
<li>the transactions can be consumed very quickly</li>
</ul>
<p>Thus, the most optimal and performant setup for us looked like:</p>
<ul>
<li>using Kafka as a transaction log</li>
<li>using JDBC and relational database as a document store</li>
<li>using RocksDB as an index store</li>
</ul>
<p>That way, we can ensure that the transactions can be created quickly, the log can be re-consumed fast, and the document storage is performant enough and resilient.</p>
<h3 id="checkpoints">Checkpoints</h3>
<p>If we want to rebuild the query indices (e.g. on node restart), XT might need to replay the transaction log â which sometimes might be not so fast especially if you have a long history of changes.</p>
<p>As we run our XTDB in a cluster, it&rsquo;s vital that the readiness time â when the XT instance is ready to serve DB requests â is as low as possible.
Fortunately, XTDB has a solution for that problem called <strong>checkpoints</strong>.</p>
<p>Right now, there are three ways to persist the local query indices state:</p>
<ul>
<li>local files (using Java&rsquo;s NIO file system)</li>
<li>AWS S3</li>
<li>GPC&rsquo;s cloud storage</li>
</ul>
<h4 id="aws-s3">AWS S3</h4>
<p>In our case, we&rsquo;ve decided to go with the AWS setup in order to have a centralised and already configured storage for the checkpoints.
However, it also requires some additional dependencies to be installed:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"> <span class="ss">:deps</span> <span class="p">{</span><span class="nv">com.xtdb/xtdb-s3</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="nv">software.amazon.awssdk/aws-core</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;2.10.91&#34;</span><span class="p">}</span></span></span></code></pre></div><p>Additional setup in the node configuration is also required.</p>
<p>As we&rsquo;ve experienced some requests to S3 taking a long time, we&rsquo;ve also decided to build a custom AWS S3 HTTP client:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="kd">defn- </span><span class="nv">make-s3-client</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="s">&#34;Increases timeouts for AWS S3 HTTP calls&#34;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">[]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">timeout</span> <span class="p">(</span><span class="nf">Duration/ofSeconds</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="nv">http-client-builder</span> <span class="p">(</span><span class="nf">-&gt;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                             <span class="p">(</span><span class="nf">NettyNioAsyncHttpClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionAcquisitionTimeout</span> <span class="nv">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionTimeout</span> <span class="nv">timeout</span><span class="p">))]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">S3AsyncClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">(</span><span class="nf">.httpClientBuilder</span> <span class="nv">http-client-builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="nv">.build</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-name</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;CHECKPOINT_NAME&#34;</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-config</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="c1">; Checkpoints are not enabled on a local machine where we don&#39;t have the env</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">str/blank?</span> <span class="nv">checkpoint-name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.checkpoint/-&gt;checkpointer</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">     <span class="ss">:store</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">     <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.s3.checkpoint/-&gt;cp-store</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">      <span class="ss">:bucket</span> <span class="nv">checkpoint-name</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">      <span class="ss">:configurator</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">reify</span> <span class="nv">S3Configurator</span> <span class="p">(</span><span class="nf">makeClient</span> <span class="p">[</span><span class="nv">_this</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-s3-client</span><span class="p">))))}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">     <span class="ss">:Keep-dir-on-close?</span> <span class="nv">false</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">     <span class="ss">:approx-frequency</span> <span class="p">(</span><span class="nf">Duration/ofHours</span> <span class="mi">2</span><span class="p">)}))</span></span></span></code></pre></div><p>Once configured, XT will persist the current index state to S3 every 2 hours. One might want to adjust S3&rsquo;s bucket policy so it archives or removes the obsolete checkpoints files.</p>
<h2 id="caveats">Caveats</h2>
<h3 id="memory-consumption">Memory consumption</h3>
<p>JVM-based applications tend to consume quite a significant amount of memory budget â in our case, running XT with allowed 4GB of memory wasn&rsquo;t always enough so we&rsquo;ve decided to increase the memory limits in Kubernetes up to 8 gigabytes.</p>
<p>Another consideration we&rsquo;ve observed is that the vertical scaling works better for an XTDB cluster â unlike the horizontal scaling, where we need to wait until the new node restores from the checkpoints or processes the transactions log.</p>
<h3 id="rocksdb-tuning">RocksDB tuning</h3>
<p>RocksDB is being used by XT as an index store, and as the result, it might consume quite a significant amount of resources.
In order to avoid possible issues with the memory budgeting, it&rsquo;s recommended to <a href="https://github.com/facebook/rocksdb/wiki/Setup-Options-and-Basic-Tuning#block-cache-size">set RocksDB block cache to 1/3 of available memory</a> which can be done in XTDB configuration.</p>
<h3 id="readiness-probes">Readiness probes</h3>
<p>Depending on your technology stack that you use for XTDB deployment, consuming the transaction log even with the checkpoints feature enabled can take some time â and even though the starting node is able to handle REST API requests, they won&rsquo;t be processed until the node finishes the consumption.</p>
<p>To avoid that, you might need to check the difference between the last submitted and last completed transactions, e.g. from a bash script:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="c1"># scripts/readiness.sh: A script that compares the latest submitted and indexed transactions</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="nb">set</span> -e
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="nv">THRESHOLD</span><span class="o">=</span><span class="m">1000</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"># Assumes that you have jq and curl installed</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="nv">submitted_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-submitted-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nv">completed_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-completed-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nv">diff</span><span class="o">=</span>$<span class="o">[</span>submitted_tx - completed_tx<span class="o">]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">if</span> <span class="o">((</span>diff &gt; THRESHOLD<span class="o">))</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is not ready&#34;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is ready&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="k">fi</span></span></span></code></pre></div><h3 id="load-balancing-and-xt-cluster">Load balancing and XT cluster</h3>
<p>The index storage is not shared between XTDB nodes â so every node might have a slightly different data representation. To ensure integrity, we might need to use <em>await-tx</em> or <em>sync</em> functions whenever we submit a transaction.</p>
<p>However, when we use REST API in a distributed cluster of nodes, it might be that the load balancer that stands in front of the nodes distributes requests to the database randomly â and when we submit a transaction to one node, we can end up reading data from another, which might have not processed that transaction yet.</p>
<p>If we want to prevent such situation, we might need to implement sticky sessions or use <a href="https://dev.to/marleyspoon/taming-the-time-how-to-install-develop-with-xtdb-2lbf#http2">HTTP2</a> connections between your applications and database nodes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>XTDB embraces the bitemporality concept and provides powerful capabilities of handling your data in an immutable way.</p>
<p>However, this also implies that during your journey with XT, you might face some technical challenges caused by its unbundled database concept â and resolve them by reasoning about the selected components, technology stack, and implications.</p>
<p>The new milestone in XTDB&rsquo;s development â <a href="https://www.xtdb.com/v2">XTDB 2.0</a> â looks very promising for us as it has a more flexible and scalable architecture as well as the first-class SQL support â and can be used by PostgreSQL clients.</p>
<p>We look forward to trying out the new version and hope that you&rsquo;ve enjoyed our series of articles about XT.</p>
<p>Happy hacking, and stay tuned!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Taming the time: how to run XTDB in production</title>
      <link>https://neiro.io/posts/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</link>
      <pubDate>Wed, 19 Jul 2023 15:45:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd&#34;&gt;The article was originally published in MarleySpoon DevBlog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-xtdb&#34;&gt;What is XTDB&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/ne1ro/series/22497&#34;&gt;In the previous articles&lt;/a&gt;, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&amp;rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.&lt;/p&gt;&#xA;&lt;h3 id=&#34;xtdb-1&#34;&gt;XTDB 1&lt;/h3&gt;&#xA;&lt;p&gt;Before we proceed, it&amp;rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.&#xA;It&amp;rsquo;s worth mentioning that your experience may vary, especially with the introduction of &lt;a href=&#34;https://www.xtdb.com/v2&#34;&gt;XTDB 2.0&lt;/a&gt; and subsequent versions.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<hr>
<p><a href="https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd">The article was originally published in MarleySpoon DevBlog</a></p>
<h2 id="what-is-xtdb">What is XTDB</h2>
<p><a href="https://dev.to/ne1ro/series/22497">In the previous articles</a>, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.</p>
<h3 id="xtdb-1">XTDB 1</h3>
<p>Before we proceed, it&rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.
It&rsquo;s worth mentioning that your experience may vary, especially with the introduction of <a href="https://www.xtdb.com/v2">XTDB 2.0</a> and subsequent versions.</p>
<h2 id="deploying-xtdb">Deploying XTDB</h2>
<p>Deploying XTDB in a production environment offers several options, each with its advantages and considerations:</p>
<ul>
<li>run as a part of your JVM application</li>
<li>run separately, but on the same server together with your application</li>
<li>run on a standalone node or in a separate container</li>
<li>run a cluster of XTDB nodes</li>
</ul>
<p>To achieve a resilient and scalable setup, I recommend running a cluster of XTDB nodes, with each node deployed as a separate Docker container managed by Kubernetes. This allows easy orchestration, automatic scaling, and simplified management of the XTDB cluster.</p>
<h3 id="containerised-xtdb">Containerised XTDB</h3>
<p>In this section, we will explore how to build and run a Docker container with a custom configured XTDB application <em>(Clojure project)</em> in a Kubernetes cluster. However, in case you don&rsquo;t need to have a custom build and can simply use a <a href="https://hub.docker.com/r/juxt/xtdb-standalone-rocksdb">standalone Docker image</a>, you can skip right to the &ldquo;Authentication&rdquo; section.</p>
<h4 id="uberjar">Uberjar</h4>
<p>If we want to run the XTDB in Docker the most fitting way to run it in a container would be to compile our preconfigured XT application into a single &ldquo;uberjar&rdquo; file.</p>
<p>This can be done by employing <a href="https://github.com/tonsky/uberdeps">Uberdeps</a> in our Clojure project:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="ss">:aliases</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"> <span class="p">{</span><span class="ss">:uberdeps</span> <span class="p">{</span><span class="ss">:replace-deps</span> <span class="p">{</span><span class="nv">uberdeps/uberdeps</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.1.0&#34;</span><span class="p">}}</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">             <span class="ss">:replace-paths</span> <span class="p">[]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">             <span class="ss">:main-opts</span> <span class="p">[</span><span class="s">&#34;-m&#34;</span> <span class="s">&#34;uberdeps.uberjar&#34;</span><span class="p">]}}</span></span></span></code></pre></div><p>Once you have it installed, you can compile your project into a single Uberjar file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">clj -M:uberdeps</span></span></code></pre></div><h4 id="dockerfile">Dockerfile</h4>
<p>We want our XTDB Docker image to be as lightweight as possible, so the best approach would be to have a multi-stage build image that builds and runs the Uberjar on the selected JVM image:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c"># Build clojure uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> clojure:openjdk-17-tools-deps-alpine AS BUILD</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">COPY</span> . /xtdb<span class="err">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk add --no-cache libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="err"></span><span class="k">RUN</span> clojure -M:uberdeps<span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err"></span><span class="c"># Copy and run uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> openjdk:17-alpine3.14</span><span class="err">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /usr/local/lib/xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk --no-cache add bash libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/resources /usr/local/lib/xtdb/resources<span class="err">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/target .<span class="err">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">MALLOC_ARENA_MAX</span><span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;java&#34;</span><span class="p">,</span> <span class="s2">&#34;-cp&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.jar&#34;</span><span class="p">,</span> <span class="s2">&#34;clojure.main&#34;</span><span class="p">,</span> <span class="s2">&#34;-m&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.core&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 3000</span></span></span></code></pre></div><h4 id="graceful-shutdown">Graceful shutdown</h4>
<p>Another requirement for running XT in Kubernetes is to gracefully shut down, e.g., on killing containers or Kubernetes deployment restart. To ensure that, we have to change our `xtdb.clj` file by adding a `SIGTERM` signal handler:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">;; Stop the system on SIGTERM</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="nf">with-handler</span> <span class="ss">:term</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;Caught SIGTERM, quitting&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="p">(</span><span class="nf">.close</span> <span class="o">@</span><span class="nv">xt-node</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;All components shut down&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">0</span><span class="p">))</span></span></span></code></pre></div><h3 id="authentication">Authentication</h3>
<p>Since we run our XTDB separately from our application containers, we might want to ensure that the requests from services to the database are properly authenticated.</p>
<p>In order to ensure that we need to change the way we start XTDB by providing JWKS (<a href="https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets">JSON Web Token key set</a>) as an environment variable to the XTDB node:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; core.clj</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.http-server/server</span> <span class="p">{</span><span class="ss">:port</span> <span class="mi">3000</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">                             <span class="ss">:jwks</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;XTDB_JWKS&#34;</span><span class="p">)}</span> <span class="nv">...</span></span></span></code></pre></div><p>The next step is to send the compatible JWT token from your application requests:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">{</span><span class="s2">&#34;Authorization&#34;</span><span class="p">,</span> <span class="s2">&#34;Bearer </span><span class="si">#{</span><span class="n">your_jwt</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">}</span></span></span></code></pre></div><h3 id="kubernetes">Kubernetes</h3>
<p>As we&rsquo;ve decided to go with the running XT nodes as Docker containers in a Kubernetes cluster, we need to prepare Kubernetes manifests for that purpose.</p>
<p>The simplest way to achieve that is to create a Kubernetes stateful set of multiple XT containers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-headless</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">      </span><span class="nt">terminationGracePeriodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">$REGISTRY/xtdb:1.21.0</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Always</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">          </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">            </span><span class="nt">tcpSocket</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">              </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">120</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">            </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w">          </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w">            </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">              </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">                </span>- <span class="l">bash</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">                </span><span class="c"># custom readiness check script</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">                </span>- <span class="l">scripts/readiness.sh</span><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">            </span>- <span class="nt">secretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-secrets</span></span></span></code></pre></div><p>As for the configuration, you can create a configmap with environment variables required for configuring XTDB and a secrets resource for providing secrets to your XT nodes.</p>
<h2 id="running-xt-in-production">Running XT in production</h2>
<p>XTDB is an <em>unbundled database</em> which means that it has a lot of components that can be swapped or changed â and it might work with different technologies and other databases.</p>
<p>In general, it consists of 3 parts:</p>
<ol>
<li>Transaction log</li>
<li>Document store</li>
<li>Index store</li>
</ol>
<p>We had an experience using PostgreSQL and JDBC adapter for our XTDB setup, as well as experimenting with Kafka for transaction log â and using RocksDB as an index storage.</p>
<p>However, there are many more other ways and modules to setup the database â you can find them in <a href="https://docs.xtdb.com/administration/configuring/">the documentation.</a></p>
<h3 id="jdbc">JDBC</h3>
<p>The transaction log and document store are considered to be <strong>golden stores</strong> in XTDB â which means that they should be reliably persisted, unlike the index storage that can be rebuilt from scratch on node restart.</p>
<p>XT supports JDBC (Java Database Connectivity) which allows us to connect to various SQL databases like PostgreSQL, MySQL, SQLite, and others.
In our example, we were using PostgreSQL + JDBC for both transaction log and document store.</p>
<p>To use PostgreSQL and JDBC together, you have to provide these modules in your <em>deps.edn</em> first:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="ss">:deps</span> <span class="p">{</span><span class="nv">org.postgresql/postgresql</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;42.2.18&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">        <span class="nv">com.xtdb/xtdb-jdbc</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">       <span class="nv">...</span></span></span></code></pre></div><p>If you want to use environment variables for connecting to PostgreSQL from the XTDB deployment you can also pass them in <strong>core.clj</strong> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="p">{</span><span class="ss">:host</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_HOST&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="ss">:port</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;POSTGRES_PORT&#34;</span> <span class="s">&#34;5432&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="ss">:dbname</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_DB&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="ss">:user</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_USER&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="ss">:password</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_PASSWORD&#34;</span><span class="p">)})</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.jdbc/connection-pool</span> <span class="p">{</span><span class="ss">:dialect</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc.psql/-&gt;dialect</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                               <span class="ss">:pool-opts</span> <span class="p">{</span><span class="ss">:maximumPoolSize</span> <span class="mi">10</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                               <span class="ss">:db-spec</span> <span class="nv">db-spec</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">   <span class="ss">:xtdb/tx-log</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;tx-log</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                 <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">   <span class="ss">:xtdb/document-store</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;document-store</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                         <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}})</span></span></span></code></pre></div><p>That way we can also re-use the same connection pool for both transaction and document store.</p>
<h3 id="kafka">Kafka</h3>
<p>However, the recommended option (and also most often used in production) is to leverage Kafka for the transaction store.</p>
<p>During node restarts <em>(e.g. on new deployments)</em> XTDB has to rebuild the transaction log from zero or the latest saved checkpoint, which means reading the whole transaction table in PostgreSQL â and in our experience, this process was slower than expected.</p>
<p>Kafka seems to be a better fit for the very purpose of the transaction log because:</p>
<ul>
<li>it&rsquo;s basically a log of events</li>
<li>we only need to use just one partition and one topic</li>
<li>the transactions can be consumed very quickly</li>
</ul>
<p>Thus, the most optimal and performant setup for us looked like:</p>
<ul>
<li>using Kafka as a transaction log</li>
<li>using JDBC and relational database as a document store</li>
<li>using RocksDB as an index store</li>
</ul>
<p>That way, we can ensure that the transactions can be created quickly, the log can be re-consumed fast, and the document storage is performant enough and resilient.</p>
<h3 id="checkpoints">Checkpoints</h3>
<p>If we want to rebuild the query indices (e.g. on node restart), XT might need to replay the transaction log â which sometimes might be not so fast especially if you have a long history of changes.</p>
<p>As we run our XTDB in a cluster, it&rsquo;s vital that the readiness time â when the XT instance is ready to serve DB requests â is as low as possible.
Fortunately, XTDB has a solution for that problem called <strong>checkpoints</strong>.</p>
<p>Right now, there are three ways to persist the local query indices state:</p>
<ul>
<li>local files (using Java&rsquo;s NIO file system)</li>
<li>AWS S3</li>
<li>GPC&rsquo;s cloud storage</li>
</ul>
<h4 id="aws-s3">AWS S3</h4>
<p>In our case, we&rsquo;ve decided to go with the AWS setup in order to have a centralised and already configured storage for the checkpoints.
However, it also requires some additional dependencies to be installed:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"> <span class="ss">:deps</span> <span class="p">{</span><span class="nv">com.xtdb/xtdb-s3</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="nv">software.amazon.awssdk/aws-core</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;2.10.91&#34;</span><span class="p">}</span></span></span></code></pre></div><p>Additional setup in the node configuration is also required.</p>
<p>As we&rsquo;ve experienced some requests to S3 taking a long time, we&rsquo;ve also decided to build a custom AWS S3 HTTP client:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="kd">defn- </span><span class="nv">make-s3-client</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="s">&#34;Increases timeouts for AWS S3 HTTP calls&#34;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">[]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">timeout</span> <span class="p">(</span><span class="nf">Duration/ofSeconds</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="nv">http-client-builder</span> <span class="p">(</span><span class="nf">-&gt;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                             <span class="p">(</span><span class="nf">NettyNioAsyncHttpClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionAcquisitionTimeout</span> <span class="nv">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionTimeout</span> <span class="nv">timeout</span><span class="p">))]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">S3AsyncClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">(</span><span class="nf">.httpClientBuilder</span> <span class="nv">http-client-builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="nv">.build</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-name</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;CHECKPOINT_NAME&#34;</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-config</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="c1">; Checkpoints are not enabled on a local machine where we don&#39;t have the env</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">str/blank?</span> <span class="nv">checkpoint-name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.checkpoint/-&gt;checkpointer</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">     <span class="ss">:store</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">     <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.s3.checkpoint/-&gt;cp-store</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">      <span class="ss">:bucket</span> <span class="nv">checkpoint-name</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">      <span class="ss">:configurator</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">reify</span> <span class="nv">S3Configurator</span> <span class="p">(</span><span class="nf">makeClient</span> <span class="p">[</span><span class="nv">_this</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-s3-client</span><span class="p">))))}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">     <span class="ss">:Keep-dir-on-close?</span> <span class="nv">false</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">     <span class="ss">:approx-frequency</span> <span class="p">(</span><span class="nf">Duration/ofHours</span> <span class="mi">2</span><span class="p">)}))</span></span></span></code></pre></div><p>Once configured, XT will persist the current index state to S3 every 2 hours. One might want to adjust S3&rsquo;s bucket policy so it archives or removes the obsolete checkpoints files.</p>
<h2 id="caveats">Caveats</h2>
<h3 id="memory-consumption">Memory consumption</h3>
<p>JVM-based applications tend to consume quite a significant amount of memory budget â in our case, running XT with allowed 4GB of memory wasn&rsquo;t always enough so we&rsquo;ve decided to increase the memory limits in Kubernetes up to 8 gigabytes.</p>
<p>Another consideration we&rsquo;ve observed is that the vertical scaling works better for an XTDB cluster â unlike the horizontal scaling, where we need to wait until the new node restores from the checkpoints or processes the transactions log.</p>
<h3 id="rocksdb-tuning">RocksDB tuning</h3>
<p>RocksDB is being used by XT as an index store, and as the result, it might consume quite a significant amount of resources.
In order to avoid possible issues with the memory budgeting, it&rsquo;s recommended to <a href="https://github.com/facebook/rocksdb/wiki/Setup-Options-and-Basic-Tuning#block-cache-size">set RocksDB block cache to 1/3 of available memory</a> which can be done in XTDB configuration.</p>
<h3 id="readiness-probes">Readiness probes</h3>
<p>Depending on your technology stack that you use for XTDB deployment, consuming the transaction log even with the checkpoints feature enabled can take some time â and even though the starting node is able to handle REST API requests, they won&rsquo;t be processed until the node finishes the consumption.</p>
<p>To avoid that, you might need to check the difference between the last submitted and last completed transactions, e.g. from a bash script:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="c1"># scripts/readiness.sh: A script that compares the latest submitted and indexed transactions</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="nb">set</span> -e
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="nv">THRESHOLD</span><span class="o">=</span><span class="m">1000</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"># Assumes that you have jq and curl installed</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="nv">submitted_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-submitted-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nv">completed_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-completed-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nv">diff</span><span class="o">=</span>$<span class="o">[</span>submitted_tx - completed_tx<span class="o">]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">if</span> <span class="o">((</span>diff &gt; THRESHOLD<span class="o">))</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is not ready&#34;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is ready&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="k">fi</span></span></span></code></pre></div><h3 id="load-balancing-and-xt-cluster">Load balancing and XT cluster</h3>
<p>The index storage is not shared between XTDB nodes â so every node might have a slightly different data representation. To ensure integrity, we might need to use <em>await-tx</em> or <em>sync</em> functions whenever we submit a transaction.</p>
<p>However, when we use REST API in a distributed cluster of nodes, it might be that the load balancer that stands in front of the nodes distributes requests to the database randomly â and when we submit a transaction to one node, we can end up reading data from another, which might have not processed that transaction yet.</p>
<p>If we want to prevent such situation, we might need to implement sticky sessions or use <a href="https://dev.to/marleyspoon/taming-the-time-how-to-install-develop-with-xtdb-2lbf#http2">HTTP2</a> connections between your applications and database nodes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>XTDB embraces the bitemporality concept and provides powerful capabilities of handling your data in an immutable way.</p>
<p>However, this also implies that during your journey with XT, you might face some technical challenges caused by its unbundled database concept â and resolve them by reasoning about the selected components, technology stack, and implications.</p>
<p>The new milestone in XTDB&rsquo;s development â <a href="https://www.xtdb.com/v2">XTDB 2.0</a> â looks very promising for us as it has a more flexible and scalable architecture as well as the first-class SQL support â and can be used by PostgreSQL clients.</p>
<p>We look forward to trying out the new version and hope that you&rsquo;ve enjoyed our series of articles about XT.</p>
<p>Happy hacking, and stay tuned!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Well-crafted functional architecture: ports and adapters</title>
      <link>https://neiro.io/blog/2019-10-01-well-crafted-functional-architecture-ports-and-adapters.md/</link>
      <pubDate>Tue, 01 Oct 2019 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2019-10-01-well-crafted-functional-architecture-ports-and-adapters.md/</guid>
      <description>&lt;p&gt;At &lt;a href=&#34;https://salam.io&#34;&gt;Salam.io&lt;/a&gt; we are developing a modern social&#xA;platform containing a humongous amount of features.&lt;/p&gt;&#xA;&lt;p&gt;Development of such product is quite hard and challenging - we need our&#xA;software to be robust, scalable, fault-tolerant, performant and at the&#xA;same time we want it to be easy to extend, test, maintain and support.&lt;/p&gt;&#xA;&lt;p&gt;All these issues are inevitable upon growth of the app but they for sure&#xA;can be simplified or even avoided by choosing, optimising the software&#xA;architecture.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>At <a href="https://salam.io">Salam.io</a> we are developing a modern social
platform containing a humongous amount of features.</p>
<p>Development of such product is quite hard and challenging - we need our
software to be robust, scalable, fault-tolerant, performant and at the
same time we want it to be easy to extend, test, maintain and support.</p>
<p>All these issues are inevitable upon growth of the app but they for sure
can be simplified or even avoided by choosing, optimising the software
architecture.</p>
<p>We also use functional programming languages -
<a href="https://clojure.org">Clojure</a> &amp; <a href="https://elixir-lang.org">Elixir</a> -
for the backend and frontend as much as possible. Therefore, we need to
adjust the existing architecture approaches to powerful abilities and
intricacies of modern functional programming.</p>
<p>That&rsquo;s why we&rsquo;re starting these series of articles - we think it&rsquo;s
crucial for everyone who&rsquo;s crafting the functional systems to understand
and apply software architectures rules and principles.</p>
<h2 id="why-ports-adapters">Why ports &amp; adapters ?</h2>
<p>Even if you&rsquo;re developing a relatively small scale software you still
need to design it first - and to design it properly. The earlier you
start caring about your architecture the earlier you can benefit from it
and the later a lot of issues caused by bad architecture would appear.</p>
<p>The main idea of ports &amp; adapters architecture is that application that
you&rsquo;re building is a <em>closed area</em>. This means that all your business
logic should be separated from technical details in this area. Often
architecture is about the boundaries so are the ports &amp; adapters.</p>
<p>In case you stick with ports &amp; adapters from the very beginning then
this approach should help you to keep your business logic separated and
easily tested s well as technology agnostic - you can write a port &amp; an
adapter for any software/third-party service/library that you&rsquo;re using
so it can be easily extended or switched in favour of another one.</p>
<h2 id="hexagonal">Hexagonal</h2>
<p>Ports &amp; adapters architecture also has another name: <em>Hexagonal
architecture</em>. According to this terminology the inner part of your
software - the place where you put your business logic - is hexagon
while your adapters are placed surround it.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Hexagonal_Architecture.svg/1000px-Hexagonal_Architecture.svg.png"
    alt="Figure 1: Hexagon"><figcaption>
      <p><span class="figure-number">Figure 1: </span>Hexagon</p>
    </figcaption>
</figure>

<p>The hexagon should not contain any references to another frameworks,
real world services, libraries, etc. - all these elements should be
adapters. At the same time the architecture doesn&rsquo;t prescribe you to
design your hexagon in some certain way - you can use Layer
architecture, Onion, DDD or any another suitable architecture inside or
it may be a pure business logic without any sophistications - it&rsquo;s up to
you.</p>
<p>Why hexagon? Well, any geometric figure with boundaries could work, but
the hexagon represents better the concept that you have ports at the
edges of your application and adapters behind it. Likewise, it&rsquo;s a
symmetric figure and we&rsquo;ll describe below why it&rsquo;s important.</p>
<h2 id="ports">Ports</h2>
<p>Every time you need to interact with something from beyond of your
application logic you need to group these actions and describe them in a
<em>port</em>. The port is the edge of hexagon and it should be an integral and
essential part of your application.</p>
<p>Naming of the ports is quite important - you shouldn&rsquo;t use any
technology name in your port but focus on its mission instead. Some of
examples:</p>
<ul>
<li>PushNotifications</li>
<li>Search</li>
<li>Persistence</li>
<li>Authentication</li>
</ul>
<p>The majority of programming languages usually contain interfaces /
protocols feature allowing you to build a port. In Clojure, for example,
you can use <em>multimethods</em> or <em>protocols</em> to achieve this goal. But for
now let&rsquo;s see how we can implement the realisation of port for Elixir
using its&rsquo; capability to create <strong>behaviours</strong>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule Core.PushNotifications do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Port for sending push notifications.
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    @type message :: %{title: String.t(), body: String.t()}
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    @type payload :: Keyword.t
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @type recipients :: [map]
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    @adapter :core |&gt; Application.fetch_env!(__MODULE__) |&gt; Keyword.fetch!(:adapter)
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    @callback send_notifications(message, recipients, payload) :: {:ok, [map]} | {:error, any}
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    defdelegate send_notifications(message, recipients, payload), to: @adapter
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>The example above is nothing more than an abstraction for using push
notifications from <code>Core</code>. We declare the behaviour and one callback
that specifies what we send and what we can expect as the result. The
exact implementation - adapter - should be placed in your app
configuration like:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  config :core, Core.PushNotifications, adapter: PushNotifications.APNS</span></span></code></pre></div><p>If you want to call this port from your application you just need to use
the delegated function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule Core do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    alias Core.PushNotifications
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def register_user(params) do
</span></span><span class="line"><span class="ln">5</span><span class="cl">      # business logic ...
</span></span><span class="line"><span class="ln">6</span><span class="cl">       result = PushNotifications.send_notifications(message, recipients, payload)
</span></span><span class="line"><span class="ln">7</span><span class="cl">      # handle the result somehow
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end
</span></span><span class="line"><span class="ln">9</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, from the <code>Core</code> we know nothing about the implementation
details - we just send notifications to users and that&rsquo;s it. In ideal
case we need to move <strong>any impure function, any side-effect</strong> to the edge
of the system - to adapters and call them <strong>only by using ports</strong> .</p>
<h2 id="driver-adapters">Driver Adapters</h2>
<p>Adapters are components which are placed outside of your application -
and your hexagon. They should represent the technology, service, library
that you need to interact through the port.</p>
<p>We specify two types of adapters: <em>Driver</em> and <em>Driven</em>.</p>
<p>The first ones are something from the left side of the picture above. It
could be a HTML page, API endpoint, CLI application, GUI or anything
that <em>drives</em> your application. That also means that the driver adapter
should use a driver port interface so your app receives technology
agnostic request on its borders.</p>
<p>Let&rsquo;s assume that we also have a web application that uses our <em>Core</em>.
If we want to register user then we need to call a
<code>Core.register_user/1</code> function from inside of our controller. In that
case <code>UserController</code> is our driver adapter and <code>Core</code> is the called
application. Fortunately, in Elixir we have type specs that can play a
role of specification of driver port so you&rsquo;ll always be able to see
what we need to send and what we should expect in response.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule Web.UserController do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    use Web, :controller
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def create(conn, params) do
</span></span><span class="line"><span class="ln">5</span><span class="cl">      result = Core.register_user(params) # will create user and send notifications
</span></span><span class="line"><span class="ln">6</span><span class="cl">     # handle the result somehow
</span></span><span class="line"><span class="ln">7</span><span class="cl">    end
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>In the approach above you can see that we use <code>Core.register_user/1</code>
function as the driver port - because it&rsquo;s spec describes the
interface - and <code>Web.UserController.index/2</code> as the driver adapter.</p>
<h2 id="driven-adapters">Driven Adapters</h2>
<p>A <em>Driven</em> adapter implements an interface given by driven port. That
means that now driven adapter depends on our application, but not visa
versa. The same as driver, this adapter should also be placed outside of
our hexagon and represents a technology/library/real-world device.</p>
<p>Common examples are:</p>
<ul>
<li>Persistence adapters - SQL, NoSQL databases or even in-memory / file
storage</li>
<li>Cache adapters - Redis / Memcached / ETS or in-memory storage</li>
<li>Email adapters - SMTP or third-party services</li>
<li>Message queue adapters</li>
<li>Third-party APIs</li>
</ul>
<p>Let&rsquo;s continue the push notifications solution we&rsquo;ve started before.
Now, in order to implement the driver adapter, we need to use the port
<code>Core.PushNotifications</code> and it&rsquo;s callback <code>send_notifications</code>. We will
adapt realisation of sending push notifications over APNS by the
specification that was given us by this port:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule PushNotifications.APNS do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;APNS adapter for push notifications&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @behaviour Core.PushNotifications
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    @impl true
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    def send_notifications(message, recipients, payload) do
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      {:ok, recipients
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      |&gt; Enum.map(fn r -&gt; build_notification(message, r, payload) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      |&gt; Pigeon.APNS.Notification.push()}
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp build_notification(message, recipient, payload) do
</span></span><span class="line"><span class="ln">13</span><span class="cl">       Pigeon.APNS.Notification.new(message, recipient.device_token, payload)
</span></span><span class="line"><span class="ln">14</span><span class="cl">     end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>Now our push notifications are almost completed. We can always change
the implementation - for example, from APNS to Firebase - or use
third-party library <strong>* without changing our core application*</strong> - so we
can say that&rsquo;s technology agnostic approach.</p>
<h2 id="testing">Testing</h2>
<p>Of course the main benefit of ports and adapters architecture is
improved testability. Instead of manually mocking calls to the
real-world providers we just need to create a test adapter that we
satisfy testing conditions. In the perfect case every <em>driven adapter</em>
should have a test analogue as well as all behaviours of <code>driver ports</code>
should be tested. Let&rsquo;s write a test adapter for the PushNotifications
port then:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule PushNotifications.TestAdapter do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;Test adapter for push notifications&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    @behaviour Core.PushNotifications
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">    @impl true
</span></span><span class="line"><span class="ln">6</span><span class="cl">    def send_notifications(message, recipients, payload) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">       {:ok, [%{message: message, payload: payload, recipients: recipients}]}
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end
</span></span><span class="line"><span class="ln">9</span><span class="cl">  end</span></span></code></pre></div><p>As you can see we are not sending data to the outer world but use a pure
function instead. In case of any incoming input we will know its&rsquo; output
for sure. Now, when we unit-test the <code>Core</code> module we just need to
select test adapter as the implementation of <code>PushNotifications</code>
interface. In Elixir ecosystem we have a great library called <code>Mox</code> that
can be used for such case:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  Mox.defmock(PushNotifications.TestMock, for: Core.PushNotifications)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule CoreTest do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    use Core.DataCase, async: true
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    import Mox
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">   # Make sure mocks are verified when the test exits
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    setup :verify_on_exit!
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    test &#34;register/1&#34; do
</span></span><span class="line"><span class="ln">11</span><span class="cl">       stub_with(PushNotifications.TestMock, PushNotifications.TestAdapter)
</span></span><span class="line"><span class="ln">12</span><span class="cl">       assert {:ok, _} = Core.register_user(some_params)
</span></span><span class="line"><span class="ln">13</span><span class="cl">    end
</span></span><span class="line"><span class="ln">14</span><span class="cl">  end</span></span></code></pre></div><p>In this example you can see that we&rsquo;re not sending push notifications in
the real world but using the local test mock instead. We are free to
change the test adapter for any testing purposes if we want to.</p>
<p>From now you get your <em>driver</em> port&rsquo;s behaviour tested. As the next step
you can test exactly the adapter implementation without any outside
logic attached - you just need to check that your implementation is
working fine as it was predicted. As for the integration testing you&rsquo;re
free to choose between the real-world adapters or you may use some test
adapters for this purpose - it&rsquo;s up to you.</p>
<h2 id="pros-vs-cons">Pros vs Cons</h2>
<p>Now we&rsquo;ve covered the basics of ports and adapters architecture. Let&rsquo;s
summarise what we have:</p>
<h3 id="pros">Pros</h3>
<ul>
<li>Testability</li>
<li>Replaceability</li>
<li>Technology-agnostic approach - you can delay technological solutions</li>
<li>Isolating pure code from impure code</li>
<li>Isolating side-effects</li>
<li>Maintainability</li>
</ul>
<h3 id="cons">Cons</h3>
<ul>
<li>Sometimes it may be an overhead, especially for a small scale software</li>
<li>You may not need it if you are pretty sure that the technology stack
of your project will remain the same over the years</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>We applied ports &amp; adapters architecture at
<a href="https://salam.io">Salam.io</a> when it became clear that our software
will be using a lot of services which could be replaced in the future.
This approach has already given a lot of benefits and allowed us to make
our software even more testable and flexible.</p>
<p>If you want to know more about this architecture you can take a look at
the
<a href="https://web.archive.org/web/20180822100852/http://alistair.cockburn.us/Hexagonal&#43;architecture">original
article by Alistair Cockburn</a> .</p>
<p>In the next article of this series we will show how you can apply ports
&amp; adapters architecture in Clojure by using its language tools and
component libraries.</p>
<p>Stay tuned!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Well-crafted functional architecture: ports and adapters</title>
      <link>https://neiro.io/posts/2019-10-01-well-crafted-functional-architecture-ports-and-adapters.md/</link>
      <pubDate>Tue, 01 Oct 2019 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2019-10-01-well-crafted-functional-architecture-ports-and-adapters.md/</guid>
      <description>&lt;p&gt;At &lt;a href=&#34;https://salam.io&#34;&gt;Salam.io&lt;/a&gt; we are developing a modern social&#xA;platform containing a humongous amount of features.&lt;/p&gt;&#xA;&lt;p&gt;Development of such product is quite hard and challenging - we need our&#xA;software to be robust, scalable, fault-tolerant, performant and at the&#xA;same time we want it to be easy to extend, test, maintain and support.&lt;/p&gt;&#xA;&lt;p&gt;All these issues are inevitable upon growth of the app but they for sure&#xA;can be simplified or even avoided by choosing, optimising the software&#xA;architecture.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>At <a href="https://salam.io">Salam.io</a> we are developing a modern social
platform containing a humongous amount of features.</p>
<p>Development of such product is quite hard and challenging - we need our
software to be robust, scalable, fault-tolerant, performant and at the
same time we want it to be easy to extend, test, maintain and support.</p>
<p>All these issues are inevitable upon growth of the app but they for sure
can be simplified or even avoided by choosing, optimising the software
architecture.</p>
<p>We also use functional programming languages -
<a href="https://clojure.org">Clojure</a> &amp; <a href="https://elixir-lang.org">Elixir</a> -
for the backend and frontend as much as possible. Therefore, we need to
adjust the existing architecture approaches to powerful abilities and
intricacies of modern functional programming.</p>
<p>That&rsquo;s why we&rsquo;re starting these series of articles - we think it&rsquo;s
crucial for everyone who&rsquo;s crafting the functional systems to understand
and apply software architectures rules and principles.</p>
<h2 id="why-ports-adapters">Why ports &amp; adapters ?</h2>
<p>Even if you&rsquo;re developing a relatively small scale software you still
need to design it first - and to design it properly. The earlier you
start caring about your architecture the earlier you can benefit from it
and the later a lot of issues caused by bad architecture would appear.</p>
<p>The main idea of ports &amp; adapters architecture is that application that
you&rsquo;re building is a <em>closed area</em>. This means that all your business
logic should be separated from technical details in this area. Often
architecture is about the boundaries so are the ports &amp; adapters.</p>
<p>In case you stick with ports &amp; adapters from the very beginning then
this approach should help you to keep your business logic separated and
easily tested s well as technology agnostic - you can write a port &amp; an
adapter for any software/third-party service/library that you&rsquo;re using
so it can be easily extended or switched in favour of another one.</p>
<h2 id="hexagonal">Hexagonal</h2>
<p>Ports &amp; adapters architecture also has another name: <em>Hexagonal
architecture</em>. According to this terminology the inner part of your
software - the place where you put your business logic - is hexagon
while your adapters are placed surround it.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Hexagonal_Architecture.svg/1000px-Hexagonal_Architecture.svg.png"
    alt="Figure 1: Hexagon"><figcaption>
      <p><span class="figure-number">Figure 1: </span>Hexagon</p>
    </figcaption>
</figure>

<p>The hexagon should not contain any references to another frameworks,
real world services, libraries, etc. - all these elements should be
adapters. At the same time the architecture doesn&rsquo;t prescribe you to
design your hexagon in some certain way - you can use Layer
architecture, Onion, DDD or any another suitable architecture inside or
it may be a pure business logic without any sophistications - it&rsquo;s up to
you.</p>
<p>Why hexagon? Well, any geometric figure with boundaries could work, but
the hexagon represents better the concept that you have ports at the
edges of your application and adapters behind it. Likewise, it&rsquo;s a
symmetric figure and we&rsquo;ll describe below why it&rsquo;s important.</p>
<h2 id="ports">Ports</h2>
<p>Every time you need to interact with something from beyond of your
application logic you need to group these actions and describe them in a
<em>port</em>. The port is the edge of hexagon and it should be an integral and
essential part of your application.</p>
<p>Naming of the ports is quite important - you shouldn&rsquo;t use any
technology name in your port but focus on its mission instead. Some of
examples:</p>
<ul>
<li>PushNotifications</li>
<li>Search</li>
<li>Persistence</li>
<li>Authentication</li>
</ul>
<p>The majority of programming languages usually contain interfaces /
protocols feature allowing you to build a port. In Clojure, for example,
you can use <em>multimethods</em> or <em>protocols</em> to achieve this goal. But for
now let&rsquo;s see how we can implement the realisation of port for Elixir
using its&rsquo; capability to create <strong>behaviours</strong>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule Core.PushNotifications do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Port for sending push notifications.
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    @type message :: %{title: String.t(), body: String.t()}
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    @type payload :: Keyword.t
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @type recipients :: [map]
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    @adapter :core |&gt; Application.fetch_env!(__MODULE__) |&gt; Keyword.fetch!(:adapter)
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    @callback send_notifications(message, recipients, payload) :: {:ok, [map]} | {:error, any}
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    defdelegate send_notifications(message, recipients, payload), to: @adapter
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>The example above is nothing more than an abstraction for using push
notifications from <code>Core</code>. We declare the behaviour and one callback
that specifies what we send and what we can expect as the result. The
exact implementation - adapter - should be placed in your app
configuration like:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  config :core, Core.PushNotifications, adapter: PushNotifications.APNS</span></span></code></pre></div><p>If you want to call this port from your application you just need to use
the delegated function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule Core do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    alias Core.PushNotifications
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def register_user(params) do
</span></span><span class="line"><span class="ln">5</span><span class="cl">      # business logic ...
</span></span><span class="line"><span class="ln">6</span><span class="cl">       result = PushNotifications.send_notifications(message, recipients, payload)
</span></span><span class="line"><span class="ln">7</span><span class="cl">      # handle the result somehow
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end
</span></span><span class="line"><span class="ln">9</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, from the <code>Core</code> we know nothing about the implementation
details - we just send notifications to users and that&rsquo;s it. In ideal
case we need to move <strong>any impure function, any side-effect</strong> to the edge
of the system - to adapters and call them <strong>only by using ports</strong> .</p>
<h2 id="driver-adapters">Driver Adapters</h2>
<p>Adapters are components which are placed outside of your application -
and your hexagon. They should represent the technology, service, library
that you need to interact through the port.</p>
<p>We specify two types of adapters: <em>Driver</em> and <em>Driven</em>.</p>
<p>The first ones are something from the left side of the picture above. It
could be a HTML page, API endpoint, CLI application, GUI or anything
that <em>drives</em> your application. That also means that the driver adapter
should use a driver port interface so your app receives technology
agnostic request on its borders.</p>
<p>Let&rsquo;s assume that we also have a web application that uses our <em>Core</em>.
If we want to register user then we need to call a
<code>Core.register_user/1</code> function from inside of our controller. In that
case <code>UserController</code> is our driver adapter and <code>Core</code> is the called
application. Fortunately, in Elixir we have type specs that can play a
role of specification of driver port so you&rsquo;ll always be able to see
what we need to send and what we should expect in response.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule Web.UserController do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    use Web, :controller
</span></span><span class="line"><span class="ln">3</span><span class="cl">
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def create(conn, params) do
</span></span><span class="line"><span class="ln">5</span><span class="cl">      result = Core.register_user(params) # will create user and send notifications
</span></span><span class="line"><span class="ln">6</span><span class="cl">     # handle the result somehow
</span></span><span class="line"><span class="ln">7</span><span class="cl">    end
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>In the approach above you can see that we use <code>Core.register_user/1</code>
function as the driver port - because it&rsquo;s spec describes the
interface - and <code>Web.UserController.index/2</code> as the driver adapter.</p>
<h2 id="driven-adapters">Driven Adapters</h2>
<p>A <em>Driven</em> adapter implements an interface given by driven port. That
means that now driven adapter depends on our application, but not visa
versa. The same as driver, this adapter should also be placed outside of
our hexagon and represents a technology/library/real-world device.</p>
<p>Common examples are:</p>
<ul>
<li>Persistence adapters - SQL, NoSQL databases or even in-memory / file
storage</li>
<li>Cache adapters - Redis / Memcached / ETS or in-memory storage</li>
<li>Email adapters - SMTP or third-party services</li>
<li>Message queue adapters</li>
<li>Third-party APIs</li>
</ul>
<p>Let&rsquo;s continue the push notifications solution we&rsquo;ve started before.
Now, in order to implement the driver adapter, we need to use the port
<code>Core.PushNotifications</code> and it&rsquo;s callback <code>send_notifications</code>. We will
adapt realisation of sending push notifications over APNS by the
specification that was given us by this port:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule PushNotifications.APNS do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;APNS adapter for push notifications&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @behaviour Core.PushNotifications
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    @impl true
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    def send_notifications(message, recipients, payload) do
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      {:ok, recipients
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      |&gt; Enum.map(fn r -&gt; build_notification(message, r, payload) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      |&gt; Pigeon.APNS.Notification.push()}
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp build_notification(message, recipient, payload) do
</span></span><span class="line"><span class="ln">13</span><span class="cl">       Pigeon.APNS.Notification.new(message, recipient.device_token, payload)
</span></span><span class="line"><span class="ln">14</span><span class="cl">     end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>Now our push notifications are almost completed. We can always change
the implementation - for example, from APNS to Firebase - or use
third-party library <strong>* without changing our core application*</strong> - so we
can say that&rsquo;s technology agnostic approach.</p>
<h2 id="testing">Testing</h2>
<p>Of course the main benefit of ports and adapters architecture is
improved testability. Instead of manually mocking calls to the
real-world providers we just need to create a test adapter that we
satisfy testing conditions. In the perfect case every <em>driven adapter</em>
should have a test analogue as well as all behaviours of <code>driver ports</code>
should be tested. Let&rsquo;s write a test adapter for the PushNotifications
port then:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule PushNotifications.TestAdapter do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;Test adapter for push notifications&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    @behaviour Core.PushNotifications
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">    @impl true
</span></span><span class="line"><span class="ln">6</span><span class="cl">    def send_notifications(message, recipients, payload) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">       {:ok, [%{message: message, payload: payload, recipients: recipients}]}
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end
</span></span><span class="line"><span class="ln">9</span><span class="cl">  end</span></span></code></pre></div><p>As you can see we are not sending data to the outer world but use a pure
function instead. In case of any incoming input we will know its&rsquo; output
for sure. Now, when we unit-test the <code>Core</code> module we just need to
select test adapter as the implementation of <code>PushNotifications</code>
interface. In Elixir ecosystem we have a great library called <code>Mox</code> that
can be used for such case:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  Mox.defmock(PushNotifications.TestMock, for: Core.PushNotifications)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule CoreTest do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    use Core.DataCase, async: true
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    import Mox
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">   # Make sure mocks are verified when the test exits
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    setup :verify_on_exit!
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">    test &#34;register/1&#34; do
</span></span><span class="line"><span class="ln">11</span><span class="cl">       stub_with(PushNotifications.TestMock, PushNotifications.TestAdapter)
</span></span><span class="line"><span class="ln">12</span><span class="cl">       assert {:ok, _} = Core.register_user(some_params)
</span></span><span class="line"><span class="ln">13</span><span class="cl">    end
</span></span><span class="line"><span class="ln">14</span><span class="cl">  end</span></span></code></pre></div><p>In this example you can see that we&rsquo;re not sending push notifications in
the real world but using the local test mock instead. We are free to
change the test adapter for any testing purposes if we want to.</p>
<p>From now you get your <em>driver</em> port&rsquo;s behaviour tested. As the next step
you can test exactly the adapter implementation without any outside
logic attached - you just need to check that your implementation is
working fine as it was predicted. As for the integration testing you&rsquo;re
free to choose between the real-world adapters or you may use some test
adapters for this purpose - it&rsquo;s up to you.</p>
<h2 id="pros-vs-cons">Pros vs Cons</h2>
<p>Now we&rsquo;ve covered the basics of ports and adapters architecture. Let&rsquo;s
summarise what we have:</p>
<h3 id="pros">Pros</h3>
<ul>
<li>Testability</li>
<li>Replaceability</li>
<li>Technology-agnostic approach - you can delay technological solutions</li>
<li>Isolating pure code from impure code</li>
<li>Isolating side-effects</li>
<li>Maintainability</li>
</ul>
<h3 id="cons">Cons</h3>
<ul>
<li>Sometimes it may be an overhead, especially for a small scale software</li>
<li>You may not need it if you are pretty sure that the technology stack
of your project will remain the same over the years</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>We applied ports &amp; adapters architecture at
<a href="https://salam.io">Salam.io</a> when it became clear that our software
will be using a lot of services which could be replaced in the future.
This approach has already given a lot of benefits and allowed us to make
our software even more testable and flexible.</p>
<p>If you want to know more about this architecture you can take a look at
the
<a href="https://web.archive.org/web/20180822100852/http://alistair.cockburn.us/Hexagonal&#43;architecture">original
article by Alistair Cockburn</a> .</p>
<p>In the next article of this series we will show how you can apply ports
&amp; adapters architecture in Clojure by using its language tools and
component libraries.</p>
<p>Stay tuned!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Seven reasons to use Elixir in 2019</title>
      <link>https://neiro.io/blog/2018-12-30-seven-reasons-to-use-elixir-in-2019.md/</link>
      <pubDate>Sun, 30 Dec 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/blog/2018-12-30-seven-reasons-to-use-elixir-in-2019.md/</guid>
      <description>&lt;p&gt;Currently Elixir is not one of the most popular programming languages&#xA;but for sure it is one of the most promising and underrated ones. Elixir&#xA;and it&amp;rsquo;s community has been growing and evolving this year steadily so&#xA;right now I can recommend it to everyone - no matter if you are a&#xA;business owner or you are an experienced developer or a total newbie -&#xA;it&amp;rsquo;s time to learn or adopt the new technology.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Currently Elixir is not one of the most popular programming languages
but for sure it is one of the most promising and underrated ones. Elixir
and it&rsquo;s community has been growing and evolving this year steadily so
right now I can recommend it to everyone - no matter if you are a
business owner or you are an experienced developer or a total newbie -
it&rsquo;s time to learn or adopt the new technology.</p>
<h2 id="reliability">Reliability</h2>
<p>Elixir seems to be like a fresh new programming language which was
created just a few years ago, in 2012, but it&rsquo;s not the full picture:
Elixir is really a friendly interface and tooling for Erlang virtual
machine (BEAM). And just to remind you, Erlang has been widely used
since the 80s to build reliable, fault-tolerant, concurrent and
distributed systems like backends, telephony, communications - and so
does Elixir.</p>
<p>If you want your service or server to be eternally available with
<em>almost zero</em> downtime then it could be a top match for you. Elixir has
all the powers of Erlang and provides even more libraries, tools and
opportunities.</p>
<h2 id="syntax-and-simplicity">Syntax and simplicity</h2>
<p>Erlang inherited its syntax and semantics mostly from Prolog - a logic
programmingÂ language associated withÂ artificial
intelligenceÂ andÂ computational linguistics. Right now it seems very aged
and clunky and not the best suitable for modern functional programming
language. Elixir, in contradistinction to Erlang, was heavily influenced
by Ruby and Clojure, and its syntax and semantics looks really fresh,
eloquent and easy to write and read. Elixir has really collected all the
best parts of these languages and Erlang to make developers much more
productive and efficient.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def list_users(ids) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">        User
</span></span><span class="line"><span class="ln">4</span><span class="cl">         |&gt; where([u], u.id in ^ids)
</span></span><span class="line"><span class="ln">5</span><span class="cl">         |&gt; order_by(asc: :inserted_at)
</span></span><span class="line"><span class="ln">6</span><span class="cl">         |&gt; Repo.all()
</span></span><span class="line"><span class="ln">7</span><span class="cl">    end
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>Elixir&rsquo;s syntax is beautiful yet simple enough. Of course it seems like
syntax sugar for Erlang but it&rsquo;s really enough to let you compose
programs in most elegant and simple way. There are no sophisticated and
intricate features that can mislead you. There is less room for mistakes
but much more possibilities to write a reliable, robust code in the most
expressive yet simple way. As a developer you can always be sure that
your Elixir&rsquo;s program will be predictable, explicit, easy to understand
and extend.</p>
<h2 id="scalability">Scalability</h2>
<p>Elixir VM&rsquo;s model of concurrency allows you to run your programs
efficiently on multi-core CPUs to use all the powers of your computer,
but it is not limited to only one machine - you can scale your
application on multiple machines and there are no any limitations. For
example,
<a href="http://phoenixframework.org/blog/the-road-to-2-million-websocket-connections">you
can have 2 million open web socket connections</a> or
<a href="https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b?gi=434344270ffd">5
000 000 concurrent users</a> .</p>
<p>Elixir&rsquo;s processes are extremely lightweight and it makes Elixir also
resource efficient - you don&rsquo;t need so many machines, CPUs or have
hundreds of GB of RAM to handle your load. But if you really need to
then your program will always be ready to scale both horizontally and
vertically.</p>
<h2 id="performance">Performance</h2>
<p>Elixir is very fast and performant. Its most popular web framework is
Phoenix
<a href="https://github.com/mroth/phoenix-showdown/blob/master/README.md#benchmarking">is
almost 10 times faster than Ruby on Rails and Node.js</a> . Phoenix is
much more consistent under the high load though. And as I&rsquo;ve said
before, Elixir is quite resource effective so the same web server
implemented in Elixir and Phoenix will handle much more load than Ruby
on Rails application and will consume much less RAM.</p>
<p>However, Elixir can be not so good when it comes to heavy computations,
but you can avoid the bottlenecks by using the native implemented
functions - NIFs - that allow you to
<a href="https://medium.com/@jacob.lerche/writing-rust-nifs-for-your-elixir-code-with-the-rustler-package-d884a7c0dbe3">rewrite
problematic code to make it way more performant</a>.</p>
<h2 id="functional-programming">Functional programming</h2>
<p>Elixir is a functional programming language and it encourages you to
write pure, side-effect free functions, keep your logic and data
separated and your variables immutable. Elixir has first-class
functions, functions composition, closures, high-order functions,
pattern-matching - all that you really need to write your programs
according to the functional programming paradigm.</p>
<p>All these features made Elixir&rsquo;s concurrency model so simple and easy to
use. You shouldn&rsquo;t be afraid to communicate between different processes,
nodes, machines but be insured from the most concurrency issues.</p>
<h2 id="tooling">Tooling</h2>
<p>Elixir has a plethora of great tools and instruments that helps
developers to write, test, build, deploy and debug their applications.</p>
<ul>
<li>Package manager</li>
<li>Interactive shell</li>
<li>Code formatter</li>
<li><a href="https://github.com/bitwalker/distillery">Packing into releases</a></li>
<li><a href="https://github.com/edeliver/edeliver">Deployment tool</a></li>
<li><a href="https://medium.com/@neiro/elixir-code-quality-tools-and-checks-315ab9e9d7ea">Linters
and quality checks</a></li>
<li><a href="https://github.com/jeremyjh/dialyxir">Discrepancy analyzer</a></li>
<li><a href="https://github.com/parapluu/Concuerror">Concurrency errors checker</a></li>
<li><a href="https://github.com/josefs/Gradualizer">Gradual types system</a></li>
<li><a href="https://github.com/JakeBecker/elixir-ls">Frontend-independent
language-server</a></li>
<li>And even more!</li>
</ul>
<h2 id="community">Community</h2>
<p>Elixir was invented by Jose Valim who was a former Ruby on Rails
community participant. Starting from the very beginning many people have
switched from Ruby and Python to Elixir. Elixir&rsquo;s community is quite
friendly, responsive and welcoming, it&rsquo;s easy to find help or advice
there. Elixir could be your first programming language or tenth - it
doesn&rsquo;t matter, you will get support in any case.</p>
<p>Right now there are <a href="https://github.com/h4cc/awesome-elixir">so many
tools and libraries in Elixir</a> and
<a href="https://github.com/drobakowski/awesome-erlang">so in Erlang</a>.</p>
<h2 id="summary">Summary</h2>
<p>If you want so start your new 2019 year from a little adventure then you
can learn Elixir or adopt it in your business. It suits very well for
any server-side applications, web applications, embedded systems,
scripts. You can start by reading the
<a href="https://elixir-lang.org/learning.html">learning resources</a> or try
<a href="https://elixirschool.com">Elixir School</a>.</p>
<p>We are 100% happy with Elixir as the core technology in our modern
social platform <a href="https://salam.io">Salam.io</a> and really want to
encourage anyone to give Elixir a try in their projects.</p>
<p>Happy hacking everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Seven reasons to use Elixir in 2019</title>
      <link>https://neiro.io/posts/2018-12-30-seven-reasons-to-use-elixir-in-2019.md/</link>
      <pubDate>Sun, 30 Dec 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/posts/2018-12-30-seven-reasons-to-use-elixir-in-2019.md/</guid>
      <description>&lt;p&gt;Currently Elixir is not one of the most popular programming languages&#xA;but for sure it is one of the most promising and underrated ones. Elixir&#xA;and it&amp;rsquo;s community has been growing and evolving this year steadily so&#xA;right now I can recommend it to everyone - no matter if you are a&#xA;business owner or you are an experienced developer or a total newbie -&#xA;it&amp;rsquo;s time to learn or adopt the new technology.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Currently Elixir is not one of the most popular programming languages
but for sure it is one of the most promising and underrated ones. Elixir
and it&rsquo;s community has been growing and evolving this year steadily so
right now I can recommend it to everyone - no matter if you are a
business owner or you are an experienced developer or a total newbie -
it&rsquo;s time to learn or adopt the new technology.</p>
<h2 id="reliability">Reliability</h2>
<p>Elixir seems to be like a fresh new programming language which was
created just a few years ago, in 2012, but it&rsquo;s not the full picture:
Elixir is really a friendly interface and tooling for Erlang virtual
machine (BEAM). And just to remind you, Erlang has been widely used
since the 80s to build reliable, fault-tolerant, concurrent and
distributed systems like backends, telephony, communications - and so
does Elixir.</p>
<p>If you want your service or server to be eternally available with
<em>almost zero</em> downtime then it could be a top match for you. Elixir has
all the powers of Erlang and provides even more libraries, tools and
opportunities.</p>
<h2 id="syntax-and-simplicity">Syntax and simplicity</h2>
<p>Erlang inherited its syntax and semantics mostly from Prolog - a logic
programmingÂ language associated withÂ artificial
intelligenceÂ andÂ computational linguistics. Right now it seems very aged
and clunky and not the best suitable for modern functional programming
language. Elixir, in contradistinction to Erlang, was heavily influenced
by Ruby and Clojure, and its syntax and semantics looks really fresh,
eloquent and easy to write and read. Elixir has really collected all the
best parts of these languages and Erlang to make developers much more
productive and efficient.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def list_users(ids) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">        User
</span></span><span class="line"><span class="ln">4</span><span class="cl">         |&gt; where([u], u.id in ^ids)
</span></span><span class="line"><span class="ln">5</span><span class="cl">         |&gt; order_by(asc: :inserted_at)
</span></span><span class="line"><span class="ln">6</span><span class="cl">         |&gt; Repo.all()
</span></span><span class="line"><span class="ln">7</span><span class="cl">    end
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>Elixir&rsquo;s syntax is beautiful yet simple enough. Of course it seems like
syntax sugar for Erlang but it&rsquo;s really enough to let you compose
programs in most elegant and simple way. There are no sophisticated and
intricate features that can mislead you. There is less room for mistakes
but much more possibilities to write a reliable, robust code in the most
expressive yet simple way. As a developer you can always be sure that
your Elixir&rsquo;s program will be predictable, explicit, easy to understand
and extend.</p>
<h2 id="scalability">Scalability</h2>
<p>Elixir VM&rsquo;s model of concurrency allows you to run your programs
efficiently on multi-core CPUs to use all the powers of your computer,
but it is not limited to only one machine - you can scale your
application on multiple machines and there are no any limitations. For
example,
<a href="http://phoenixframework.org/blog/the-road-to-2-million-websocket-connections">you
can have 2 million open web socket connections</a> or
<a href="https://blog.discordapp.com/scaling-elixir-f9b8e1e7c29b?gi=434344270ffd">5
000 000 concurrent users</a> .</p>
<p>Elixir&rsquo;s processes are extremely lightweight and it makes Elixir also
resource efficient - you don&rsquo;t need so many machines, CPUs or have
hundreds of GB of RAM to handle your load. But if you really need to
then your program will always be ready to scale both horizontally and
vertically.</p>
<h2 id="performance">Performance</h2>
<p>Elixir is very fast and performant. Its most popular web framework is
Phoenix
<a href="https://github.com/mroth/phoenix-showdown/blob/master/README.md#benchmarking">is
almost 10 times faster than Ruby on Rails and Node.js</a> . Phoenix is
much more consistent under the high load though. And as I&rsquo;ve said
before, Elixir is quite resource effective so the same web server
implemented in Elixir and Phoenix will handle much more load than Ruby
on Rails application and will consume much less RAM.</p>
<p>However, Elixir can be not so good when it comes to heavy computations,
but you can avoid the bottlenecks by using the native implemented
functions - NIFs - that allow you to
<a href="https://medium.com/@jacob.lerche/writing-rust-nifs-for-your-elixir-code-with-the-rustler-package-d884a7c0dbe3">rewrite
problematic code to make it way more performant</a>.</p>
<h2 id="functional-programming">Functional programming</h2>
<p>Elixir is a functional programming language and it encourages you to
write pure, side-effect free functions, keep your logic and data
separated and your variables immutable. Elixir has first-class
functions, functions composition, closures, high-order functions,
pattern-matching - all that you really need to write your programs
according to the functional programming paradigm.</p>
<p>All these features made Elixir&rsquo;s concurrency model so simple and easy to
use. You shouldn&rsquo;t be afraid to communicate between different processes,
nodes, machines but be insured from the most concurrency issues.</p>
<h2 id="tooling">Tooling</h2>
<p>Elixir has a plethora of great tools and instruments that helps
developers to write, test, build, deploy and debug their applications.</p>
<ul>
<li>Package manager</li>
<li>Interactive shell</li>
<li>Code formatter</li>
<li><a href="https://github.com/bitwalker/distillery">Packing into releases</a></li>
<li><a href="https://github.com/edeliver/edeliver">Deployment tool</a></li>
<li><a href="https://medium.com/@neiro/elixir-code-quality-tools-and-checks-315ab9e9d7ea">Linters
and quality checks</a></li>
<li><a href="https://github.com/jeremyjh/dialyxir">Discrepancy analyzer</a></li>
<li><a href="https://github.com/parapluu/Concuerror">Concurrency errors checker</a></li>
<li><a href="https://github.com/josefs/Gradualizer">Gradual types system</a></li>
<li><a href="https://github.com/JakeBecker/elixir-ls">Frontend-independent
language-server</a></li>
<li>And even more!</li>
</ul>
<h2 id="community">Community</h2>
<p>Elixir was invented by Jose Valim who was a former Ruby on Rails
community participant. Starting from the very beginning many people have
switched from Ruby and Python to Elixir. Elixir&rsquo;s community is quite
friendly, responsive and welcoming, it&rsquo;s easy to find help or advice
there. Elixir could be your first programming language or tenth - it
doesn&rsquo;t matter, you will get support in any case.</p>
<p>Right now there are <a href="https://github.com/h4cc/awesome-elixir">so many
tools and libraries in Elixir</a> and
<a href="https://github.com/drobakowski/awesome-erlang">so in Erlang</a>.</p>
<h2 id="summary">Summary</h2>
<p>If you want so start your new 2019 year from a little adventure then you
can learn Elixir or adopt it in your business. It suits very well for
any server-side applications, web applications, embedded systems,
scripts. You can start by reading the
<a href="https://elixir-lang.org/learning.html">learning resources</a> or try
<a href="https://elixirschool.com">Elixir School</a>.</p>
<p>We are 100% happy with Elixir as the core technology in our modern
social platform <a href="https://salam.io">Salam.io</a> and really want to
encourage anyone to give Elixir a try in their projects.</p>
<p>Happy hacking everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Asynchronous testing in Elixir with Mox</title>
      <link>https://neiro.io/blog/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</link>
      <pubDate>Sun, 29 Jul 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</guid>
      <description>&lt;p&gt;Testing in Elixir is pretty neat. You can easily test anything written,&#xA;you have instruments like ExUnit or ESpec, you can&#xA;&lt;a href=&#34;https://github.com/lpil/mix-test.watch&#34;&gt;practice TDD&lt;/a&gt; and more and&#xA;more. Functional programming paradigm helps you a lot to make your&#xA;testing even simpler by forcing you to use pure, small functions that&#xA;will be pleasant to test. Concurrency of Elixir allows you to run all&#xA;your tests asynchronously and blazingly fast.&lt;/p&gt;&#xA;&lt;p&gt;However, there can be some pitfalls.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Testing in Elixir is pretty neat. You can easily test anything written,
you have instruments like ExUnit or ESpec, you can
<a href="https://github.com/lpil/mix-test.watch">practice TDD</a> and more and
more. Functional programming paradigm helps you a lot to make your
testing even simpler by forcing you to use pure, small functions that
will be pleasant to test. Concurrency of Elixir allows you to run all
your tests asynchronously and blazingly fast.</p>
<p>However, there can be some pitfalls.</p>
<h2 id="mocks-problem">Mocks problem</h2>
<p>If you&rsquo;re programming a big project then I suppose that you will be
using third-party services anyway. Imagine that you are sending SMS
through you favorite provider services. This code can look like that:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>In this case you are using some external provider API in order to send
SMS. The HTTP request will go from your application to the destination
and it will trigger SMS delivery.</p>
<p>Now we need to test this situation. This will be our very first
approach:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>As you can see it will behave as if it was on production. Your SMS with
the nasty fake test message will be delivered to non-existent users with
absent phone numbers. Sad!</p>
<p>The most popular solution is mocking. You&rsquo;re supposing that call of
<code>send_sms</code> function with the expected arguments which will return the
expected result:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mock(SmsProvider, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}} end)
</span></span><span class="line"><span class="ln">2</span><span class="cl">  assert {:ok, %Message{status: :sent}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>This approach will work, at least for this test. The problem is simple
enough - it&rsquo;s not the best solution for asynchronous tests. We have
mocked SmsProvider so it will be overriden in every next asynchronous
test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  use MyApp.DataCase, async: true
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  # ...
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  assert {:error, :wrong_phone_number} = SmsProvider.send_sms(wrong_number, to, &#34;message&#34;)</span></span></code></pre></div><p>This test will fail because <code>send_sms</code> call was already mocked in
another test earlier. The entire mocking approach is not suitable for
concurrent testing, so we need to find another one to serve this
purpose.</p>
<h2 id="asynchronous-testing">Asynchronous testing</h2>
<p>Instead of mocking we can try calling the function that will override
<code>sms_send/3</code>. Let&rsquo;s create a <code>TestProvider</code> module with the next
content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def send_sms(from, to, message) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, %Message{status: :sent, from: from, to: to, text: message}}
</span></span><span class="line"><span class="ln">4</span><span class="cl">    end
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end</span></span></code></pre></div><p>Now we can try to use this module as an adapter in our <code>SmsProvider</code>
module. It will use default adapter in development, production
environments and will use <code>TestProvider</code> in testing:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # config/test.exs
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  config :my_app, SmsProvider, adapter: TestProvider
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  # config/config.exs
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  config :my_app, SmsProvider, adapter: SmsApiService
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @adapter Application.fetch_env(:my_app, :sms_provider, :adapter)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    defdelegate send_sms(from, to, message), to: @adapter
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end</span></span></code></pre></div><p>Let&rsquo;s go straight to the test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;) # true</span></span></code></pre></div><p>Now it should work even in concurrent tests. Your SMS will not be
delivered neither to the real nor fake users, your money will be saved
and your tests will not suffer more.</p>
<h2 id="using-mox">Using Mox</h2>
<p>However, there is still a room for improvement.</p>
<p><a href="https://github.com/plataformatec/mox">Mox</a> is a relatively new
library that solves the issue of concurrent testing and mocks. It
follows the next principles:</p>
<ul>
<li>You can only create mocks based on behaviours</li>
<li>No dynamic generation of mocked modules, every mock should be defined
in tests</li>
<li>Full concurrency support</li>
<li>Use of pattern matching and function clauses for asserting</li>
</ul>
<p>Now let&rsquo;s add it to our dependencies list:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  # mix.exs
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def deps do
</span></span><span class="line"><span class="ln">3</span><span class="cl">    [
</span></span><span class="line"><span class="ln">4</span><span class="cl">      {:mox, &#34;~&gt; 0.4&#34;, only: :test}
</span></span><span class="line"><span class="ln">5</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  end</span></span></code></pre></div><p>It&rsquo;s easy as a pie to rewrite our tests with Mox. We need to create an
SMS provider behaviour and implement it for different environments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  # test_helper.exs
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  Mox.defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">  defmodule Test do
</span></span><span class="line"><span class="ln">12</span><span class="cl">    use ExUnit.Case, async: true
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    import Mox
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    # Make sure mocks are verified when the test exits
</span></span><span class="line"><span class="ln">17</span><span class="cl">    setup :verify_on_exit!
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    test &#34;returns message on success&#34; do
</span></span><span class="line"><span class="ln">20</span><span class="cl">      expect SmsProviderMock, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}}
</span></span><span class="line"><span class="ln">21</span><span class="cl">      assert {:ok, %{status: :sent}} = SmsProvider.send_sms(from, to, message)
</span></span><span class="line"><span class="ln">22</span><span class="cl">    end
</span></span><span class="line"><span class="ln">23</span><span class="cl">  end</span></span></code></pre></div><p>If you don&rsquo;t need to check expectations in test you can try
<code>stub_with/2</code> function in order to stub entire module:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @callback sent_sms(String.t) :: [%Message{}]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # test_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @behaviour SmsProvider
</span></span><span class="line"><span class="ln">10</span><span class="cl">    def send_sms(_from, _to, message), do: {:ok, %Message{status: :sent, message: message}}
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def sent_sms(number) :: [%Message{}]
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">15</span><span class="cl">  defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  stub_with(SmsProviderMock, TestProvider)</span></span></code></pre></div><p>Viola! Now your tests are all green, fast and shiny thanks to concurrent
testing and Mox :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>If you&rsquo;re definitely interested in concurrent testing, you might want to
read
<a href="http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/">excellent
article from Jose Valim</a> and dive in into
<a href="https://hexdocs.pm/mox/Mox.html">Mox documentation</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Asynchronous testing in Elixir with Mox</title>
      <link>https://neiro.io/posts/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</link>
      <pubDate>Sun, 29 Jul 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</guid>
      <description>&lt;p&gt;Testing in Elixir is pretty neat. You can easily test anything written,&#xA;you have instruments like ExUnit or ESpec, you can&#xA;&lt;a href=&#34;https://github.com/lpil/mix-test.watch&#34;&gt;practice TDD&lt;/a&gt; and more and&#xA;more. Functional programming paradigm helps you a lot to make your&#xA;testing even simpler by forcing you to use pure, small functions that&#xA;will be pleasant to test. Concurrency of Elixir allows you to run all&#xA;your tests asynchronously and blazingly fast.&lt;/p&gt;&#xA;&lt;p&gt;However, there can be some pitfalls.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Testing in Elixir is pretty neat. You can easily test anything written,
you have instruments like ExUnit or ESpec, you can
<a href="https://github.com/lpil/mix-test.watch">practice TDD</a> and more and
more. Functional programming paradigm helps you a lot to make your
testing even simpler by forcing you to use pure, small functions that
will be pleasant to test. Concurrency of Elixir allows you to run all
your tests asynchronously and blazingly fast.</p>
<p>However, there can be some pitfalls.</p>
<h2 id="mocks-problem">Mocks problem</h2>
<p>If you&rsquo;re programming a big project then I suppose that you will be
using third-party services anyway. Imagine that you are sending SMS
through you favorite provider services. This code can look like that:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>In this case you are using some external provider API in order to send
SMS. The HTTP request will go from your application to the destination
and it will trigger SMS delivery.</p>
<p>Now we need to test this situation. This will be our very first
approach:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>As you can see it will behave as if it was on production. Your SMS with
the nasty fake test message will be delivered to non-existent users with
absent phone numbers. Sad!</p>
<p>The most popular solution is mocking. You&rsquo;re supposing that call of
<code>send_sms</code> function with the expected arguments which will return the
expected result:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mock(SmsProvider, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}} end)
</span></span><span class="line"><span class="ln">2</span><span class="cl">  assert {:ok, %Message{status: :sent}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>This approach will work, at least for this test. The problem is simple
enough - it&rsquo;s not the best solution for asynchronous tests. We have
mocked SmsProvider so it will be overriden in every next asynchronous
test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  use MyApp.DataCase, async: true
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  # ...
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  assert {:error, :wrong_phone_number} = SmsProvider.send_sms(wrong_number, to, &#34;message&#34;)</span></span></code></pre></div><p>This test will fail because <code>send_sms</code> call was already mocked in
another test earlier. The entire mocking approach is not suitable for
concurrent testing, so we need to find another one to serve this
purpose.</p>
<h2 id="asynchronous-testing">Asynchronous testing</h2>
<p>Instead of mocking we can try calling the function that will override
<code>sms_send/3</code>. Let&rsquo;s create a <code>TestProvider</code> module with the next
content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def send_sms(from, to, message) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, %Message{status: :sent, from: from, to: to, text: message}}
</span></span><span class="line"><span class="ln">4</span><span class="cl">    end
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end</span></span></code></pre></div><p>Now we can try to use this module as an adapter in our <code>SmsProvider</code>
module. It will use default adapter in development, production
environments and will use <code>TestProvider</code> in testing:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # config/test.exs
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  config :my_app, SmsProvider, adapter: TestProvider
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  # config/config.exs
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  config :my_app, SmsProvider, adapter: SmsApiService
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @adapter Application.fetch_env(:my_app, :sms_provider, :adapter)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    defdelegate send_sms(from, to, message), to: @adapter
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end</span></span></code></pre></div><p>Let&rsquo;s go straight to the test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;) # true</span></span></code></pre></div><p>Now it should work even in concurrent tests. Your SMS will not be
delivered neither to the real nor fake users, your money will be saved
and your tests will not suffer more.</p>
<h2 id="using-mox">Using Mox</h2>
<p>However, there is still a room for improvement.</p>
<p><a href="https://github.com/plataformatec/mox">Mox</a> is a relatively new
library that solves the issue of concurrent testing and mocks. It
follows the next principles:</p>
<ul>
<li>You can only create mocks based on behaviours</li>
<li>No dynamic generation of mocked modules, every mock should be defined
in tests</li>
<li>Full concurrency support</li>
<li>Use of pattern matching and function clauses for asserting</li>
</ul>
<p>Now let&rsquo;s add it to our dependencies list:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  # mix.exs
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def deps do
</span></span><span class="line"><span class="ln">3</span><span class="cl">    [
</span></span><span class="line"><span class="ln">4</span><span class="cl">      {:mox, &#34;~&gt; 0.4&#34;, only: :test}
</span></span><span class="line"><span class="ln">5</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  end</span></span></code></pre></div><p>It&rsquo;s easy as a pie to rewrite our tests with Mox. We need to create an
SMS provider behaviour and implement it for different environments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  # test_helper.exs
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  Mox.defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">  defmodule Test do
</span></span><span class="line"><span class="ln">12</span><span class="cl">    use ExUnit.Case, async: true
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    import Mox
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    # Make sure mocks are verified when the test exits
</span></span><span class="line"><span class="ln">17</span><span class="cl">    setup :verify_on_exit!
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    test &#34;returns message on success&#34; do
</span></span><span class="line"><span class="ln">20</span><span class="cl">      expect SmsProviderMock, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}}
</span></span><span class="line"><span class="ln">21</span><span class="cl">      assert {:ok, %{status: :sent}} = SmsProvider.send_sms(from, to, message)
</span></span><span class="line"><span class="ln">22</span><span class="cl">    end
</span></span><span class="line"><span class="ln">23</span><span class="cl">  end</span></span></code></pre></div><p>If you don&rsquo;t need to check expectations in test you can try
<code>stub_with/2</code> function in order to stub entire module:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @callback sent_sms(String.t) :: [%Message{}]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # test_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @behaviour SmsProvider
</span></span><span class="line"><span class="ln">10</span><span class="cl">    def send_sms(_from, _to, message), do: {:ok, %Message{status: :sent, message: message}}
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def sent_sms(number) :: [%Message{}]
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">15</span><span class="cl">  defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  stub_with(SmsProviderMock, TestProvider)</span></span></code></pre></div><p>Viola! Now your tests are all green, fast and shiny thanks to concurrent
testing and Mox :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>If you&rsquo;re definitely interested in concurrent testing, you might want to
read
<a href="http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/">excellent
article from Jose Valim</a> and dive in into
<a href="https://hexdocs.pm/mox/Mox.html">Mox documentation</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir continious integration with CircleCI</title>
      <link>https://neiro.io/blog/2018-06-19-elixir-continious-integration-with-circleci.md/</link>
      <pubDate>Tue, 19 Jun 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2018-06-19-elixir-continious-integration-with-circleci.md/</guid>
      <description>&lt;p&gt;Elixir programming language has gained popularity and now it is&#xA;supported at many platforms, including plenty of CI services. In this&#xA;article we will see how we can achieve seamless and &lt;em&gt;(almost)&lt;/em&gt; dead&#xA;simple continious integration by using CircleCI in our Elixir projects.&lt;/p&gt;&#xA;&lt;h2 id=&#34;circleci-2.0&#34;&gt;CircleCI 2.0&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com&#34;&gt;CircleCI&lt;/a&gt; is one of the most popular and&#xA;user-friendly continious integration solutions. It supports many&#xA;programming languages and tools, including Elixir and Erlang/OTP.&lt;/p&gt;&#xA;&lt;p&gt;CircleCI is entirely free when it comes to open-source GitHub&#xA;repositories, but it also provides free 1500 minutes a month for any&#xA;private repos.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has gained popularity and now it is
supported at many platforms, including plenty of CI services. In this
article we will see how we can achieve seamless and <em>(almost)</em> dead
simple continious integration by using CircleCI in our Elixir projects.</p>
<h2 id="circleci-2.0">CircleCI 2.0</h2>
<p><a href="https://circleci.com">CircleCI</a> is one of the most popular and
user-friendly continious integration solutions. It supports many
programming languages and tools, including Elixir and Erlang/OTP.</p>
<p>CircleCI is entirely free when it comes to open-source GitHub
repositories, but it also provides free 1500 minutes a month for any
private repos.</p>
<p>Starting version 2.0 CircleCI can create jobs based on any images from
<a href="https://hub.docker.com/">DockerHub</a>. This feature makes possible to
build any programming language or platform that can be placed in Docker
image.</p>
<p>Imagine you have a standard Elixir Phoenix / Ecto application. You need
to run it on the latest versions of Elixir and Erlang/OTP and run the
tests on PostgreSQL database.</p>
<p>Let&rsquo;s start by creating a CircleCI configuration file in
<code>.circleci/config.yml</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  version: 2  # use CircleCI 2.0 instead of CircleCI Classic
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  jobs:  # basic units of work in a run
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build:  # runs not using Workflows must have a `build` job as entry point
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      parallelism: 1  # run only one instance of this job in parallel
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      docker:  # run the steps with Docker
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - image: circleci/elixir:1.6 # ...with this image as the primary container; this is where all `steps` will run
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            MIX_ENV: test
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - image: mdillon/postgis:9.6-alpine  # database image
</span></span><span class="line"><span class="ln">11</span><span class="cl">          environment:  # environment variables for database
</span></span><span class="line"><span class="ln">12</span><span class="cl">            POSTGRES_DB: app_test
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      steps:  # commands that comprise the `build` job
</span></span><span class="line"><span class="ln">15</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)</span></span></code></pre></div><p>As you can see here, we are declaring the <code>build</code> continious integration
job. Basically we will use the Elixir 1.6 with PostgreSQL 9.6 to run
tests on the <code>app_test</code> database. After that we will checkout source
code base to fetch our recent changes into the build. <code>mix local</code> tasks
are also necessary in order to use any of <em>Mix</em> tasks later.</p>
<h2 id="running-tests-and-code-quality">Running tests and code quality</h2>
<p>All of us want to run all common continious integration steps such as:</p>
<ul>
<li>Fetch dependencies and compile application</li>
<li>Run code quality tools and checks (<em>you can read more about it
<a href="https://neiro.io/2018/04/28/elixir-code-quality-tools-and-checks.html">here</a>)</em></li>
<li>Execute all tests to make sure that our build is successful and
infallible</li>
<li>Run heavy and bulky static analysis tools</li>
</ul>
<p>Also we want to make our builds as fast as possible, so we definitely
need caching. Let&rsquo;s continue with our config and implement the steps
above:</p>
<p>{% raw %}</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">        - restore_cache:  # restores saved mix cache
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">            keys:  # list of cache keys, in decreasing specificity
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">              - v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">              - v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">              - v1-mix-cache
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - restore_cache:  # restores saved build cache
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">              - v1-build-cache
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - restore_cache:  # restores saved plt cache
</span></span><span class="line"><span class="ln">11</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln">12</span><span class="cl">              - dialyzer-cache
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - save_cache:  # generate and store cache so `restore_cache` works
</span></span><span class="line"><span class="ln">17</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln">18</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">19</span><span class="cl">        - save_cache:  # make another less specific cache
</span></span><span class="line"><span class="ln">20</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">21</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - save_cache:  # you should really save one more cache just in case
</span></span><span class="line"><span class="ln">23</span><span class="cl">            key: v1-mix-cache
</span></span><span class="line"><span class="ln">24</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - save_cache: # don&#39;t forget to save a *build* cache, too
</span></span><span class="line"><span class="ln">26</span><span class="cl">            key: v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">27</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">28</span><span class="cl">        - save_cache: # and one more build cache for good measure
</span></span><span class="line"><span class="ln">29</span><span class="cl">            key: v1-build-cache
</span></span><span class="line"><span class="ln">30</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">        - run: mix do format --check-formatted, credo --strict, security
</span></span><span class="line"><span class="ln">33</span><span class="cl">        - run: mix do xref deprecated --include-siblings, xref unreachable --include-siblings, xref graph --format stats
</span></span><span class="line"><span class="ln">34</span><span class="cl">
</span></span><span class="line"><span class="ln">35</span><span class="cl">        - run:  # special utility that stalls main process until DB is ready
</span></span><span class="line"><span class="ln">36</span><span class="cl">            name: Wait for DB
</span></span><span class="line"><span class="ln">37</span><span class="cl">            command: dockerize -wait tcp://localhost:5432 -timeout 1m
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">        - run: mix do ecto.migrations, ecto.load
</span></span><span class="line"><span class="ln">40</span><span class="cl">        - run: mix test  # run all tests in project
</span></span><span class="line"><span class="ln">41</span><span class="cl">
</span></span><span class="line"><span class="ln">42</span><span class="cl">        - run: mix dialyzer --halt-exit-status
</span></span><span class="line"><span class="ln">43</span><span class="cl">        - save_cache:
</span></span><span class="line"><span class="ln">44</span><span class="cl">            key: dialyzer-cache
</span></span><span class="line"><span class="ln">45</span><span class="cl">            paths: &#34;_build/test/dialyxir*.plt&#34;
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">        - store_test_results:  # upload test results for display in Test Summary
</span></span><span class="line"><span class="ln">48</span><span class="cl">            path: _build/test/lib/app/results.xml</span></span></code></pre></div><p>{% endraw %}</p>
<p>Now you can start new builds by signing up into CircleCI as it will run
the configuration and steps from your config. Every commit in any branch
will run the build job and you will know if something is wrong with your
code.</p>
<h2 id="deploying">Deploying</h2>
<p>However, having only one build job is not enough even for the simplest
CI process. Most often we need to make a staging/production release by
using <a href="https://github.com/bitwalker/distillery">Distillery</a>.</p>
<p>Let&rsquo;s continue filling up our configuration file by adding a new
<code>deploy</code> job:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    deploy:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      docker:
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        - image: circleci/elixir:1.6
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            MIX_ENV: staging
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      steps:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">11</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        # set MIX_ENV to prod or staging value according to the source branch
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - run:
</span></span><span class="line"><span class="ln">17</span><span class="cl">            name: Update MIX_ENV environment variable
</span></span><span class="line"><span class="ln">18</span><span class="cl">            command: |
</span></span><span class="line"><span class="ln">19</span><span class="cl">              echo &#34;export MIX_ENV=$(if [ &#39;$CIRCLE_BRANCH&#39; &#39;==&#39; &#39;master&#39; ]; then echo &#39;prod&#39;; else echo &#39;staging&#39;; fi)&#34; &gt;&gt; $BASH_ENV
</span></span><span class="line"><span class="ln">20</span><span class="cl">              source $BASH_ENV
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - run: cd deps/argon2_elixir &amp;&amp; make clean &amp;&amp; make &amp;&amp; cd -
</span></span><span class="line"><span class="ln">23</span><span class="cl">        - run: MIX_ENV=staging mix release --env $MIX_ENV
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - run: tar -zcvf $CIRCLE_SHA1.tar.gz bin appspec.yml VERSION _build/$MIX_ENV/rel/app/releases/$(cat VERSION)/app.tar.gz</span></span></code></pre></div><p>This will be enough to create a separate deploy job that will run on a
separate Docker image. However, we will need to run it only on develop
and master branches in order to upload staging/production releases
accordingly. We can achieve this by using CircleCI workflow and
providing a simple configuration at the bottom of our config file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  workflows:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    version: 2
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build-and-deploy:
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      jobs:
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        - build
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - deploy:
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            requires:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - build
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            filters:
</span></span><span class="line"><span class="ln">10</span><span class="cl">              branches:
</span></span><span class="line"><span class="ln">11</span><span class="cl">                only:
</span></span><span class="line"><span class="ln">12</span><span class="cl">                  - develop
</span></span><span class="line"><span class="ln">13</span><span class="cl">                  - master</span></span></code></pre></div><p>After that you are free to upload the built release to any server or any
platform you want. You can use Edeliver, Ansible, Chef, Docker - it&rsquo;s up
to you.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see above, it&rsquo;s not so hard to build and deploy Elixir
applications with CircleCI 2.0. This platform is flexible and fast
enough to make your continious integration bright and shiny.</p>
<p>If you want to discover even more on the topic then let&rsquo;s read
<a href="https://circleci.com/docs/2.0/">CircleCI 2.0 documentation</a> and
<a href="https://circleci.com/docs/2.0/language-elixir/">Elixir Language
Guide</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir continious integration with CircleCI</title>
      <link>https://neiro.io/posts/2018-06-19-elixir-continious-integration-with-circleci.md/</link>
      <pubDate>Tue, 19 Jun 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2018-06-19-elixir-continious-integration-with-circleci.md/</guid>
      <description>&lt;p&gt;Elixir programming language has gained popularity and now it is&#xA;supported at many platforms, including plenty of CI services. In this&#xA;article we will see how we can achieve seamless and &lt;em&gt;(almost)&lt;/em&gt; dead&#xA;simple continious integration by using CircleCI in our Elixir projects.&lt;/p&gt;&#xA;&lt;h2 id=&#34;circleci-2.0&#34;&gt;CircleCI 2.0&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com&#34;&gt;CircleCI&lt;/a&gt; is one of the most popular and&#xA;user-friendly continious integration solutions. It supports many&#xA;programming languages and tools, including Elixir and Erlang/OTP.&lt;/p&gt;&#xA;&lt;p&gt;CircleCI is entirely free when it comes to open-source GitHub&#xA;repositories, but it also provides free 1500 minutes a month for any&#xA;private repos.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has gained popularity and now it is
supported at many platforms, including plenty of CI services. In this
article we will see how we can achieve seamless and <em>(almost)</em> dead
simple continious integration by using CircleCI in our Elixir projects.</p>
<h2 id="circleci-2.0">CircleCI 2.0</h2>
<p><a href="https://circleci.com">CircleCI</a> is one of the most popular and
user-friendly continious integration solutions. It supports many
programming languages and tools, including Elixir and Erlang/OTP.</p>
<p>CircleCI is entirely free when it comes to open-source GitHub
repositories, but it also provides free 1500 minutes a month for any
private repos.</p>
<p>Starting version 2.0 CircleCI can create jobs based on any images from
<a href="https://hub.docker.com/">DockerHub</a>. This feature makes possible to
build any programming language or platform that can be placed in Docker
image.</p>
<p>Imagine you have a standard Elixir Phoenix / Ecto application. You need
to run it on the latest versions of Elixir and Erlang/OTP and run the
tests on PostgreSQL database.</p>
<p>Let&rsquo;s start by creating a CircleCI configuration file in
<code>.circleci/config.yml</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  version: 2  # use CircleCI 2.0 instead of CircleCI Classic
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  jobs:  # basic units of work in a run
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build:  # runs not using Workflows must have a `build` job as entry point
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      parallelism: 1  # run only one instance of this job in parallel
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      docker:  # run the steps with Docker
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - image: circleci/elixir:1.6 # ...with this image as the primary container; this is where all `steps` will run
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            MIX_ENV: test
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - image: mdillon/postgis:9.6-alpine  # database image
</span></span><span class="line"><span class="ln">11</span><span class="cl">          environment:  # environment variables for database
</span></span><span class="line"><span class="ln">12</span><span class="cl">            POSTGRES_DB: app_test
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      steps:  # commands that comprise the `build` job
</span></span><span class="line"><span class="ln">15</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)</span></span></code></pre></div><p>As you can see here, we are declaring the <code>build</code> continious integration
job. Basically we will use the Elixir 1.6 with PostgreSQL 9.6 to run
tests on the <code>app_test</code> database. After that we will checkout source
code base to fetch our recent changes into the build. <code>mix local</code> tasks
are also necessary in order to use any of <em>Mix</em> tasks later.</p>
<h2 id="running-tests-and-code-quality">Running tests and code quality</h2>
<p>All of us want to run all common continious integration steps such as:</p>
<ul>
<li>Fetch dependencies and compile application</li>
<li>Run code quality tools and checks (<em>you can read more about it
<a href="https://neiro.io/2018/04/28/elixir-code-quality-tools-and-checks.html">here</a>)</em></li>
<li>Execute all tests to make sure that our build is successful and
infallible</li>
<li>Run heavy and bulky static analysis tools</li>
</ul>
<p>Also we want to make our builds as fast as possible, so we definitely
need caching. Let&rsquo;s continue with our config and implement the steps
above:</p>
<p>{% raw %}</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">        - restore_cache:  # restores saved mix cache
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">            keys:  # list of cache keys, in decreasing specificity
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">              - v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">              - v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">              - v1-mix-cache
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - restore_cache:  # restores saved build cache
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">              - v1-build-cache
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - restore_cache:  # restores saved plt cache
</span></span><span class="line"><span class="ln">11</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln">12</span><span class="cl">              - dialyzer-cache
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - save_cache:  # generate and store cache so `restore_cache` works
</span></span><span class="line"><span class="ln">17</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln">18</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">19</span><span class="cl">        - save_cache:  # make another less specific cache
</span></span><span class="line"><span class="ln">20</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">21</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - save_cache:  # you should really save one more cache just in case
</span></span><span class="line"><span class="ln">23</span><span class="cl">            key: v1-mix-cache
</span></span><span class="line"><span class="ln">24</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - save_cache: # don&#39;t forget to save a *build* cache, too
</span></span><span class="line"><span class="ln">26</span><span class="cl">            key: v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">27</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">28</span><span class="cl">        - save_cache: # and one more build cache for good measure
</span></span><span class="line"><span class="ln">29</span><span class="cl">            key: v1-build-cache
</span></span><span class="line"><span class="ln">30</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">        - run: mix do format --check-formatted, credo --strict, security
</span></span><span class="line"><span class="ln">33</span><span class="cl">        - run: mix do xref deprecated --include-siblings, xref unreachable --include-siblings, xref graph --format stats
</span></span><span class="line"><span class="ln">34</span><span class="cl">
</span></span><span class="line"><span class="ln">35</span><span class="cl">        - run:  # special utility that stalls main process until DB is ready
</span></span><span class="line"><span class="ln">36</span><span class="cl">            name: Wait for DB
</span></span><span class="line"><span class="ln">37</span><span class="cl">            command: dockerize -wait tcp://localhost:5432 -timeout 1m
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">        - run: mix do ecto.migrations, ecto.load
</span></span><span class="line"><span class="ln">40</span><span class="cl">        - run: mix test  # run all tests in project
</span></span><span class="line"><span class="ln">41</span><span class="cl">
</span></span><span class="line"><span class="ln">42</span><span class="cl">        - run: mix dialyzer --halt-exit-status
</span></span><span class="line"><span class="ln">43</span><span class="cl">        - save_cache:
</span></span><span class="line"><span class="ln">44</span><span class="cl">            key: dialyzer-cache
</span></span><span class="line"><span class="ln">45</span><span class="cl">            paths: &#34;_build/test/dialyxir*.plt&#34;
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">        - store_test_results:  # upload test results for display in Test Summary
</span></span><span class="line"><span class="ln">48</span><span class="cl">            path: _build/test/lib/app/results.xml</span></span></code></pre></div><p>{% endraw %}</p>
<p>Now you can start new builds by signing up into CircleCI as it will run
the configuration and steps from your config. Every commit in any branch
will run the build job and you will know if something is wrong with your
code.</p>
<h2 id="deploying">Deploying</h2>
<p>However, having only one build job is not enough even for the simplest
CI process. Most often we need to make a staging/production release by
using <a href="https://github.com/bitwalker/distillery">Distillery</a>.</p>
<p>Let&rsquo;s continue filling up our configuration file by adding a new
<code>deploy</code> job:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    deploy:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      docker:
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        - image: circleci/elixir:1.6
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            MIX_ENV: staging
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      steps:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">11</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        # set MIX_ENV to prod or staging value according to the source branch
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - run:
</span></span><span class="line"><span class="ln">17</span><span class="cl">            name: Update MIX_ENV environment variable
</span></span><span class="line"><span class="ln">18</span><span class="cl">            command: |
</span></span><span class="line"><span class="ln">19</span><span class="cl">              echo &#34;export MIX_ENV=$(if [ &#39;$CIRCLE_BRANCH&#39; &#39;==&#39; &#39;master&#39; ]; then echo &#39;prod&#39;; else echo &#39;staging&#39;; fi)&#34; &gt;&gt; $BASH_ENV
</span></span><span class="line"><span class="ln">20</span><span class="cl">              source $BASH_ENV
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - run: cd deps/argon2_elixir &amp;&amp; make clean &amp;&amp; make &amp;&amp; cd -
</span></span><span class="line"><span class="ln">23</span><span class="cl">        - run: MIX_ENV=staging mix release --env $MIX_ENV
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - run: tar -zcvf $CIRCLE_SHA1.tar.gz bin appspec.yml VERSION _build/$MIX_ENV/rel/app/releases/$(cat VERSION)/app.tar.gz</span></span></code></pre></div><p>This will be enough to create a separate deploy job that will run on a
separate Docker image. However, we will need to run it only on develop
and master branches in order to upload staging/production releases
accordingly. We can achieve this by using CircleCI workflow and
providing a simple configuration at the bottom of our config file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  workflows:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    version: 2
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build-and-deploy:
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      jobs:
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        - build
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - deploy:
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            requires:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - build
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            filters:
</span></span><span class="line"><span class="ln">10</span><span class="cl">              branches:
</span></span><span class="line"><span class="ln">11</span><span class="cl">                only:
</span></span><span class="line"><span class="ln">12</span><span class="cl">                  - develop
</span></span><span class="line"><span class="ln">13</span><span class="cl">                  - master</span></span></code></pre></div><p>After that you are free to upload the built release to any server or any
platform you want. You can use Edeliver, Ansible, Chef, Docker - it&rsquo;s up
to you.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see above, it&rsquo;s not so hard to build and deploy Elixir
applications with CircleCI 2.0. This platform is flexible and fast
enough to make your continious integration bright and shiny.</p>
<p>If you want to discover even more on the topic then let&rsquo;s read
<a href="https://circleci.com/docs/2.0/">CircleCI 2.0 documentation</a> and
<a href="https://circleci.com/docs/2.0/language-elixir/">Elixir Language
Guide</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir code quality tools and checks</title>
      <link>https://neiro.io/blog/2018-04-28-elixir-code-quality-tools-and-checks.md/</link>
      <pubDate>Sat, 28 Apr 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2018-04-28-elixir-code-quality-tools-and-checks.md/</guid>
      <description>&lt;p&gt;Elixir programming language has its great, huge community and ecosystem.&#xA;As for now, we can easily do static code analysis and code quality&#xA;checks by using plenty of standard or external tools. This allows us to&#xA;write robust solid Elixir code in a uniform way according to the&#xA;&lt;a href=&#34;https://github.com/christopheradams/elixir_style_guide&#34;&gt;style guide&lt;/a&gt;&#xA;.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with the most popular tools and solutions:&lt;/p&gt;&#xA;&lt;h2 id=&#34;mix-compile-warnings-as-errors&#34;&gt;mix compile &amp;ndash;warnings-as-errors&lt;/h2&gt;&#xA;&lt;p&gt;The first and the simplest check that could possibly exist. Elixir&#xA;compiler is smart enough to detect easily harsh mistakes like unused&#xA;variables or mismatched module names. At the same time it is pretty&#xA;friendly, because compiler just warns you about these problems, but does&#xA;not stop compilation. For some reasons, especially if we are running the&#xA;CI, we want to make it more obvious and stop any further checks. This&#xA;can be achieved by running &lt;code&gt;mix compile&lt;/code&gt; task with related option:&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has its great, huge community and ecosystem.
As for now, we can easily do static code analysis and code quality
checks by using plenty of standard or external tools. This allows us to
write robust solid Elixir code in a uniform way according to the
<a href="https://github.com/christopheradams/elixir_style_guide">style guide</a>
.</p>
<p>Let&rsquo;s start with the most popular tools and solutions:</p>
<h2 id="mix-compile-warnings-as-errors">mix compile &ndash;warnings-as-errors</h2>
<p>The first and the simplest check that could possibly exist. Elixir
compiler is smart enough to detect easily harsh mistakes like unused
variables or mismatched module names. At the same time it is pretty
friendly, because compiler just warns you about these problems, but does
not stop compilation. For some reasons, especially if we are running the
CI, we want to make it more obvious and stop any further checks. This
can be achieved by running <code>mix compile</code> task with related option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix compile --warnings-as-errors</span></span></code></pre></div><h2 id="mix-format-check-formatted">mix format &ndash;check-formatted</h2>
<p>Elixir 1.6 introduced yet another useful tool - the formatter. After
that we can keep our codebase consistent in one uniform code style
without any contradictions. However, in the real life, not everyone uses
the formatter and we need to force this option by running <code>mix format</code>
task with the <code>--check-formatted</code> option during CI.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix format --check-formatted</span></span></code></pre></div><h2 id="credo">Credo</h2>
<p><a href="https://github.com/rrrene/credo">Credo</a> is a static analysis code
tool for Elixir. It&rsquo;s more than just a usual code checker - it can teach
you how to write your code better, show refactoring possibilities and
inconsistencies in naming.</p>
<p>In order to start using Credo you need to add this line to your
<code>mix.exs</code> deps:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  {:credo, &#34;~&gt; 0.9.1&#34;, only: ~w(dev test)a, runtime: false}</span></span></code></pre></div><p>You can enforce your own code style for your team by using Credo
configuration file. For example, you can create <code>config/.credo.exs</code> file
with this content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  %{
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    #
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    # You can have as many configs as you like in the `configs:` field.
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    configs: [
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      %{
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        #
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        # Run any exec using `mix credo -C &lt;name&gt;`. If no exec name is given
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # &#34;default&#34; is used.
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        name: &#34;default&#34;,
</span></span><span class="line"><span class="ln">10</span><span class="cl">        #
</span></span><span class="line"><span class="ln">11</span><span class="cl">        # These are the files included in the analysis:
</span></span><span class="line"><span class="ln">12</span><span class="cl">        files: %{
</span></span><span class="line"><span class="ln">13</span><span class="cl">          #
</span></span><span class="line"><span class="ln">14</span><span class="cl">          # You can give explicit globs or simply directories.
</span></span><span class="line"><span class="ln">15</span><span class="cl">          # In the latter case `**/*.{ex,exs}` will be used.
</span></span><span class="line"><span class="ln">16</span><span class="cl">          excluded: [~r&#34;/_build/&#34;, ~r&#34;/deps/&#34;, ~r&#34;/priv/&#34;]
</span></span><span class="line"><span class="ln">17</span><span class="cl">        },
</span></span><span class="line"><span class="ln">18</span><span class="cl">        #
</span></span><span class="line"><span class="ln">19</span><span class="cl">        # If you create your own checks, you must specify the source files for
</span></span><span class="line"><span class="ln">20</span><span class="cl">        # them here, so they can be loaded by Credo before running the analysis.
</span></span><span class="line"><span class="ln">21</span><span class="cl">        requires: [],
</span></span><span class="line"><span class="ln">22</span><span class="cl">        #
</span></span><span class="line"><span class="ln">23</span><span class="cl">        # Credo automatically checks for updates, like e.g. Hex does.
</span></span><span class="line"><span class="ln">24</span><span class="cl">        # You can disable this behaviour below:
</span></span><span class="line"><span class="ln">25</span><span class="cl">        check_for_updates: true,
</span></span><span class="line"><span class="ln">26</span><span class="cl">        #
</span></span><span class="line"><span class="ln">27</span><span class="cl">        # If you want to enforce a style guide and need a more traditional linting
</span></span><span class="line"><span class="ln">28</span><span class="cl">        # experience, you can change `strict` to `true` below:
</span></span><span class="line"><span class="ln">29</span><span class="cl">        strict: true,
</span></span><span class="line"><span class="ln">30</span><span class="cl">        #
</span></span><span class="line"><span class="ln">31</span><span class="cl">        # If you want to use uncolored output by default, you can change `color`
</span></span><span class="line"><span class="ln">32</span><span class="cl">        # to `false` below:
</span></span><span class="line"><span class="ln">33</span><span class="cl">        color: true,
</span></span><span class="line"><span class="ln">34</span><span class="cl">        #
</span></span><span class="line"><span class="ln">35</span><span class="cl">        # You can customize the parameters of any check by adding a second element
</span></span><span class="line"><span class="ln">36</span><span class="cl">        # to the tuple.
</span></span><span class="line"><span class="ln">37</span><span class="cl">        #
</span></span><span class="line"><span class="ln">38</span><span class="cl">        # To disable a check put `false` as second element:
</span></span><span class="line"><span class="ln">39</span><span class="cl">        #
</span></span><span class="line"><span class="ln">40</span><span class="cl">        #     {Credo.Check.Design.DuplicatedCode, false}
</span></span><span class="line"><span class="ln">41</span><span class="cl">        #
</span></span><span class="line"><span class="ln">42</span><span class="cl">        checks: [
</span></span><span class="line"><span class="ln">43</span><span class="cl">          {Credo.Check.Readability.Specs, priority: :low},
</span></span><span class="line"><span class="ln">44</span><span class="cl">          {Credo.Check.Design.TagTODO, exit_status: 0},
</span></span><span class="line"><span class="ln">45</span><span class="cl">          {Credo.Check.Design.TagFIXME, exit_status: 0},
</span></span><span class="line"><span class="ln">46</span><span class="cl">          {Credo.Check.Readability.MaxLineLength, priority: :low, max_length: 100}
</span></span><span class="line"><span class="ln">47</span><span class="cl">        ]
</span></span><span class="line"><span class="ln">48</span><span class="cl">      }
</span></span><span class="line"><span class="ln">49</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">50</span><span class="cl">  }</span></span></code></pre></div><p>After that, it would be nice to force these settings by running Credo
mix task with <code>--strict</code> option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix credo --strict</span></span></code></pre></div><h2 id="xref">Xref</h2>
<p>Elixir has a <code>mix xref</code> task that performs cross-reference checks
between modules. This check can print all unavailable or deprecated
references, create a dependencies graph and show callers of the given
function. During the CI we want to check if we have any unavailable or
deprecated functions/modules:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix xref unavailable
</span></span><span class="line"><span class="ln">2</span><span class="cl">  mix xref deprecated</span></span></code></pre></div><p>Don&rsquo;t forget to include <code>--include-siblings</code> option if you are using
this in umbrella application.</p>
<h2 id="sobelow">Sobelow</h2>
<p><a href="https://github.com/nccgroup/sobelow">Sobelow</a> is a security-based
static analysis tool. Unfortunately, it comes just for the Phoenix
framework, so you can use it only in your web applications. Sobelow can
detect the following types of security issues:</p>
<ul>
<li>Insecure configuration</li>
<li>Known-vulnerable Dependencies</li>
<li>Cross-Site Scripting</li>
<li>SQL injection</li>
<li>Command injection</li>
<li>Denial of Service</li>
<li>Directory traversal</li>
<li>Unsafe serialization</li>
</ul>
<p>To install Sobelow you can use the next command:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix archive.install hex sobelow</span></span></code></pre></div><p>To run Sobelow just start the related mix task:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix sobelow</span></span></code></pre></div><h2 id="dialyzer">Dialyzer</h2>
<p><a href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a> is the most
powerful and yet complex analysis tool for the BEAM platform. Dialyzer
means DIscrepancy AnaLYZer for ERlang programs, but it could be used in
Elixir too. It identifies software discrepancies like definite type
errors, dead or unreachable code.</p>
<p>To use Dialyzer in your Elixir application you may want to use
<a href="identifies%20software%20discrepancies">Dialyxir</a>. Just add this
line to your <code>mix.exs</code> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp deps do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [{:dialyxir, &#34;~&gt; 0.5&#34;, only: [:dev], runtime: false}]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>You can also configure warnings, dependencies and paths in <code>mix.exs</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [
</span></span><span class="line"><span class="ln">3</span><span class="cl">    dialyzer: [plt_add_deps: :apps_direct, plt_add_apps: [:wx]]
</span></span><span class="line"><span class="ln">4</span><span class="cl">    # flags: [&#34;-Wunmatched_returns&#34;, :error_handling, :race_conditions, :underspecs]
</span></span><span class="line"><span class="ln">5</span><span class="cl">    # paths: [&#34;_build/dev/lib/my_app/ebin&#34;, &#34;_build/dev/lib/foo/ebin&#34;]
</span></span><span class="line"><span class="ln">6</span><span class="cl">      ]
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>You can ignore any unwanted warnings by providing <code>ignore_warnings</code>
option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [dialyzer: [ignore_warnings: &#34;dialyzer.ignore-warnings&#34;]]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>To run dialyzer on the CI add the next option to make sure that the
build fails in case of any errors:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix dialyzer --halt-exit-status</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>As you can see, Elixir by itself and by its ecosystem has many useful
checks and tools that allow you to keep your code nice, simple, robust
and consistent. These checks are also highly configurable and
extensible. You can easily use them for any CI platforms to keep your
development workflow bright and shiny.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir code quality tools and checks</title>
      <link>https://neiro.io/posts/2018-04-28-elixir-code-quality-tools-and-checks.md/</link>
      <pubDate>Sat, 28 Apr 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2018-04-28-elixir-code-quality-tools-and-checks.md/</guid>
      <description>&lt;p&gt;Elixir programming language has its great, huge community and ecosystem.&#xA;As for now, we can easily do static code analysis and code quality&#xA;checks by using plenty of standard or external tools. This allows us to&#xA;write robust solid Elixir code in a uniform way according to the&#xA;&lt;a href=&#34;https://github.com/christopheradams/elixir_style_guide&#34;&gt;style guide&lt;/a&gt;&#xA;.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with the most popular tools and solutions:&lt;/p&gt;&#xA;&lt;h2 id=&#34;mix-compile-warnings-as-errors&#34;&gt;mix compile &amp;ndash;warnings-as-errors&lt;/h2&gt;&#xA;&lt;p&gt;The first and the simplest check that could possibly exist. Elixir&#xA;compiler is smart enough to detect easily harsh mistakes like unused&#xA;variables or mismatched module names. At the same time it is pretty&#xA;friendly, because compiler just warns you about these problems, but does&#xA;not stop compilation. For some reasons, especially if we are running the&#xA;CI, we want to make it more obvious and stop any further checks. This&#xA;can be achieved by running &lt;code&gt;mix compile&lt;/code&gt; task with related option:&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has its great, huge community and ecosystem.
As for now, we can easily do static code analysis and code quality
checks by using plenty of standard or external tools. This allows us to
write robust solid Elixir code in a uniform way according to the
<a href="https://github.com/christopheradams/elixir_style_guide">style guide</a>
.</p>
<p>Let&rsquo;s start with the most popular tools and solutions:</p>
<h2 id="mix-compile-warnings-as-errors">mix compile &ndash;warnings-as-errors</h2>
<p>The first and the simplest check that could possibly exist. Elixir
compiler is smart enough to detect easily harsh mistakes like unused
variables or mismatched module names. At the same time it is pretty
friendly, because compiler just warns you about these problems, but does
not stop compilation. For some reasons, especially if we are running the
CI, we want to make it more obvious and stop any further checks. This
can be achieved by running <code>mix compile</code> task with related option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix compile --warnings-as-errors</span></span></code></pre></div><h2 id="mix-format-check-formatted">mix format &ndash;check-formatted</h2>
<p>Elixir 1.6 introduced yet another useful tool - the formatter. After
that we can keep our codebase consistent in one uniform code style
without any contradictions. However, in the real life, not everyone uses
the formatter and we need to force this option by running <code>mix format</code>
task with the <code>--check-formatted</code> option during CI.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix format --check-formatted</span></span></code></pre></div><h2 id="credo">Credo</h2>
<p><a href="https://github.com/rrrene/credo">Credo</a> is a static analysis code
tool for Elixir. It&rsquo;s more than just a usual code checker - it can teach
you how to write your code better, show refactoring possibilities and
inconsistencies in naming.</p>
<p>In order to start using Credo you need to add this line to your
<code>mix.exs</code> deps:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  {:credo, &#34;~&gt; 0.9.1&#34;, only: ~w(dev test)a, runtime: false}</span></span></code></pre></div><p>You can enforce your own code style for your team by using Credo
configuration file. For example, you can create <code>config/.credo.exs</code> file
with this content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  %{
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    #
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    # You can have as many configs as you like in the `configs:` field.
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    configs: [
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      %{
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        #
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        # Run any exec using `mix credo -C &lt;name&gt;`. If no exec name is given
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # &#34;default&#34; is used.
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        name: &#34;default&#34;,
</span></span><span class="line"><span class="ln">10</span><span class="cl">        #
</span></span><span class="line"><span class="ln">11</span><span class="cl">        # These are the files included in the analysis:
</span></span><span class="line"><span class="ln">12</span><span class="cl">        files: %{
</span></span><span class="line"><span class="ln">13</span><span class="cl">          #
</span></span><span class="line"><span class="ln">14</span><span class="cl">          # You can give explicit globs or simply directories.
</span></span><span class="line"><span class="ln">15</span><span class="cl">          # In the latter case `**/*.{ex,exs}` will be used.
</span></span><span class="line"><span class="ln">16</span><span class="cl">          excluded: [~r&#34;/_build/&#34;, ~r&#34;/deps/&#34;, ~r&#34;/priv/&#34;]
</span></span><span class="line"><span class="ln">17</span><span class="cl">        },
</span></span><span class="line"><span class="ln">18</span><span class="cl">        #
</span></span><span class="line"><span class="ln">19</span><span class="cl">        # If you create your own checks, you must specify the source files for
</span></span><span class="line"><span class="ln">20</span><span class="cl">        # them here, so they can be loaded by Credo before running the analysis.
</span></span><span class="line"><span class="ln">21</span><span class="cl">        requires: [],
</span></span><span class="line"><span class="ln">22</span><span class="cl">        #
</span></span><span class="line"><span class="ln">23</span><span class="cl">        # Credo automatically checks for updates, like e.g. Hex does.
</span></span><span class="line"><span class="ln">24</span><span class="cl">        # You can disable this behaviour below:
</span></span><span class="line"><span class="ln">25</span><span class="cl">        check_for_updates: true,
</span></span><span class="line"><span class="ln">26</span><span class="cl">        #
</span></span><span class="line"><span class="ln">27</span><span class="cl">        # If you want to enforce a style guide and need a more traditional linting
</span></span><span class="line"><span class="ln">28</span><span class="cl">        # experience, you can change `strict` to `true` below:
</span></span><span class="line"><span class="ln">29</span><span class="cl">        strict: true,
</span></span><span class="line"><span class="ln">30</span><span class="cl">        #
</span></span><span class="line"><span class="ln">31</span><span class="cl">        # If you want to use uncolored output by default, you can change `color`
</span></span><span class="line"><span class="ln">32</span><span class="cl">        # to `false` below:
</span></span><span class="line"><span class="ln">33</span><span class="cl">        color: true,
</span></span><span class="line"><span class="ln">34</span><span class="cl">        #
</span></span><span class="line"><span class="ln">35</span><span class="cl">        # You can customize the parameters of any check by adding a second element
</span></span><span class="line"><span class="ln">36</span><span class="cl">        # to the tuple.
</span></span><span class="line"><span class="ln">37</span><span class="cl">        #
</span></span><span class="line"><span class="ln">38</span><span class="cl">        # To disable a check put `false` as second element:
</span></span><span class="line"><span class="ln">39</span><span class="cl">        #
</span></span><span class="line"><span class="ln">40</span><span class="cl">        #     {Credo.Check.Design.DuplicatedCode, false}
</span></span><span class="line"><span class="ln">41</span><span class="cl">        #
</span></span><span class="line"><span class="ln">42</span><span class="cl">        checks: [
</span></span><span class="line"><span class="ln">43</span><span class="cl">          {Credo.Check.Readability.Specs, priority: :low},
</span></span><span class="line"><span class="ln">44</span><span class="cl">          {Credo.Check.Design.TagTODO, exit_status: 0},
</span></span><span class="line"><span class="ln">45</span><span class="cl">          {Credo.Check.Design.TagFIXME, exit_status: 0},
</span></span><span class="line"><span class="ln">46</span><span class="cl">          {Credo.Check.Readability.MaxLineLength, priority: :low, max_length: 100}
</span></span><span class="line"><span class="ln">47</span><span class="cl">        ]
</span></span><span class="line"><span class="ln">48</span><span class="cl">      }
</span></span><span class="line"><span class="ln">49</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">50</span><span class="cl">  }</span></span></code></pre></div><p>After that, it would be nice to force these settings by running Credo
mix task with <code>--strict</code> option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix credo --strict</span></span></code></pre></div><h2 id="xref">Xref</h2>
<p>Elixir has a <code>mix xref</code> task that performs cross-reference checks
between modules. This check can print all unavailable or deprecated
references, create a dependencies graph and show callers of the given
function. During the CI we want to check if we have any unavailable or
deprecated functions/modules:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix xref unavailable
</span></span><span class="line"><span class="ln">2</span><span class="cl">  mix xref deprecated</span></span></code></pre></div><p>Don&rsquo;t forget to include <code>--include-siblings</code> option if you are using
this in umbrella application.</p>
<h2 id="sobelow">Sobelow</h2>
<p><a href="https://github.com/nccgroup/sobelow">Sobelow</a> is a security-based
static analysis tool. Unfortunately, it comes just for the Phoenix
framework, so you can use it only in your web applications. Sobelow can
detect the following types of security issues:</p>
<ul>
<li>Insecure configuration</li>
<li>Known-vulnerable Dependencies</li>
<li>Cross-Site Scripting</li>
<li>SQL injection</li>
<li>Command injection</li>
<li>Denial of Service</li>
<li>Directory traversal</li>
<li>Unsafe serialization</li>
</ul>
<p>To install Sobelow you can use the next command:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix archive.install hex sobelow</span></span></code></pre></div><p>To run Sobelow just start the related mix task:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix sobelow</span></span></code></pre></div><h2 id="dialyzer">Dialyzer</h2>
<p><a href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a> is the most
powerful and yet complex analysis tool for the BEAM platform. Dialyzer
means DIscrepancy AnaLYZer for ERlang programs, but it could be used in
Elixir too. It identifies software discrepancies like definite type
errors, dead or unreachable code.</p>
<p>To use Dialyzer in your Elixir application you may want to use
<a href="identifies%20software%20discrepancies">Dialyxir</a>. Just add this
line to your <code>mix.exs</code> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp deps do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [{:dialyxir, &#34;~&gt; 0.5&#34;, only: [:dev], runtime: false}]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>You can also configure warnings, dependencies and paths in <code>mix.exs</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [
</span></span><span class="line"><span class="ln">3</span><span class="cl">    dialyzer: [plt_add_deps: :apps_direct, plt_add_apps: [:wx]]
</span></span><span class="line"><span class="ln">4</span><span class="cl">    # flags: [&#34;-Wunmatched_returns&#34;, :error_handling, :race_conditions, :underspecs]
</span></span><span class="line"><span class="ln">5</span><span class="cl">    # paths: [&#34;_build/dev/lib/my_app/ebin&#34;, &#34;_build/dev/lib/foo/ebin&#34;]
</span></span><span class="line"><span class="ln">6</span><span class="cl">      ]
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>You can ignore any unwanted warnings by providing <code>ignore_warnings</code>
option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [dialyzer: [ignore_warnings: &#34;dialyzer.ignore-warnings&#34;]]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>To run dialyzer on the CI add the next option to make sure that the
build fails in case of any errors:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix dialyzer --halt-exit-status</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>As you can see, Elixir by itself and by its ecosystem has many useful
checks and tools that allow you to keep your code nice, simple, robust
and consistent. These checks are also highly configurable and
extensible. You can easily use them for any CI platforms to keep your
development workflow bright and shiny.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Postgres full-text search using Ecto</title>
      <link>https://neiro.io/blog/2018-01-21-postgres-full-text-search-using-ecto.md/</link>
      <pubDate>Sun, 21 Jan 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/blog/2018-01-21-postgres-full-text-search-using-ecto.md/</guid>
      <description>&lt;p&gt;PostgreSQL is one of the most popular, stable and common relational&#xA;database. It&amp;rsquo;s widely used in Elixir infrastructure and has a great&#xA;integration with Ecto library.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re into web development you can often face the search problem.&#xA;You have a large stable database, you have tons of useful information,&#xA;great tools, but your users desire to find something by arbitrary&#xA;questions. You can&amp;rsquo;t use your favourite plain SELECT &amp;hellip; WHERE &amp;hellip;&#xA;queries because you need to search for the words, not columns or&#xA;records.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Postgres full-text search using Ecto</title>
      <link>https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/</link>
      <pubDate>Sun, 21 Jan 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/</guid>
      <description>&lt;p&gt;PostgreSQL is one of the most popular, stable and common relational&#xA;database. It&amp;rsquo;s widely used in Elixir infrastructure and has a great&#xA;integration with Ecto library.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re into web development you can often face the search problem.&#xA;You have a large stable database, you have tons of useful information,&#xA;great tools, but your users desire to find something by arbitrary&#xA;questions. You can&amp;rsquo;t use your favourite plain SELECT &amp;hellip; WHERE &amp;hellip;&#xA;queries because you need to search for the words, not columns or&#xA;records.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Building dynamic queries with Ecto</title>
      <link>https://neiro.io/blog/2017-09-16-building-dynamic-queries-with-ecto.md/</link>
      <pubDate>Sat, 16 Sep 2017 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2017-09-16-building-dynamic-queries-with-ecto.md/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/elixir-ecto/ecto&#34;&gt;Ecto&lt;/a&gt; is the most popular,&#xA;robust and solid solution to work with databases in &lt;strong&gt;Elixir&lt;/strong&gt; ecosystem.&#xA;Ecto is not ORM, ODM nor it is a &lt;em&gt;Repository patern&lt;/em&gt; library. &lt;em&gt;Ecto&lt;/em&gt; is&#xA;just a wrapper for common constructions to work with databases, nothing&#xA;less and nothing more than that.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ecto.Query&lt;/strong&gt; is the core module for operations with database queries. It&#xA;allows us to build easily any queries with predefined conditions that we&#xA;wanted.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/elixir-ecto/ecto">Ecto</a> is the most popular,
robust and solid solution to work with databases in <strong>Elixir</strong> ecosystem.
Ecto is not ORM, ODM nor it is a <em>Repository patern</em> library. <em>Ecto</em> is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.</p>
<p><strong>Ecto.Query</strong> is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted.</p>
<p>But what if we want to build a <em>really</em> dynamic query? A common case can
be filtering by list of attributes.</p>
<p>Imagine a situation when you have a large set of users in your database.
Your customers want to filter or exclude users by any attributes that
can be allowed: <code>name, nickname, gender</code> etc. Writing code for all of
model attributes can be tedious and annoying.</p>
<p>So what can we do about it?</p>
<h2 id="filter-query">Filter Query</h2>
<p>Let&rsquo;s create a new Elixir module that will implement logic of our future
dynamic query. I will name it <code>FilterQuery</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln">4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>This module should have just one public function called <code>filter</code> that
accepts incoming query, inclusion and exclusion parameters as the
arguments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def filter(query, inclusion, exclusion)</span></span></code></pre></div><p>Now let&rsquo;s implement the core of our future filter function. Assume that
we need to build two lists of dynamic queries both for inclusion and
exclusion parameters:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)</span></span></code></pre></div><p>Now we need to merge all these dynamic queries into a new big one. It
can be implemented using <code>Enum.reduce</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)</span></span></code></pre></div><p>Now our <code>filter</code> function returns a new complex query that can be easily
composed with another queries using <code>Ecto.Query</code> functions or macroses.</p>
<h2 id="dynamic-filter-query">Dynamic filter query</h2>
<p>We have just created a basic prototype for our future dynamic filter
query. However, the devil&rsquo;s always in the details. We need to hide
implementation in private functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">3</span><span class="cl">      do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">4</span><span class="cl">  end
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">  defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">    for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>We suppose that inclusion and exclusion filters are keyword lists with
keys as model attributes and lists as the filter values. Therefore, we
need to check if these lists contain values or we shall skip building
query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">2</span><span class="cl">  defp present?(_), do: false</span></span></code></pre></div><p>Now we need to go straight to the implementation. <code>dynamic_query/3</code>
should finally return for us the result.</p>
<p>We will use <code>dynamic</code> macro from Ecto.Query that takes any query as
first argument and builds dynamic query for the second one. Also notice
that we need to use <code>field</code> macro to dynamically access attribute name:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">6</span><span class="cl">    dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><h2 id="restriction-of-filter-keys">Restriction of filter keys</h2>
<p>So, looks like our filter query is fully functional and dynamic! But
this is not enough when you are building a complex logic that
desperately needs to leave some attributes <strong>unfiltered</strong>.</p>
<p>For example, imagine the case when your <code>User</code> model has a
<code>relationships_status</code> attribute. If you&rsquo;re allowing your API customers
to filter any attributes they are likely to find out lonely users by
using this loophole. Therefore your customers will be dating, engaging,
tying the knots and finally will be lost for your application. Is this
what you really wished? Guess not :)</p>
<p>So let&rsquo;s restrict filtered attributes by using <code>__using__</code> macro:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  ...
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    end
</span></span><span class="line"><span class="ln">10</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">13</span><span class="cl">      do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">     defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">17</span><span class="cl">  end</span></span></code></pre></div><p>Voila! No one ever will find out how your users relationships are going.</p>
<p>Now let&rsquo;s take a quick look at our dynamic filter query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      quote do
</span></span><span class="line"><span class="ln">10</span><span class="cl">        import FilterQuery
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">13</span><span class="cl">        def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln">14</span><span class="cl">          [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">          queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln">17</span><span class="cl">          Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        end
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">        def filter(query, _) do
</span></span><span class="line"><span class="ln">21</span><span class="cl">          query
</span></span><span class="line"><span class="ln">22</span><span class="cl">        end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">25</span><span class="cl">          for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">26</span><span class="cl">            do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">27</span><span class="cl">        end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">          for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">31</span><span class="cl">        end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">34</span><span class="cl">          dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">35</span><span class="cl">        end
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">        defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">          dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">39</span><span class="cl">        end
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl">        defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">42</span><span class="cl">          do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">43</span><span class="cl">
</span></span><span class="line"><span class="ln">44</span><span class="cl">        defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">45</span><span class="cl">
</span></span><span class="line"><span class="ln">46</span><span class="cl">        defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">47</span><span class="cl">        defp present?(_), do: false
</span></span><span class="line"><span class="ln">48</span><span class="cl">      end
</span></span><span class="line"><span class="ln">49</span><span class="cl">    end
</span></span><span class="line"><span class="ln">50</span><span class="cl">  end</span></span></code></pre></div><h2 id="usage">Usage</h2>
<p>It&rsquo;s a piece of cake to use our query in another modules. Just include
our query and set the list of allowed attributes through <code>use</code>
construction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  {:ok, _} = Application.ensure_all_started(:ex_machina)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Example of using dynamic ecto queries
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    import Factory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    use FilterQuery, attributes: ~w(proficiency name)a
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def run do
</span></span><span class="line"><span class="ln">12</span><span class="cl">      insert_users()
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      IO.inspect(count([])) # 3
</span></span><span class="line"><span class="ln">15</span><span class="cl">      [relationships_status: [&#34;married&#34;]] |&gt; count([]) |&gt; IO.inspect # 3
</span></span><span class="line"><span class="ln">16</span><span class="cl">      [proficiency: [&#34;developer&#34;]] |&gt; count([]) |&gt; IO.inspect # 1
</span></span><span class="line"><span class="ln">17</span><span class="cl">      [proficiency: [&#34;soldier&#34;]] |&gt; count([]) |&gt; IO.inspect # 0
</span></span><span class="line"><span class="ln">18</span><span class="cl">      IO.inspect(count([], %{proficiency: [&#34;politic&#34;]})) # 2
</span></span><span class="line"><span class="ln">19</span><span class="cl">    end
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    defp insert_users do
</span></span><span class="line"><span class="ln">22</span><span class="cl">      Repo.delete_all(User)
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      insert(:user, relationships_status: &#34;single&#34;, proficiency: &#34;developer&#34;)
</span></span><span class="line"><span class="ln">25</span><span class="cl">      insert(:user, relationships_status: &#34;married&#34;, proficiency: &#34;politic&#34;)
</span></span><span class="line"><span class="ln">26</span><span class="cl">      insert(:user, relationships_status: &#34;dating&#34;, proficiency: &#34;thief&#34;)
</span></span><span class="line"><span class="ln">27</span><span class="cl">    end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    defp count(inclusion, exclusion \\ []) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">      User
</span></span><span class="line"><span class="ln">31</span><span class="cl">      |&gt; filter(inclusion, exclusion)
</span></span><span class="line"><span class="ln">32</span><span class="cl">      |&gt; Repo.aggregate(:count, :id)
</span></span><span class="line"><span class="ln">33</span><span class="cl">    end
</span></span><span class="line"><span class="ln">34</span><span class="cl">  end</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>However, this is not at all that we can achieve by using <code>dynamic</code> macro
in Ecto.</p>
<p>You can filter by regex, type or even your own query; sort by ascending
and descending; do aggregation or pagination; whatever comes to your
head - it all depends on your imagination and skills. Ecto provides you
a great tool to build any complex queries by writing minimal lines of
code without any duplication.</p>
<p>What&rsquo;s next? See the <a href="https://github.com/ne1ro/dynamic_ecto_query">full
example</a> for this article or read
<a href="https://hexdocs.pm/ecto/Ecto.Query.html">Ecto documentation</a> to
deepen your knowledge a little bit more.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Building dynamic queries with Ecto</title>
      <link>https://neiro.io/posts/2017-09-16-building-dynamic-queries-with-ecto.md/</link>
      <pubDate>Sat, 16 Sep 2017 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2017-09-16-building-dynamic-queries-with-ecto.md/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/elixir-ecto/ecto&#34;&gt;Ecto&lt;/a&gt; is the most popular,&#xA;robust and solid solution to work with databases in &lt;strong&gt;Elixir&lt;/strong&gt; ecosystem.&#xA;Ecto is not ORM, ODM nor it is a &lt;em&gt;Repository patern&lt;/em&gt; library. &lt;em&gt;Ecto&lt;/em&gt; is&#xA;just a wrapper for common constructions to work with databases, nothing&#xA;less and nothing more than that.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ecto.Query&lt;/strong&gt; is the core module for operations with database queries. It&#xA;allows us to build easily any queries with predefined conditions that we&#xA;wanted.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/elixir-ecto/ecto">Ecto</a> is the most popular,
robust and solid solution to work with databases in <strong>Elixir</strong> ecosystem.
Ecto is not ORM, ODM nor it is a <em>Repository patern</em> library. <em>Ecto</em> is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.</p>
<p><strong>Ecto.Query</strong> is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted.</p>
<p>But what if we want to build a <em>really</em> dynamic query? A common case can
be filtering by list of attributes.</p>
<p>Imagine a situation when you have a large set of users in your database.
Your customers want to filter or exclude users by any attributes that
can be allowed: <code>name, nickname, gender</code> etc. Writing code for all of
model attributes can be tedious and annoying.</p>
<p>So what can we do about it?</p>
<h2 id="filter-query">Filter Query</h2>
<p>Let&rsquo;s create a new Elixir module that will implement logic of our future
dynamic query. I will name it <code>FilterQuery</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln">4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>This module should have just one public function called <code>filter</code> that
accepts incoming query, inclusion and exclusion parameters as the
arguments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def filter(query, inclusion, exclusion)</span></span></code></pre></div><p>Now let&rsquo;s implement the core of our future filter function. Assume that
we need to build two lists of dynamic queries both for inclusion and
exclusion parameters:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)</span></span></code></pre></div><p>Now we need to merge all these dynamic queries into a new big one. It
can be implemented using <code>Enum.reduce</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)</span></span></code></pre></div><p>Now our <code>filter</code> function returns a new complex query that can be easily
composed with another queries using <code>Ecto.Query</code> functions or macroses.</p>
<h2 id="dynamic-filter-query">Dynamic filter query</h2>
<p>We have just created a basic prototype for our future dynamic filter
query. However, the devil&rsquo;s always in the details. We need to hide
implementation in private functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">3</span><span class="cl">      do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">4</span><span class="cl">  end
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">  defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">    for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>We suppose that inclusion and exclusion filters are keyword lists with
keys as model attributes and lists as the filter values. Therefore, we
need to check if these lists contain values or we shall skip building
query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">2</span><span class="cl">  defp present?(_), do: false</span></span></code></pre></div><p>Now we need to go straight to the implementation. <code>dynamic_query/3</code>
should finally return for us the result.</p>
<p>We will use <code>dynamic</code> macro from Ecto.Query that takes any query as
first argument and builds dynamic query for the second one. Also notice
that we need to use <code>field</code> macro to dynamically access attribute name:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">6</span><span class="cl">    dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><h2 id="restriction-of-filter-keys">Restriction of filter keys</h2>
<p>So, looks like our filter query is fully functional and dynamic! But
this is not enough when you are building a complex logic that
desperately needs to leave some attributes <strong>unfiltered</strong>.</p>
<p>For example, imagine the case when your <code>User</code> model has a
<code>relationships_status</code> attribute. If you&rsquo;re allowing your API customers
to filter any attributes they are likely to find out lonely users by
using this loophole. Therefore your customers will be dating, engaging,
tying the knots and finally will be lost for your application. Is this
what you really wished? Guess not :)</p>
<p>So let&rsquo;s restrict filtered attributes by using <code>__using__</code> macro:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  ...
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    end
</span></span><span class="line"><span class="ln">10</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">13</span><span class="cl">      do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">     defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">17</span><span class="cl">  end</span></span></code></pre></div><p>Voila! No one ever will find out how your users relationships are going.</p>
<p>Now let&rsquo;s take a quick look at our dynamic filter query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      quote do
</span></span><span class="line"><span class="ln">10</span><span class="cl">        import FilterQuery
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">13</span><span class="cl">        def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln">14</span><span class="cl">          [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">          queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln">17</span><span class="cl">          Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        end
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">        def filter(query, _) do
</span></span><span class="line"><span class="ln">21</span><span class="cl">          query
</span></span><span class="line"><span class="ln">22</span><span class="cl">        end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">25</span><span class="cl">          for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">26</span><span class="cl">            do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">27</span><span class="cl">        end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">          for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">31</span><span class="cl">        end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">34</span><span class="cl">          dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">35</span><span class="cl">        end
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">        defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">          dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">39</span><span class="cl">        end
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl">        defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">42</span><span class="cl">          do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">43</span><span class="cl">
</span></span><span class="line"><span class="ln">44</span><span class="cl">        defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">45</span><span class="cl">
</span></span><span class="line"><span class="ln">46</span><span class="cl">        defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">47</span><span class="cl">        defp present?(_), do: false
</span></span><span class="line"><span class="ln">48</span><span class="cl">      end
</span></span><span class="line"><span class="ln">49</span><span class="cl">    end
</span></span><span class="line"><span class="ln">50</span><span class="cl">  end</span></span></code></pre></div><h2 id="usage">Usage</h2>
<p>It&rsquo;s a piece of cake to use our query in another modules. Just include
our query and set the list of allowed attributes through <code>use</code>
construction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  {:ok, _} = Application.ensure_all_started(:ex_machina)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Example of using dynamic ecto queries
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    import Factory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    use FilterQuery, attributes: ~w(proficiency name)a
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def run do
</span></span><span class="line"><span class="ln">12</span><span class="cl">      insert_users()
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      IO.inspect(count([])) # 3
</span></span><span class="line"><span class="ln">15</span><span class="cl">      [relationships_status: [&#34;married&#34;]] |&gt; count([]) |&gt; IO.inspect # 3
</span></span><span class="line"><span class="ln">16</span><span class="cl">      [proficiency: [&#34;developer&#34;]] |&gt; count([]) |&gt; IO.inspect # 1
</span></span><span class="line"><span class="ln">17</span><span class="cl">      [proficiency: [&#34;soldier&#34;]] |&gt; count([]) |&gt; IO.inspect # 0
</span></span><span class="line"><span class="ln">18</span><span class="cl">      IO.inspect(count([], %{proficiency: [&#34;politic&#34;]})) # 2
</span></span><span class="line"><span class="ln">19</span><span class="cl">    end
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    defp insert_users do
</span></span><span class="line"><span class="ln">22</span><span class="cl">      Repo.delete_all(User)
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      insert(:user, relationships_status: &#34;single&#34;, proficiency: &#34;developer&#34;)
</span></span><span class="line"><span class="ln">25</span><span class="cl">      insert(:user, relationships_status: &#34;married&#34;, proficiency: &#34;politic&#34;)
</span></span><span class="line"><span class="ln">26</span><span class="cl">      insert(:user, relationships_status: &#34;dating&#34;, proficiency: &#34;thief&#34;)
</span></span><span class="line"><span class="ln">27</span><span class="cl">    end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    defp count(inclusion, exclusion \\ []) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">      User
</span></span><span class="line"><span class="ln">31</span><span class="cl">      |&gt; filter(inclusion, exclusion)
</span></span><span class="line"><span class="ln">32</span><span class="cl">      |&gt; Repo.aggregate(:count, :id)
</span></span><span class="line"><span class="ln">33</span><span class="cl">    end
</span></span><span class="line"><span class="ln">34</span><span class="cl">  end</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>However, this is not at all that we can achieve by using <code>dynamic</code> macro
in Ecto.</p>
<p>You can filter by regex, type or even your own query; sort by ascending
and descending; do aggregation or pagination; whatever comes to your
head - it all depends on your imagination and skills. Ecto provides you
a great tool to build any complex queries by writing minimal lines of
code without any duplication.</p>
<p>What&rsquo;s next? See the <a href="https://github.com/ne1ro/dynamic_ecto_query">full
example</a> for this article or read
<a href="https://hexdocs.pm/ecto/Ecto.Query.html">Ecto documentation</a> to
deepen your knowledge a little bit more.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>How are are using Elixir</title>
      <link>https://neiro.io/blog/2017-03-14-how-we-are-using-elixir.md/</link>
      <pubDate>Tue, 14 Mar 2017 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/blog/2017-03-14-how-we-are-using-elixir.md/</guid>
      <description>&lt;p&gt;This post is a continuation of series of posts started in previous&#xA;article. Previously we&amp;rsquo;ve talked about one of the most awesome,&#xA;innovative and pleasant projects that we had the honor to develop here&#xA;in FlatStack. In this article I will tell you about the problems we&amp;rsquo;ve&#xA;faced and how the right choice of technologies stack helped us to solve&#xA;them.&lt;/p&gt;&#xA;&lt;h2 id=&#34;concerns-that-weve-faced&#34;&gt;Concerns that we&amp;rsquo;ve faced&lt;/h2&gt;&#xA;&lt;p&gt;When we started this project we knew right away that the features that&#xA;we need to implement aren&amp;rsquo;t that simple. It&amp;rsquo;s not a typical website with&#xA;predefined functionality and common list of features, it&amp;rsquo;s not a web&#xA;store or blog, but rather a more complex and solid service. The heart of&#xA;our project is the time lapse build process.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>This post is a continuation of series of posts started in previous
article. Previously we&rsquo;ve talked about one of the most awesome,
innovative and pleasant projects that we had the honor to develop here
in FlatStack. In this article I will tell you about the problems we&rsquo;ve
faced and how the right choice of technologies stack helped us to solve
them.</p>
<h2 id="concerns-that-weve-faced">Concerns that we&rsquo;ve faced</h2>
<p>When we started this project we knew right away that the features that
we need to implement aren&rsquo;t that simple. It&rsquo;s not a typical website with
predefined functionality and common list of features, it&rsquo;s not a web
store or blog, but rather a more complex and solid service. The heart of
our project is the time lapse build process.</p>
<p>We&rsquo;re operating the huge amount of photos distributed in time by hours,
days, months or even years. It would be nice if we could see these
photos through time to see progress, changes or development of
something. Therefore we can just clue these images into one
videoâ&mdash;âtime lapse. However, this feature isn&rsquo;t that simple as it
sounds. The entire build process is multi-staged and sophisticated
because it requires operations with external resources, data storages,
system utilities. We need to make several steps before we get the time
lapse:</p>
<ul>
<li>We need to select only favourable photos that we want to see in our
video. Shoots made late at night or at the noon may be not acceptable
by users so we need to define a time range and filter images that are
following this conditions.</li>
<li>We need to download preferred images each one by one in the fastest
and most reliable way. We need to fetch them in parallel but at the
same time we must be sure that all of downloads have been completed
successfullyâ&mdash;âwe can&rsquo;t make time lapse with broken files or
incomplete data.</li>
<li>Finally we need to create a video from downloaded images. It&rsquo;s an
external process that is most important and fragile in entire
infrastructure. We need to make it most stable and reliable part
because we need to get finished video despite of all.</li>
<li>After successful time lapse build it would be nice to upload it to
cloud storage to share it with the other users.</li>
</ul>
<p>So these features were not easy and straightforward. We&rsquo;ve faced many
concerns and problems regarding these tasks:</p>
<ul>
<li>We need an external service to store photos and related data.
Therefore, it&rsquo;s required to have sharp tools to operate with it.</li>
<li>Downloading many files as fast as possible is quite hard. We need to
create batch fetches to achieve this velocity and not overflow network
connections.</li>
<li>We want to use well-tried, attested tools to operate video processes.
Unfortunately, these tools come as a command line utilities and we
need to run them in external threads per each time lapse build
process.</li>
<li>As it was said before, time lapse functionality is much more than core
of our entire system. Consequently, we must be sure that every fetch,
download or build process is successful. We can&rsquo;t afford the errors or
broken builds.</li>
<li>Timelapse server can be easily distributed and scaled in case of
increased load. It should just work despite high pressure, low system
resources or any other cases.</li>
</ul>
<p>These issues are not so easy to solve when you&rsquo;re trying to fix them
using popular programming languages or technologies. Most of them are
not so fault-tolerant, not process-oriented and requires much more
complexity to build such things. But we were free in selecting
technologies stack so we&rsquo;ve decided to give a chance to Elixir. And
after successful development of time lapse service we certainly sure
that this was the right choice.</p>
<h2 id="what-is-an-elixir">What is an Elixir?</h2>
<p>It&rsquo;s not just a new fancy, shiny programming language. It&rsquo;s an entire
platform based on mature, robust Erlang VM and it&rsquo;s ecosystem. What are
key benefits of Erlang runtime system? Well, the are plenty of them:</p>
<ul>
<li>Light-weight user-space threads</li>
<li>It can be easily distributed on myriads of servers</li>
<li>You can swap your code without restarting server e.g.Â hot-swap</li>
<li>It encourages to write highly available, non-stop applications</li>
<li>Fault-tolerancy</li>
<li>It allows you to write soft real-time systems</li>
</ul>
<p>Elixir comes with pleasant Ruby-like syntax and fully compatibility with
any Erlang code. But it also extends standard Erlang library and
provides more tools and libraries:</p>
<ul>
<li>Unicode string and operations</li>
<li>Built-in test framework</li>
<li>Meta-programming e.g.Â macroses</li>
<li>Even more data structures</li>
<li>Polymorphic records</li>
<li>Strict and lazy enumeration APIs</li>
<li>Advanced scripting tools</li>
<li>A project management tool to compile and test Elixir code</li>
<li>Useful OTP (Open Telecom Platform) abstractions like Agent, Task,
GenStage</li>
</ul>
<p>We&rsquo;ve tried Elixir before in our hackathon projects and it established
itself as a powerful and eloquent tool for developing complex
thread-based applications, e.g servers, process supervisors. Therefore
we&rsquo;ve decided that core features and advantages of Elixir as both
programming language and platform will doubtless help us to solve our
problems so we&rsquo;ve decided to give it a chance.</p>
<h2 id="how-weve-actually-used-elixir">How we&rsquo;ve actually used Elixir?</h2>
<p>At the first, we&rsquo;ve created a base skeleton for our new Elixir
applications: <a href="https://github.com/fs/elixir-base">https://github.com/fs/elixir-base</a>. In this repository
we&rsquo;ve developed just a simple template that contains required libraries,
scripts and tools that we like to use to.</p>
<p>The heart of project, time lapse service is based on this skeleton.
Basically it&rsquo;s just a simple server written in Elixir, but it contains
multiple supervisors, processes, distribution steps. OTP tools are just
great for building such applications, they allow us to write complex
multi-thread logic in elegant and simple way. So how it help us with
solving main problems and concerns?</p>
<ul>
<li>We&rsquo;re using Amazon Web Services for storing our data. Elixir and
Erlang have a great third-party libraries that work with it&rsquo;s API. We
can provide any configuration that we want, we can supervise calls or
request to AWS and make sure that they will be successful.</li>
<li>We can create complex asynchronous constructions using processes.
Batch files download can be easily implemented by starting fetching
each file in parallel, in his own process.</li>
<li>Elixir ecosystem has great tools for operating external processes,
e.g.Â command line utilities. You can use ports for or native
implemented functions for communicating with another system-level
processes, supervise them, start or shut them down.</li>
<li>Elixir is extremely fault-tolerant. It&rsquo;s core principle &ldquo;Let it crash&rdquo;
may sound confusing, but really it&rsquo;s a whole gift. Everything that can
fail will restart again. It encourages you not to use defensive
programming, but to architecture your application using supervisor and
processes tree. This will lead to stability and robustness.</li>
<li>Elixir has great tools for distribution and scaling that come out of
the box. Nevertheless, it has also libraries that help us to avoid
performance issues. Any bottlenecks related to limited system
resources or calls to external services can be solved using GenStage
and it&rsquo;s dynamic supervisors. We will provide your more details about
this fascinating abstractions in the next post of this series.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Developing process of Elixir micro service was not that fast at first.
When we created the first fully-functional prototype we thought that it
was already completed and reliable. But after some time we saw the
endless possibilities to improve our current implementation and making
it more robust and stable.</p>
<p>We did a stress testing of our service and understood that we need more
flexibility and steadiness for each step of time lapse build process.
Therefore we tried to rethink our entire architecture and the build flow
and we&rsquo;ve ended up reconstructing our application using GenStages. This
approach finally resolved our main concerns regarding application
stability and performance bottlenecks and we&rsquo;ll share with you some more
information about this in our next post.</p>
]]></content:encoded>
    </item>
    <item>
      <title>How are are using Elixir</title>
      <link>https://neiro.io/posts/2017-03-14-how-we-are-using-elixir.md/</link>
      <pubDate>Tue, 14 Mar 2017 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/posts/2017-03-14-how-we-are-using-elixir.md/</guid>
      <description>&lt;p&gt;This post is a continuation of series of posts started in previous&#xA;article. Previously we&amp;rsquo;ve talked about one of the most awesome,&#xA;innovative and pleasant projects that we had the honor to develop here&#xA;in FlatStack. In this article I will tell you about the problems we&amp;rsquo;ve&#xA;faced and how the right choice of technologies stack helped us to solve&#xA;them.&lt;/p&gt;&#xA;&lt;h2 id=&#34;concerns-that-weve-faced&#34;&gt;Concerns that we&amp;rsquo;ve faced&lt;/h2&gt;&#xA;&lt;p&gt;When we started this project we knew right away that the features that&#xA;we need to implement aren&amp;rsquo;t that simple. It&amp;rsquo;s not a typical website with&#xA;predefined functionality and common list of features, it&amp;rsquo;s not a web&#xA;store or blog, but rather a more complex and solid service. The heart of&#xA;our project is the time lapse build process.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>This post is a continuation of series of posts started in previous
article. Previously we&rsquo;ve talked about one of the most awesome,
innovative and pleasant projects that we had the honor to develop here
in FlatStack. In this article I will tell you about the problems we&rsquo;ve
faced and how the right choice of technologies stack helped us to solve
them.</p>
<h2 id="concerns-that-weve-faced">Concerns that we&rsquo;ve faced</h2>
<p>When we started this project we knew right away that the features that
we need to implement aren&rsquo;t that simple. It&rsquo;s not a typical website with
predefined functionality and common list of features, it&rsquo;s not a web
store or blog, but rather a more complex and solid service. The heart of
our project is the time lapse build process.</p>
<p>We&rsquo;re operating the huge amount of photos distributed in time by hours,
days, months or even years. It would be nice if we could see these
photos through time to see progress, changes or development of
something. Therefore we can just clue these images into one
videoâ&mdash;âtime lapse. However, this feature isn&rsquo;t that simple as it
sounds. The entire build process is multi-staged and sophisticated
because it requires operations with external resources, data storages,
system utilities. We need to make several steps before we get the time
lapse:</p>
<ul>
<li>We need to select only favourable photos that we want to see in our
video. Shoots made late at night or at the noon may be not acceptable
by users so we need to define a time range and filter images that are
following this conditions.</li>
<li>We need to download preferred images each one by one in the fastest
and most reliable way. We need to fetch them in parallel but at the
same time we must be sure that all of downloads have been completed
successfullyâ&mdash;âwe can&rsquo;t make time lapse with broken files or
incomplete data.</li>
<li>Finally we need to create a video from downloaded images. It&rsquo;s an
external process that is most important and fragile in entire
infrastructure. We need to make it most stable and reliable part
because we need to get finished video despite of all.</li>
<li>After successful time lapse build it would be nice to upload it to
cloud storage to share it with the other users.</li>
</ul>
<p>So these features were not easy and straightforward. We&rsquo;ve faced many
concerns and problems regarding these tasks:</p>
<ul>
<li>We need an external service to store photos and related data.
Therefore, it&rsquo;s required to have sharp tools to operate with it.</li>
<li>Downloading many files as fast as possible is quite hard. We need to
create batch fetches to achieve this velocity and not overflow network
connections.</li>
<li>We want to use well-tried, attested tools to operate video processes.
Unfortunately, these tools come as a command line utilities and we
need to run them in external threads per each time lapse build
process.</li>
<li>As it was said before, time lapse functionality is much more than core
of our entire system. Consequently, we must be sure that every fetch,
download or build process is successful. We can&rsquo;t afford the errors or
broken builds.</li>
<li>Timelapse server can be easily distributed and scaled in case of
increased load. It should just work despite high pressure, low system
resources or any other cases.</li>
</ul>
<p>These issues are not so easy to solve when you&rsquo;re trying to fix them
using popular programming languages or technologies. Most of them are
not so fault-tolerant, not process-oriented and requires much more
complexity to build such things. But we were free in selecting
technologies stack so we&rsquo;ve decided to give a chance to Elixir. And
after successful development of time lapse service we certainly sure
that this was the right choice.</p>
<h2 id="what-is-an-elixir">What is an Elixir?</h2>
<p>It&rsquo;s not just a new fancy, shiny programming language. It&rsquo;s an entire
platform based on mature, robust Erlang VM and it&rsquo;s ecosystem. What are
key benefits of Erlang runtime system? Well, the are plenty of them:</p>
<ul>
<li>Light-weight user-space threads</li>
<li>It can be easily distributed on myriads of servers</li>
<li>You can swap your code without restarting server e.g.Â hot-swap</li>
<li>It encourages to write highly available, non-stop applications</li>
<li>Fault-tolerancy</li>
<li>It allows you to write soft real-time systems</li>
</ul>
<p>Elixir comes with pleasant Ruby-like syntax and fully compatibility with
any Erlang code. But it also extends standard Erlang library and
provides more tools and libraries:</p>
<ul>
<li>Unicode string and operations</li>
<li>Built-in test framework</li>
<li>Meta-programming e.g.Â macroses</li>
<li>Even more data structures</li>
<li>Polymorphic records</li>
<li>Strict and lazy enumeration APIs</li>
<li>Advanced scripting tools</li>
<li>A project management tool to compile and test Elixir code</li>
<li>Useful OTP (Open Telecom Platform) abstractions like Agent, Task,
GenStage</li>
</ul>
<p>We&rsquo;ve tried Elixir before in our hackathon projects and it established
itself as a powerful and eloquent tool for developing complex
thread-based applications, e.g servers, process supervisors. Therefore
we&rsquo;ve decided that core features and advantages of Elixir as both
programming language and platform will doubtless help us to solve our
problems so we&rsquo;ve decided to give it a chance.</p>
<h2 id="how-weve-actually-used-elixir">How we&rsquo;ve actually used Elixir?</h2>
<p>At the first, we&rsquo;ve created a base skeleton for our new Elixir
applications: <a href="https://github.com/fs/elixir-base">https://github.com/fs/elixir-base</a>. In this repository
we&rsquo;ve developed just a simple template that contains required libraries,
scripts and tools that we like to use to.</p>
<p>The heart of project, time lapse service is based on this skeleton.
Basically it&rsquo;s just a simple server written in Elixir, but it contains
multiple supervisors, processes, distribution steps. OTP tools are just
great for building such applications, they allow us to write complex
multi-thread logic in elegant and simple way. So how it help us with
solving main problems and concerns?</p>
<ul>
<li>We&rsquo;re using Amazon Web Services for storing our data. Elixir and
Erlang have a great third-party libraries that work with it&rsquo;s API. We
can provide any configuration that we want, we can supervise calls or
request to AWS and make sure that they will be successful.</li>
<li>We can create complex asynchronous constructions using processes.
Batch files download can be easily implemented by starting fetching
each file in parallel, in his own process.</li>
<li>Elixir ecosystem has great tools for operating external processes,
e.g.Â command line utilities. You can use ports for or native
implemented functions for communicating with another system-level
processes, supervise them, start or shut them down.</li>
<li>Elixir is extremely fault-tolerant. It&rsquo;s core principle &ldquo;Let it crash&rdquo;
may sound confusing, but really it&rsquo;s a whole gift. Everything that can
fail will restart again. It encourages you not to use defensive
programming, but to architecture your application using supervisor and
processes tree. This will lead to stability and robustness.</li>
<li>Elixir has great tools for distribution and scaling that come out of
the box. Nevertheless, it has also libraries that help us to avoid
performance issues. Any bottlenecks related to limited system
resources or calls to external services can be solved using GenStage
and it&rsquo;s dynamic supervisors. We will provide your more details about
this fascinating abstractions in the next post of this series.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Developing process of Elixir micro service was not that fast at first.
When we created the first fully-functional prototype we thought that it
was already completed and reliable. But after some time we saw the
endless possibilities to improve our current implementation and making
it more robust and stable.</p>
<p>We did a stress testing of our service and understood that we need more
flexibility and steadiness for each step of time lapse build process.
Therefore we tried to rethink our entire architecture and the build flow
and we&rsquo;ve ended up reconstructing our application using GenStages. This
approach finally resolved our main concerns regarding application
stability and performance bottlenecks and we&rsquo;ll share with you some more
information about this in our next post.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markov chains in Elixir</title>
      <link>https://neiro.io/blog/2016-07-31-markov-chains-in-elixir.md/</link>
      <pubDate>Sun, 31 Jul 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2016-07-31-markov-chains-in-elixir.md/</guid>
      <description>&lt;h2 id=&#34;markov-chains&#34;&gt;Markov chains&lt;/h2&gt;&#xA;&lt;p&gt;Markov chain or Markov model is a process that undergoes transitions&#xA;from one state to another. The next state depends only on current state&#xA;and not the sequence of previous events. This allows us to use Markov&#xA;chains as statistical models for real-world processes.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/7/7a/Markov_Chain_weather_model_matrix_as_a_graph.png&#34;&#xA;    alt=&#34;Figure 1: Simple Markov chain&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;&lt;span class=&#34;figure-number&#34;&gt;Figure 1: &lt;/span&gt;Simple Markov chain&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;For the next example we will try to build simple sentence generator&#xA;within Markov chain.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="markov-chains">Markov chains</h2>
<p>Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Markov_Chain_weather_model_matrix_as_a_graph.png"
    alt="Figure 1: Simple Markov chain"><figcaption>
      <p><span class="figure-number">Figure 1: </span>Simple Markov chain</p>
    </figcaption>
</figure>

<p>For the next example we will try to build simple sentence generator
within Markov chain.</p>
<h2 id="realization">Realization</h2>
<p>Let&rsquo;s create an entry point of new application:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir markov chain.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      alias ElixirMarkovChain.Model
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      alias ElixirMarkovChain.Generator
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">      def start(_type, _args) do
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        case File.read(Application.get_env :elixir_markov_chain, :source_file) do
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">           {:ok, body} -&gt; process_source body
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">           {:error, reason} -&gt; IO.puts reason
</span></span><span class="line"><span class="ln">10</span><span class="cl">        end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        System.halt 0
</span></span><span class="line"><span class="ln">13</span><span class="cl">      end
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">      defp process_source do
</span></span><span class="line"><span class="ln">16</span><span class="cl">      end
</span></span><span class="line"><span class="ln">17</span><span class="cl">    end</span></span></code></pre></div><p>At first, to process the source file for output sentences, we need to
tokenize it:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">    # lib/elixir_markov_chain/tokenizer.ex
</span></span><span class="line"><span class="ln">2</span><span class="cl">    defmodule ElixirMarkovChain.Tokenizer do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      def tokenize(text) do
</span></span><span class="line"><span class="ln">4</span><span class="cl">        text
</span></span><span class="line"><span class="ln">5</span><span class="cl">          |&gt; String.downcase
</span></span><span class="line"><span class="ln">6</span><span class="cl">          |&gt; String.split(~r{\n}, trim: true) # split text to sentences
</span></span><span class="line"><span class="ln">7</span><span class="cl">          |&gt; Enum.map(&amp;String.split/1) # split sentences to words
</span></span><span class="line"><span class="ln">8</span><span class="cl">      end
</span></span><span class="line"><span class="ln">9</span><span class="cl">    end</span></span></code></pre></div><p>Next we need to realize Markov model. We&rsquo;ll use agents to share state in
application:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir_markov_chain/model.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain.Model do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      import ElixirMarkovChain.Tokenizer
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      def start_link, do: Agent.start_link(fn -&gt; %{} end) # create map for sharing through agent
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      def populate(pid, text) do
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        for tokens &lt;- tokenize(text), do: modelize(pid, tokens) # populate model with tokens
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        pid
</span></span><span class="line"><span class="ln">10</span><span class="cl">      end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">      def fetch_token(state, pid) do
</span></span><span class="line"><span class="ln">13</span><span class="cl">        tokens = fetch_tokens state, pid
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        if length(tokens) &gt; 0 do
</span></span><span class="line"><span class="ln">16</span><span class="cl">          token = Enum.random tokens
</span></span><span class="line"><span class="ln">17</span><span class="cl">          count = tokens |&gt; Enum.count(&amp;(token == &amp;1))
</span></span><span class="line"><span class="ln">18</span><span class="cl">          {token, count / length(tokens)} # count probability of the token
</span></span><span class="line"><span class="ln">19</span><span class="cl">        else
</span></span><span class="line"><span class="ln">20</span><span class="cl">          {&#34;&#34;, 0.0}
</span></span><span class="line"><span class="ln">21</span><span class="cl">        end
</span></span><span class="line"><span class="ln">22</span><span class="cl">      end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      def fetch_state(tokens), do: fetch_state(tokens, length(tokens))
</span></span><span class="line"><span class="ln">25</span><span class="cl">      defp fetch_state(_tokens, id) when id == 0, do: {nil, nil}
</span></span><span class="line"><span class="ln">26</span><span class="cl">      defp fetch_state([head | _tail], id) when id == 1, do: {nil, head}
</span></span><span class="line"><span class="ln">27</span><span class="cl">      defp fetch_state(tokens, id) do
</span></span><span class="line"><span class="ln">28</span><span class="cl">        tokens
</span></span><span class="line"><span class="ln">29</span><span class="cl">          |&gt; Enum.slice(id - 2..id - 1) # fetch states by ids
</span></span><span class="line"><span class="ln">30</span><span class="cl">          |&gt; List.to_tuple
</span></span><span class="line"><span class="ln">31</span><span class="cl">      end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">      # Get tokens within agent
</span></span><span class="line"><span class="ln">34</span><span class="cl">      defp fetch_tokens(state, pid), do: Agent.get pid, &amp;(&amp;1[state] || [])
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">      # Build Markov chain model using tokens
</span></span><span class="line"><span class="ln">37</span><span class="cl">      defp modelize(pid, tokens) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">        for {token, id} &lt;- Enum.with_index(tokens) do
</span></span><span class="line"><span class="ln">39</span><span class="cl">          tokens |&gt; fetch_state(id) |&gt; add_state(pid, token)
</span></span><span class="line"><span class="ln">40</span><span class="cl">        end
</span></span><span class="line"><span class="ln">41</span><span class="cl">      end
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">      # Add new state within agent
</span></span><span class="line"><span class="ln">44</span><span class="cl">      defp add_state(state, pid, token) do
</span></span><span class="line"><span class="ln">45</span><span class="cl">        Agent.update pid, fn(model) -&gt;
</span></span><span class="line"><span class="ln">46</span><span class="cl">          current_state = model[state] || []
</span></span><span class="line"><span class="ln">47</span><span class="cl">          Map.put model, state, [token | current_state]
</span></span><span class="line"><span class="ln">48</span><span class="cl">        end
</span></span><span class="line"><span class="ln">49</span><span class="cl">      end
</span></span><span class="line"><span class="ln">50</span><span class="cl">    end</span></span></code></pre></div><p>When our Markov model is done, we can use it in application. For this
example, we&rsquo;ll build a random sentence generator based on text source:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir_markov_chain/generator.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain.Generator do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      alias ElixirMarkovChain.Model
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      def create_sentence(pid) do
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        {sentence, prob} = build_sentence pid
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # Create new sentence or convert builded based on treshold value
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        if prob &gt;= Application.get_env(:elixir_markov_chain, :treshold) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">          sentence |&gt; Enum.join(&#34; &#34;) |&gt; String.capitalize
</span></span><span class="line"><span class="ln">11</span><span class="cl">        else
</span></span><span class="line"><span class="ln">12</span><span class="cl">          create_sentence pid
</span></span><span class="line"><span class="ln">13</span><span class="cl">        end
</span></span><span class="line"><span class="ln">14</span><span class="cl">      end
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">      # Sentence is complete when it have enough length
</span></span><span class="line"><span class="ln">17</span><span class="cl">      # or when punctuation ends a sentence
</span></span><span class="line"><span class="ln">18</span><span class="cl">      defp complete?(tokens) do
</span></span><span class="line"><span class="ln">19</span><span class="cl">        length(tokens) &gt; 15 ||
</span></span><span class="line"><span class="ln">20</span><span class="cl">        (length(tokens) &gt; 3 &amp;&amp; Regex.match?(~r/[\!\?\.]\z/, List.last tokens))
</span></span><span class="line"><span class="ln">21</span><span class="cl">      end
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">      defp build_sentence(pid), do: build_sentence(pid, [], 0.0, 0.0)
</span></span><span class="line"><span class="ln">24</span><span class="cl">      defp build_sentence(pid, tokens, prob_acc, new_tokens) do
</span></span><span class="line"><span class="ln">25</span><span class="cl">        # Fetch Markov model state through agent
</span></span><span class="line"><span class="ln">26</span><span class="cl">        {token, prob} = tokens |&gt; Model.fetch_state |&gt; Model.fetch_token(pid)
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">        case complete?(tokens) do
</span></span><span class="line"><span class="ln">29</span><span class="cl">          true -&gt;
</span></span><span class="line"><span class="ln">30</span><span class="cl">            score = case new_tokens == 0 do
</span></span><span class="line"><span class="ln">31</span><span class="cl">              true -&gt; 1.0
</span></span><span class="line"><span class="ln">32</span><span class="cl">              _ -&gt; prob_acc / new_tokens # count new probability for this word
</span></span><span class="line"><span class="ln">33</span><span class="cl">            end
</span></span><span class="line"><span class="ln">34</span><span class="cl">            {tokens, score}
</span></span><span class="line"><span class="ln">35</span><span class="cl">          _ -&gt;
</span></span><span class="line"><span class="ln">36</span><span class="cl">            # Concat sentence with new token and try to continue
</span></span><span class="line"><span class="ln">37</span><span class="cl">            build_sentence pid, tokens ++ [token], prob + prob_acc, new_tokens + 1
</span></span><span class="line"><span class="ln">38</span><span class="cl">        end
</span></span><span class="line"><span class="ln">39</span><span class="cl">      end
</span></span><span class="line"><span class="ln">40</span><span class="cl">    end</span></span></code></pre></div><p>Now, when basic logic is implemented, we need to fill <code>process_source</code>
function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">    # lib/elixir_markov_chain.ex
</span></span><span class="line"><span class="ln">2</span><span class="cl">    defp process_source(text) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, model} = Model.start_link
</span></span><span class="line"><span class="ln">4</span><span class="cl">      model = Model.populate model, text # populate Markov model with the source
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">      # Generate 10 random sentences based on text source
</span></span><span class="line"><span class="ln">7</span><span class="cl">      Enum.each(1..10, fn(_) -&gt; model |&gt; Generator.create_sentence |&gt; IO.puts end)
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end</span></span></code></pre></div><h2 id="result">Result</h2>
<p>Processed from <em>Thus Spoke Zarathustra</em> by <em>Friedrich Nietzsche</em>:</p>
<ul>
<li>By thee pursued, my fancy!</li>
<li>Nether-world, thou exuberant star!</li>
<li>Well then! we part here!</li>
<li>Snare for me&ndash;the desire for love&ndash;that i should like to strangle me,
thou fountain of delight!</li>
<li>As yet without meaning: a buffoon at heart.</li>
<li>Loved by overflowing hearts.</li>
<li>Growling bear, and sweeten thy soul!</li>
<li>Fountains shall rush down into his height!</li>
</ul>
<p>Processed from <em>Metamorphosis</em> by <em>Franz Kafka</em>:</p>
<ul>
<li>&ldquo;it&rsquo;s got to get up.</li>
<li>Where we have to open the door, holding himself upright as preparation
for getting through the</li>
<li>Incidental damages even if he did not know that he wouldn&rsquo;t have to
suffer the view</li>
<li>The gentlemen bent over the dishes set in front of them were blown
onto the cool,</li>
<li>Gregor then turned to look after my parents suffer!</li>
<li>&ldquo;we have to overcome it because of that.</li>
<li>Does not agree to be patient.</li>
<li>&ldquo;leave my home. now!&rdquo;, said mr.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Elixir allows to easily build Markov chains and applicate them to real
world processes. In our case we have built the random text generator,
but you can find Markov models useful for another cases. To view entire
application please visit
<a href="https://github.com/ne1ro/elixir-markov-chain">this repository</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Markov chains in Elixir</title>
      <link>https://neiro.io/posts/2016-07-31-markov-chains-in-elixir.md/</link>
      <pubDate>Sun, 31 Jul 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2016-07-31-markov-chains-in-elixir.md/</guid>
      <description>&lt;h2 id=&#34;markov-chains&#34;&gt;Markov chains&lt;/h2&gt;&#xA;&lt;p&gt;Markov chain or Markov model is a process that undergoes transitions&#xA;from one state to another. The next state depends only on current state&#xA;and not the sequence of previous events. This allows us to use Markov&#xA;chains as statistical models for real-world processes.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/7/7a/Markov_Chain_weather_model_matrix_as_a_graph.png&#34;&#xA;    alt=&#34;Figure 1: Simple Markov chain&#34;&gt;&lt;figcaption&gt;&#xA;      &lt;p&gt;&lt;span class=&#34;figure-number&#34;&gt;Figure 1: &lt;/span&gt;Simple Markov chain&lt;/p&gt;&#xA;    &lt;/figcaption&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;For the next example we will try to build simple sentence generator&#xA;within Markov chain.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<h2 id="markov-chains">Markov chains</h2>
<p>Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Markov_Chain_weather_model_matrix_as_a_graph.png"
    alt="Figure 1: Simple Markov chain"><figcaption>
      <p><span class="figure-number">Figure 1: </span>Simple Markov chain</p>
    </figcaption>
</figure>

<p>For the next example we will try to build simple sentence generator
within Markov chain.</p>
<h2 id="realization">Realization</h2>
<p>Let&rsquo;s create an entry point of new application:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir markov chain.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      alias ElixirMarkovChain.Model
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      alias ElixirMarkovChain.Generator
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">      def start(_type, _args) do
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        case File.read(Application.get_env :elixir_markov_chain, :source_file) do
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">           {:ok, body} -&gt; process_source body
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">           {:error, reason} -&gt; IO.puts reason
</span></span><span class="line"><span class="ln">10</span><span class="cl">        end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        System.halt 0
</span></span><span class="line"><span class="ln">13</span><span class="cl">      end
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">      defp process_source do
</span></span><span class="line"><span class="ln">16</span><span class="cl">      end
</span></span><span class="line"><span class="ln">17</span><span class="cl">    end</span></span></code></pre></div><p>At first, to process the source file for output sentences, we need to
tokenize it:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">    # lib/elixir_markov_chain/tokenizer.ex
</span></span><span class="line"><span class="ln">2</span><span class="cl">    defmodule ElixirMarkovChain.Tokenizer do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      def tokenize(text) do
</span></span><span class="line"><span class="ln">4</span><span class="cl">        text
</span></span><span class="line"><span class="ln">5</span><span class="cl">          |&gt; String.downcase
</span></span><span class="line"><span class="ln">6</span><span class="cl">          |&gt; String.split(~r{\n}, trim: true) # split text to sentences
</span></span><span class="line"><span class="ln">7</span><span class="cl">          |&gt; Enum.map(&amp;String.split/1) # split sentences to words
</span></span><span class="line"><span class="ln">8</span><span class="cl">      end
</span></span><span class="line"><span class="ln">9</span><span class="cl">    end</span></span></code></pre></div><p>Next we need to realize Markov model. We&rsquo;ll use agents to share state in
application:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir_markov_chain/model.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain.Model do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      import ElixirMarkovChain.Tokenizer
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      def start_link, do: Agent.start_link(fn -&gt; %{} end) # create map for sharing through agent
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      def populate(pid, text) do
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        for tokens &lt;- tokenize(text), do: modelize(pid, tokens) # populate model with tokens
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        pid
</span></span><span class="line"><span class="ln">10</span><span class="cl">      end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">      def fetch_token(state, pid) do
</span></span><span class="line"><span class="ln">13</span><span class="cl">        tokens = fetch_tokens state, pid
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        if length(tokens) &gt; 0 do
</span></span><span class="line"><span class="ln">16</span><span class="cl">          token = Enum.random tokens
</span></span><span class="line"><span class="ln">17</span><span class="cl">          count = tokens |&gt; Enum.count(&amp;(token == &amp;1))
</span></span><span class="line"><span class="ln">18</span><span class="cl">          {token, count / length(tokens)} # count probability of the token
</span></span><span class="line"><span class="ln">19</span><span class="cl">        else
</span></span><span class="line"><span class="ln">20</span><span class="cl">          {&#34;&#34;, 0.0}
</span></span><span class="line"><span class="ln">21</span><span class="cl">        end
</span></span><span class="line"><span class="ln">22</span><span class="cl">      end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      def fetch_state(tokens), do: fetch_state(tokens, length(tokens))
</span></span><span class="line"><span class="ln">25</span><span class="cl">      defp fetch_state(_tokens, id) when id == 0, do: {nil, nil}
</span></span><span class="line"><span class="ln">26</span><span class="cl">      defp fetch_state([head | _tail], id) when id == 1, do: {nil, head}
</span></span><span class="line"><span class="ln">27</span><span class="cl">      defp fetch_state(tokens, id) do
</span></span><span class="line"><span class="ln">28</span><span class="cl">        tokens
</span></span><span class="line"><span class="ln">29</span><span class="cl">          |&gt; Enum.slice(id - 2..id - 1) # fetch states by ids
</span></span><span class="line"><span class="ln">30</span><span class="cl">          |&gt; List.to_tuple
</span></span><span class="line"><span class="ln">31</span><span class="cl">      end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">      # Get tokens within agent
</span></span><span class="line"><span class="ln">34</span><span class="cl">      defp fetch_tokens(state, pid), do: Agent.get pid, &amp;(&amp;1[state] || [])
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">      # Build Markov chain model using tokens
</span></span><span class="line"><span class="ln">37</span><span class="cl">      defp modelize(pid, tokens) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">        for {token, id} &lt;- Enum.with_index(tokens) do
</span></span><span class="line"><span class="ln">39</span><span class="cl">          tokens |&gt; fetch_state(id) |&gt; add_state(pid, token)
</span></span><span class="line"><span class="ln">40</span><span class="cl">        end
</span></span><span class="line"><span class="ln">41</span><span class="cl">      end
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">      # Add new state within agent
</span></span><span class="line"><span class="ln">44</span><span class="cl">      defp add_state(state, pid, token) do
</span></span><span class="line"><span class="ln">45</span><span class="cl">        Agent.update pid, fn(model) -&gt;
</span></span><span class="line"><span class="ln">46</span><span class="cl">          current_state = model[state] || []
</span></span><span class="line"><span class="ln">47</span><span class="cl">          Map.put model, state, [token | current_state]
</span></span><span class="line"><span class="ln">48</span><span class="cl">        end
</span></span><span class="line"><span class="ln">49</span><span class="cl">      end
</span></span><span class="line"><span class="ln">50</span><span class="cl">    end</span></span></code></pre></div><p>When our Markov model is done, we can use it in application. For this
example, we&rsquo;ll build a random sentence generator based on text source:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir_markov_chain/generator.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain.Generator do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      alias ElixirMarkovChain.Model
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      def create_sentence(pid) do
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        {sentence, prob} = build_sentence pid
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # Create new sentence or convert builded based on treshold value
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        if prob &gt;= Application.get_env(:elixir_markov_chain, :treshold) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">          sentence |&gt; Enum.join(&#34; &#34;) |&gt; String.capitalize
</span></span><span class="line"><span class="ln">11</span><span class="cl">        else
</span></span><span class="line"><span class="ln">12</span><span class="cl">          create_sentence pid
</span></span><span class="line"><span class="ln">13</span><span class="cl">        end
</span></span><span class="line"><span class="ln">14</span><span class="cl">      end
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">      # Sentence is complete when it have enough length
</span></span><span class="line"><span class="ln">17</span><span class="cl">      # or when punctuation ends a sentence
</span></span><span class="line"><span class="ln">18</span><span class="cl">      defp complete?(tokens) do
</span></span><span class="line"><span class="ln">19</span><span class="cl">        length(tokens) &gt; 15 ||
</span></span><span class="line"><span class="ln">20</span><span class="cl">        (length(tokens) &gt; 3 &amp;&amp; Regex.match?(~r/[\!\?\.]\z/, List.last tokens))
</span></span><span class="line"><span class="ln">21</span><span class="cl">      end
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">      defp build_sentence(pid), do: build_sentence(pid, [], 0.0, 0.0)
</span></span><span class="line"><span class="ln">24</span><span class="cl">      defp build_sentence(pid, tokens, prob_acc, new_tokens) do
</span></span><span class="line"><span class="ln">25</span><span class="cl">        # Fetch Markov model state through agent
</span></span><span class="line"><span class="ln">26</span><span class="cl">        {token, prob} = tokens |&gt; Model.fetch_state |&gt; Model.fetch_token(pid)
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">        case complete?(tokens) do
</span></span><span class="line"><span class="ln">29</span><span class="cl">          true -&gt;
</span></span><span class="line"><span class="ln">30</span><span class="cl">            score = case new_tokens == 0 do
</span></span><span class="line"><span class="ln">31</span><span class="cl">              true -&gt; 1.0
</span></span><span class="line"><span class="ln">32</span><span class="cl">              _ -&gt; prob_acc / new_tokens # count new probability for this word
</span></span><span class="line"><span class="ln">33</span><span class="cl">            end
</span></span><span class="line"><span class="ln">34</span><span class="cl">            {tokens, score}
</span></span><span class="line"><span class="ln">35</span><span class="cl">          _ -&gt;
</span></span><span class="line"><span class="ln">36</span><span class="cl">            # Concat sentence with new token and try to continue
</span></span><span class="line"><span class="ln">37</span><span class="cl">            build_sentence pid, tokens ++ [token], prob + prob_acc, new_tokens + 1
</span></span><span class="line"><span class="ln">38</span><span class="cl">        end
</span></span><span class="line"><span class="ln">39</span><span class="cl">      end
</span></span><span class="line"><span class="ln">40</span><span class="cl">    end</span></span></code></pre></div><p>Now, when basic logic is implemented, we need to fill <code>process_source</code>
function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">    # lib/elixir_markov_chain.ex
</span></span><span class="line"><span class="ln">2</span><span class="cl">    defp process_source(text) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, model} = Model.start_link
</span></span><span class="line"><span class="ln">4</span><span class="cl">      model = Model.populate model, text # populate Markov model with the source
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">      # Generate 10 random sentences based on text source
</span></span><span class="line"><span class="ln">7</span><span class="cl">      Enum.each(1..10, fn(_) -&gt; model |&gt; Generator.create_sentence |&gt; IO.puts end)
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end</span></span></code></pre></div><h2 id="result">Result</h2>
<p>Processed from <em>Thus Spoke Zarathustra</em> by <em>Friedrich Nietzsche</em>:</p>
<ul>
<li>By thee pursued, my fancy!</li>
<li>Nether-world, thou exuberant star!</li>
<li>Well then! we part here!</li>
<li>Snare for me&ndash;the desire for love&ndash;that i should like to strangle me,
thou fountain of delight!</li>
<li>As yet without meaning: a buffoon at heart.</li>
<li>Loved by overflowing hearts.</li>
<li>Growling bear, and sweeten thy soul!</li>
<li>Fountains shall rush down into his height!</li>
</ul>
<p>Processed from <em>Metamorphosis</em> by <em>Franz Kafka</em>:</p>
<ul>
<li>&ldquo;it&rsquo;s got to get up.</li>
<li>Where we have to open the door, holding himself upright as preparation
for getting through the</li>
<li>Incidental damages even if he did not know that he wouldn&rsquo;t have to
suffer the view</li>
<li>The gentlemen bent over the dishes set in front of them were blown
onto the cool,</li>
<li>Gregor then turned to look after my parents suffer!</li>
<li>&ldquo;we have to overcome it because of that.</li>
<li>Does not agree to be patient.</li>
<li>&ldquo;leave my home. now!&rdquo;, said mr.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Elixir allows to easily build Markov chains and applicate them to real
world processes. In our case we have built the random text generator,
but you can find Markov models useful for another cases. To view entire
application please visit
<a href="https://github.com/ne1ro/elixir-markov-chain">this repository</a>.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Pattern matching in Elixir</title>
      <link>https://neiro.io/blog/2016-05-31-pattern-matching-in-elixir.md/</link>
      <pubDate>Tue, 31 May 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2016-05-31-pattern-matching-in-elixir.md/</guid>
      <description>&lt;p&gt;Pattern matching is a key feature of functional programming. It allows&#xA;you to check a given sequence of tokens for the presence of the&#xA;constituents of some pattern. Using pattern matching you can easily&#xA;operate with complex data structures in most expressive and eloquent&#xA;way. Elixir provides pattern matching like any other functional&#xA;programming language.&lt;/p&gt;&#xA;&lt;h2 id=&#34;match-operator&#34;&gt;Match operator&lt;/h2&gt;&#xA;&lt;p&gt;Most of programming languages have assign operator: &lt;code&gt;var x = 10&lt;/code&gt; . In&#xA;Elixir equals sign is actually &lt;em&gt;match operator&lt;/em&gt;. Using this operator we&#xA;can assign and match values:&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.</p>
<h2 id="match-operator">Match operator</h2>
<p>Most of programming languages have assign operator: <code>var x = 10</code> . In
Elixir equals sign is actually <em>match operator</em>. Using this operator we
can assign and match values:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  1 = x
</span></span><span class="line"><span class="ln">3</span><span class="cl">  x # 1</span></span></code></pre></div><p>But if we will provide invalid pattern?</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  2 = x # ** (MatchError) no match of right hand side value: 1</span></span></code></pre></div><p>As you see, Elixir raises <code>MatchError</code> because left and right sides of
match operator are different - they don&rsquo;t match. You can assign variable
only on the left side of match operator:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  true = undefined # * (CompileError) undefined function undefined/0</span></span></code></pre></div><h2 id="pattern-matching">Pattern matching</h2>
<p>You can use match operator not for assign only - it&rsquo;s useful for
destructuring operations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # Lists
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    list = [1, 2]
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    [1 | tail] = list
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    tail # [2]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    [1 | _] = list # [1, 2]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    [2 | _] = list # ** (MatchError) no match of right hand side value: [1, 2]
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    # Tuples
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    { res, val } = { :ok, 1 } # res =&gt; :ok, val =&gt; 1
</span></span><span class="line"><span class="ln">10</span><span class="cl">    { :ok, val } = { :ok, 1 } # val =&gt; 1
</span></span><span class="line"><span class="ln">11</span><span class="cl">    { :ok, val } = { :fail, 1 } # ** (MatchError) no match of right hand side value: {:fail, 1}
</span></span><span class="line"><span class="ln">12</span><span class="cl">    { :ok, val } = { :fail } # ** (MatchError) no match of right hand side value: {:fail}
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    # Maps
</span></span><span class="line"><span class="ln">15</span><span class="cl">    %{ foo: res } = %{ foo: &#34;bar&#34; } # res =&gt; &#34;foo&#34;
</span></span><span class="line"><span class="ln">16</span><span class="cl">    %{ bar: res } = %{ foo: &#34;bar&#34; } # ** (MatchError) no match of right hand side value: %{foo: &#34;bar&#34;}</span></span></code></pre></div><p>You can also use pattern matching with functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule HelloWorld do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def hello(:world), do: &#34;Hello, world!&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    def hello(name), do: &#34;Hello, #{ name }!&#34;
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def hello, do: &#34;Hello!&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl">  HelloWorld.hello :world # &#34;Hello, world!&#34;
</span></span><span class="line"><span class="ln">8</span><span class="cl">  HelloWorld.hello &#34;Elixir&#34; # &#34;Hello, Elixir!&#34;
</span></span><span class="line"><span class="ln">9</span><span class="cl">  HelloWorld.hello # &#34;Hello!&#34;</span></span></code></pre></div><h2 id="pin-operator">Pin operator</h2>
<p>You can rebound Elixir&rsquo;s variables:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  x = 2
</span></span><span class="line"><span class="ln">3</span><span class="cl">  x # 2</span></span></code></pre></div><p>If you want to provide existing variable&rsquo;s value in pattern matching,
then you should use <em>pin operator</em>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  ^x = 2 # MatchError because 1 != 2
</span></span><span class="line"><span class="ln">3</span><span class="cl">  [^x, y] = [1, 2] # [1, 2]
</span></span><span class="line"><span class="ln">4</span><span class="cl">  y # 2
</span></span><span class="line"><span class="ln">5</span><span class="cl">  [2, ^y] = [2, 1] # ** (MatchError) no match of right hand side value: [2, 1]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  [_, ^y] = [3, 2] # [3, 2]</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Elixir comes with match and pin operators that provide support of
pattern matching. It allows you to write simple and elegant code to
operate basic values, complex data structures or even functions.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Pattern matching in Elixir</title>
      <link>https://neiro.io/posts/2016-05-31-pattern-matching-in-elixir.md/</link>
      <pubDate>Tue, 31 May 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2016-05-31-pattern-matching-in-elixir.md/</guid>
      <description>&lt;p&gt;Pattern matching is a key feature of functional programming. It allows&#xA;you to check a given sequence of tokens for the presence of the&#xA;constituents of some pattern. Using pattern matching you can easily&#xA;operate with complex data structures in most expressive and eloquent&#xA;way. Elixir provides pattern matching like any other functional&#xA;programming language.&lt;/p&gt;&#xA;&lt;h2 id=&#34;match-operator&#34;&gt;Match operator&lt;/h2&gt;&#xA;&lt;p&gt;Most of programming languages have assign operator: &lt;code&gt;var x = 10&lt;/code&gt; . In&#xA;Elixir equals sign is actually &lt;em&gt;match operator&lt;/em&gt;. Using this operator we&#xA;can assign and match values:&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.</p>
<h2 id="match-operator">Match operator</h2>
<p>Most of programming languages have assign operator: <code>var x = 10</code> . In
Elixir equals sign is actually <em>match operator</em>. Using this operator we
can assign and match values:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  1 = x
</span></span><span class="line"><span class="ln">3</span><span class="cl">  x # 1</span></span></code></pre></div><p>But if we will provide invalid pattern?</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  2 = x # ** (MatchError) no match of right hand side value: 1</span></span></code></pre></div><p>As you see, Elixir raises <code>MatchError</code> because left and right sides of
match operator are different - they don&rsquo;t match. You can assign variable
only on the left side of match operator:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  true = undefined # * (CompileError) undefined function undefined/0</span></span></code></pre></div><h2 id="pattern-matching">Pattern matching</h2>
<p>You can use match operator not for assign only - it&rsquo;s useful for
destructuring operations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # Lists
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    list = [1, 2]
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    [1 | tail] = list
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    tail # [2]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    [1 | _] = list # [1, 2]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    [2 | _] = list # ** (MatchError) no match of right hand side value: [1, 2]
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    # Tuples
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    { res, val } = { :ok, 1 } # res =&gt; :ok, val =&gt; 1
</span></span><span class="line"><span class="ln">10</span><span class="cl">    { :ok, val } = { :ok, 1 } # val =&gt; 1
</span></span><span class="line"><span class="ln">11</span><span class="cl">    { :ok, val } = { :fail, 1 } # ** (MatchError) no match of right hand side value: {:fail, 1}
</span></span><span class="line"><span class="ln">12</span><span class="cl">    { :ok, val } = { :fail } # ** (MatchError) no match of right hand side value: {:fail}
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    # Maps
</span></span><span class="line"><span class="ln">15</span><span class="cl">    %{ foo: res } = %{ foo: &#34;bar&#34; } # res =&gt; &#34;foo&#34;
</span></span><span class="line"><span class="ln">16</span><span class="cl">    %{ bar: res } = %{ foo: &#34;bar&#34; } # ** (MatchError) no match of right hand side value: %{foo: &#34;bar&#34;}</span></span></code></pre></div><p>You can also use pattern matching with functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule HelloWorld do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def hello(:world), do: &#34;Hello, world!&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    def hello(name), do: &#34;Hello, #{ name }!&#34;
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def hello, do: &#34;Hello!&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl">  HelloWorld.hello :world # &#34;Hello, world!&#34;
</span></span><span class="line"><span class="ln">8</span><span class="cl">  HelloWorld.hello &#34;Elixir&#34; # &#34;Hello, Elixir!&#34;
</span></span><span class="line"><span class="ln">9</span><span class="cl">  HelloWorld.hello # &#34;Hello!&#34;</span></span></code></pre></div><h2 id="pin-operator">Pin operator</h2>
<p>You can rebound Elixir&rsquo;s variables:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  x = 2
</span></span><span class="line"><span class="ln">3</span><span class="cl">  x # 2</span></span></code></pre></div><p>If you want to provide existing variable&rsquo;s value in pattern matching,
then you should use <em>pin operator</em>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  ^x = 2 # MatchError because 1 != 2
</span></span><span class="line"><span class="ln">3</span><span class="cl">  [^x, y] = [1, 2] # [1, 2]
</span></span><span class="line"><span class="ln">4</span><span class="cl">  y # 2
</span></span><span class="line"><span class="ln">5</span><span class="cl">  [2, ^y] = [2, 1] # ** (MatchError) no match of right hand side value: [2, 1]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  [_, ^y] = [3, 2] # [3, 2]</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Elixir comes with match and pin operators that provide support of
pattern matching. It allows you to write simple and elegant code to
operate basic values, complex data structures or even functions.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Introduction to Elixir</title>
      <link>https://neiro.io/blog/2016-04-24-introduction-to-elixir.md/</link>
      <pubDate>Sun, 24 Apr 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2016-04-24-introduction-to-elixir.md/</guid>
      <description>&lt;p&gt;If you want to use all features of functional programming with Ruby-like&#xA;syntax to write modern fast, fault-tolerant applications, you may take a&#xA;look at Elixir programming language.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-elixir&#34;&gt;What is Elixir?&lt;/h2&gt;&#xA;&lt;p&gt;Elixir is dynamic, functional, concurrent, fast programming language&#xA;that runs on top of the same virtual machine as his ancestor - Erlang -&#xA;&lt;em&gt;(BEAM)&lt;/em&gt;. Elixir was created by &lt;em&gt;JosÃ© Valim&lt;/em&gt; and was inspired by Ruby&#xA;syntax, but also was influenced by Clojure.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>If you want to use all features of functional programming with Ruby-like
syntax to write modern fast, fault-tolerant applications, you may take a
look at Elixir programming language.</p>
<h2 id="what-is-elixir">What is Elixir?</h2>
<p>Elixir is dynamic, functional, concurrent, fast programming language
that runs on top of the same virtual machine as his ancestor - Erlang -
<em>(BEAM)</em>. Elixir was created by <em>JosÃ© Valim</em> and was inspired by Ruby
syntax, but also was influenced by Clojure.</p>
<h2 id="key-principles">Key principles</h2>
<p>Elixir platform itself presents you next availabilities:</p>
<ul>
<li>Scalability - Elixir code can runs in thousands and millions
lightweight threads that are isolated, but can exchange information
via messages.</li>
<li>Fault-tolerance - Elixir provides supervisors that can restart parts
of your applications on errors</li>
<li>Functional programming - Elixir code is short, elegant and powerful at
the same time. You can use pattern matching, immutable constructions,
first class functions like in any other functional programming
languages.</li>
<li>Extensibility, DSL - Elixir supports modules, metaprogramming that
lets you easily extend language or another modules.</li>
<li>Erlang compatibility - You can use all of Erlang ecosystem tools and
modules in Elixir.</li>
<li>Tooling - Elixir comes with <em>mix</em> build tool, <em>Hex</em> package manager,
<em>IEx</em> interactive shell, <em>ExUnit</em> testing tool.</li>
</ul>
<h2 id="features">Features</h2>
<ul>
<li>UTF-8 support by default.</li>
<li>Modules and namespaces.</li>
<li>Docstrings documentation support.</li>
<li>Everything is an expression.</li>
<li>Pattern matching.</li>
<li>Immutability.</li>
<li>Compiling to Erlang virtual machine bytecode.</li>
<li>Polymorphism via protocols.</li>
<li>Lazy and async collections with streams.</li>
<li>Recursion, high-order functions without side-effects.</li>
<li>Tail call optimizations.</li>
<li>Metaprogramming, macroses.</li>
<li>Simple and lightweight concurrency using Erlang&rsquo;s mechanisms.</li>
</ul>
<h2 id="code-examples">Code examples</h2>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    IO.puts &#34;Hello Elixir!&#34; # Hello Elixir!
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    # Integers
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    255; 0xFF # 255
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    0b0110 # 6
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    # Floats
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    100.0 # 100.0
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    1.0e-10 # 1.0e-10
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    # Booleans
</span></span><span class="line"><span class="ln">12</span><span class="cl">    true == false; false
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    # Atoms - string constants whose name is their value
</span></span><span class="line"><span class="ln">15</span><span class="cl">    :foo == :bar # false
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    # Strings are binaries in Elixir and Erlang:
</span></span><span class="line"><span class="ln">18</span><span class="cl">    &#34;Hello&#34; # Hello
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    # Lists
</span></span><span class="line"><span class="ln">21</span><span class="cl">    [3.14, :pie, &#34;Apple&#34;]
</span></span><span class="line"><span class="ln">22</span><span class="cl">    [1] ++ [2] # [1, 2]
</span></span><span class="line"><span class="ln">23</span><span class="cl">    [1, 2] -- [1] # [2]
</span></span><span class="line"><span class="ln">24</span><span class="cl">    [head | tail] = [1, 2] # head: 1, tail: [2]
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">    # Tuples
</span></span><span class="line"><span class="ln">27</span><span class="cl">    { 3.14, :pie, &#34;Apple&#34; }
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    # Keywords lists
</span></span><span class="line"><span class="ln">30</span><span class="cl">    [foo: &#34;bar&#34;] # foo: &#34;bar&#34;
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">    # Maps
</span></span><span class="line"><span class="ln">33</span><span class="cl">    map = %{:foo =&gt; &#34;bar&#34;}
</span></span><span class="line"><span class="ln">34</span><span class="cl">    map[:foo] # &#34;bar&#34;
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">    # Comprehensions
</span></span><span class="line"><span class="ln">37</span><span class="cl">    for x &lt;- [1,2,3], do: x * 2 # [2, 4, 6]
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">    # Pattern matching
</span></span><span class="line"><span class="ln">40</span><span class="cl">    [1, a] = [1, 2]
</span></span><span class="line"><span class="ln">41</span><span class="cl">    a # 2
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">    # Modules
</span></span><span class="line"><span class="ln">44</span><span class="cl">    defmodule Foo do
</span></span><span class="line"><span class="ln">45</span><span class="cl">      def bar, do: &#34;bar&#34;
</span></span><span class="line"><span class="ln">46</span><span class="cl">    end
</span></span><span class="line"><span class="ln">47</span><span class="cl">    Foo.bar # &#34;bar&#34;
</span></span><span class="line"><span class="ln">48</span><span class="cl">
</span></span><span class="line"><span class="ln">49</span><span class="cl">    # Pipe operator
</span></span><span class="line"><span class="ln">50</span><span class="cl">    &#34;Hello world&#34; |&gt; String.split |&gt; Enum.map(&amp;String.first/1) |&gt; Enum.join # Hw
</span></span><span class="line"><span class="ln">51</span><span class="cl">
</span></span><span class="line"><span class="ln">52</span><span class="cl">    # Sigils
</span></span><span class="line"><span class="ln">53</span><span class="cl">    ~r/abcd/ # Regexp
</span></span><span class="line"><span class="ln">54</span><span class="cl">    ~s/hello world/ # String
</span></span><span class="line"><span class="ln">55</span><span class="cl">    ~w/hello world/ # List of words: [&#34;hello&#34;, &#34;world&#34;]</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>If you want to use functional programming language for web-development,
fault-tolerant , distributed applications, that you may like an Elixir.
It comes with familiar Ruby syntax, but with all of power and eloquence
of functional programming languages. Elixir built on top of Erlang
platform and you can easily use all of Erlang ecosystem tools and
modules in your projects with modern syntax.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Introduction to Elixir</title>
      <link>https://neiro.io/posts/2016-04-24-introduction-to-elixir.md/</link>
      <pubDate>Sun, 24 Apr 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2016-04-24-introduction-to-elixir.md/</guid>
      <description>&lt;p&gt;If you want to use all features of functional programming with Ruby-like&#xA;syntax to write modern fast, fault-tolerant applications, you may take a&#xA;look at Elixir programming language.&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-elixir&#34;&gt;What is Elixir?&lt;/h2&gt;&#xA;&lt;p&gt;Elixir is dynamic, functional, concurrent, fast programming language&#xA;that runs on top of the same virtual machine as his ancestor - Erlang -&#xA;&lt;em&gt;(BEAM)&lt;/em&gt;. Elixir was created by &lt;em&gt;JosÃ© Valim&lt;/em&gt; and was inspired by Ruby&#xA;syntax, but also was influenced by Clojure.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>If you want to use all features of functional programming with Ruby-like
syntax to write modern fast, fault-tolerant applications, you may take a
look at Elixir programming language.</p>
<h2 id="what-is-elixir">What is Elixir?</h2>
<p>Elixir is dynamic, functional, concurrent, fast programming language
that runs on top of the same virtual machine as his ancestor - Erlang -
<em>(BEAM)</em>. Elixir was created by <em>JosÃ© Valim</em> and was inspired by Ruby
syntax, but also was influenced by Clojure.</p>
<h2 id="key-principles">Key principles</h2>
<p>Elixir platform itself presents you next availabilities:</p>
<ul>
<li>Scalability - Elixir code can runs in thousands and millions
lightweight threads that are isolated, but can exchange information
via messages.</li>
<li>Fault-tolerance - Elixir provides supervisors that can restart parts
of your applications on errors</li>
<li>Functional programming - Elixir code is short, elegant and powerful at
the same time. You can use pattern matching, immutable constructions,
first class functions like in any other functional programming
languages.</li>
<li>Extensibility, DSL - Elixir supports modules, metaprogramming that
lets you easily extend language or another modules.</li>
<li>Erlang compatibility - You can use all of Erlang ecosystem tools and
modules in Elixir.</li>
<li>Tooling - Elixir comes with <em>mix</em> build tool, <em>Hex</em> package manager,
<em>IEx</em> interactive shell, <em>ExUnit</em> testing tool.</li>
</ul>
<h2 id="features">Features</h2>
<ul>
<li>UTF-8 support by default.</li>
<li>Modules and namespaces.</li>
<li>Docstrings documentation support.</li>
<li>Everything is an expression.</li>
<li>Pattern matching.</li>
<li>Immutability.</li>
<li>Compiling to Erlang virtual machine bytecode.</li>
<li>Polymorphism via protocols.</li>
<li>Lazy and async collections with streams.</li>
<li>Recursion, high-order functions without side-effects.</li>
<li>Tail call optimizations.</li>
<li>Metaprogramming, macroses.</li>
<li>Simple and lightweight concurrency using Erlang&rsquo;s mechanisms.</li>
</ul>
<h2 id="code-examples">Code examples</h2>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    IO.puts &#34;Hello Elixir!&#34; # Hello Elixir!
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    # Integers
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    255; 0xFF # 255
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    0b0110 # 6
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    # Floats
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    100.0 # 100.0
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    1.0e-10 # 1.0e-10
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    # Booleans
</span></span><span class="line"><span class="ln">12</span><span class="cl">    true == false; false
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    # Atoms - string constants whose name is their value
</span></span><span class="line"><span class="ln">15</span><span class="cl">    :foo == :bar # false
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    # Strings are binaries in Elixir and Erlang:
</span></span><span class="line"><span class="ln">18</span><span class="cl">    &#34;Hello&#34; # Hello
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">    # Lists
</span></span><span class="line"><span class="ln">21</span><span class="cl">    [3.14, :pie, &#34;Apple&#34;]
</span></span><span class="line"><span class="ln">22</span><span class="cl">    [1] ++ [2] # [1, 2]
</span></span><span class="line"><span class="ln">23</span><span class="cl">    [1, 2] -- [1] # [2]
</span></span><span class="line"><span class="ln">24</span><span class="cl">    [head | tail] = [1, 2] # head: 1, tail: [2]
</span></span><span class="line"><span class="ln">25</span><span class="cl">
</span></span><span class="line"><span class="ln">26</span><span class="cl">    # Tuples
</span></span><span class="line"><span class="ln">27</span><span class="cl">    { 3.14, :pie, &#34;Apple&#34; }
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    # Keywords lists
</span></span><span class="line"><span class="ln">30</span><span class="cl">    [foo: &#34;bar&#34;] # foo: &#34;bar&#34;
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">    # Maps
</span></span><span class="line"><span class="ln">33</span><span class="cl">    map = %{:foo =&gt; &#34;bar&#34;}
</span></span><span class="line"><span class="ln">34</span><span class="cl">    map[:foo] # &#34;bar&#34;
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">    # Comprehensions
</span></span><span class="line"><span class="ln">37</span><span class="cl">    for x &lt;- [1,2,3], do: x * 2 # [2, 4, 6]
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">    # Pattern matching
</span></span><span class="line"><span class="ln">40</span><span class="cl">    [1, a] = [1, 2]
</span></span><span class="line"><span class="ln">41</span><span class="cl">    a # 2
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">    # Modules
</span></span><span class="line"><span class="ln">44</span><span class="cl">    defmodule Foo do
</span></span><span class="line"><span class="ln">45</span><span class="cl">      def bar, do: &#34;bar&#34;
</span></span><span class="line"><span class="ln">46</span><span class="cl">    end
</span></span><span class="line"><span class="ln">47</span><span class="cl">    Foo.bar # &#34;bar&#34;
</span></span><span class="line"><span class="ln">48</span><span class="cl">
</span></span><span class="line"><span class="ln">49</span><span class="cl">    # Pipe operator
</span></span><span class="line"><span class="ln">50</span><span class="cl">    &#34;Hello world&#34; |&gt; String.split |&gt; Enum.map(&amp;String.first/1) |&gt; Enum.join # Hw
</span></span><span class="line"><span class="ln">51</span><span class="cl">
</span></span><span class="line"><span class="ln">52</span><span class="cl">    # Sigils
</span></span><span class="line"><span class="ln">53</span><span class="cl">    ~r/abcd/ # Regexp
</span></span><span class="line"><span class="ln">54</span><span class="cl">    ~s/hello world/ # String
</span></span><span class="line"><span class="ln">55</span><span class="cl">    ~w/hello world/ # List of words: [&#34;hello&#34;, &#34;world&#34;]</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>If you want to use functional programming language for web-development,
fault-tolerant , distributed applications, that you may like an Elixir.
It comes with familiar Ruby syntax, but with all of power and eloquence
of functional programming languages. Elixir built on top of Erlang
platform and you can easily use all of Erlang ecosystem tools and
modules in your projects with modern syntax.</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
