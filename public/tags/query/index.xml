<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Query on neiro blog</title>
    <link>https://neiro.io/tags/query/</link>
    <description>Recent content in Query on neiro blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <copyright>neiro Â© 2012-2025</copyright>
    <lastBuildDate>Sun, 21 Jan 2018 10:00:00 +0100</lastBuildDate>
    <atom:link href="https://neiro.io/tags/query/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Postgres full-text search using Ecto</title>
      <link>https://neiro.io/blog/2018-01-21-postgres-full-text-search-using-ecto.md/</link>
      <pubDate>Sun, 21 Jan 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/blog/2018-01-21-postgres-full-text-search-using-ecto.md/</guid>
      <description>&lt;p&gt;PostgreSQL is one of the most popular, stable and common relational&#xA;database. It&amp;rsquo;s widely used in Elixir infrastructure and has a great&#xA;integration with Ecto library.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re into web development you can often face the search problem.&#xA;You have a large stable database, you have tons of useful information,&#xA;great tools, but your users desire to find something by arbitrary&#xA;questions. You can&amp;rsquo;t use your favourite plain SELECT &amp;hellip; WHERE &amp;hellip;&#xA;queries because you need to search for the words, not columns or&#xA;records.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Postgres full-text search using Ecto</title>
      <link>https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/</link>
      <pubDate>Sun, 21 Jan 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/</guid>
      <description>&lt;p&gt;PostgreSQL is one of the most popular, stable and common relational&#xA;database. It&amp;rsquo;s widely used in Elixir infrastructure and has a great&#xA;integration with Ecto library.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re into web development you can often face the search problem.&#xA;You have a large stable database, you have tons of useful information,&#xA;great tools, but your users desire to find something by arbitrary&#xA;questions. You can&amp;rsquo;t use your favourite plain SELECT &amp;hellip; WHERE &amp;hellip;&#xA;queries because you need to search for the words, not columns or&#xA;records.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Building dynamic queries with Ecto</title>
      <link>https://neiro.io/blog/2017-09-16-building-dynamic-queries-with-ecto.md/</link>
      <pubDate>Sat, 16 Sep 2017 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2017-09-16-building-dynamic-queries-with-ecto.md/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/elixir-ecto/ecto&#34;&gt;Ecto&lt;/a&gt; is the most popular,&#xA;robust and solid solution to work with databases in &lt;strong&gt;Elixir&lt;/strong&gt; ecosystem.&#xA;Ecto is not ORM, ODM nor it is a &lt;em&gt;Repository patern&lt;/em&gt; library. &lt;em&gt;Ecto&lt;/em&gt; is&#xA;just a wrapper for common constructions to work with databases, nothing&#xA;less and nothing more than that.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ecto.Query&lt;/strong&gt; is the core module for operations with database queries. It&#xA;allows us to build easily any queries with predefined conditions that we&#xA;wanted.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/elixir-ecto/ecto">Ecto</a> is the most popular,
robust and solid solution to work with databases in <strong>Elixir</strong> ecosystem.
Ecto is not ORM, ODM nor it is a <em>Repository patern</em> library. <em>Ecto</em> is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.</p>
<p><strong>Ecto.Query</strong> is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted.</p>
<p>But what if we want to build a <em>really</em> dynamic query? A common case can
be filtering by list of attributes.</p>
<p>Imagine a situation when you have a large set of users in your database.
Your customers want to filter or exclude users by any attributes that
can be allowed: <code>name, nickname, gender</code> etc. Writing code for all of
model attributes can be tedious and annoying.</p>
<p>So what can we do about it?</p>
<h2 id="filter-query">Filter Query</h2>
<p>Let&rsquo;s create a new Elixir module that will implement logic of our future
dynamic query. I will name it <code>FilterQuery</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln">4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>This module should have just one public function called <code>filter</code> that
accepts incoming query, inclusion and exclusion parameters as the
arguments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def filter(query, inclusion, exclusion)</span></span></code></pre></div><p>Now let&rsquo;s implement the core of our future filter function. Assume that
we need to build two lists of dynamic queries both for inclusion and
exclusion parameters:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)</span></span></code></pre></div><p>Now we need to merge all these dynamic queries into a new big one. It
can be implemented using <code>Enum.reduce</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)</span></span></code></pre></div><p>Now our <code>filter</code> function returns a new complex query that can be easily
composed with another queries using <code>Ecto.Query</code> functions or macroses.</p>
<h2 id="dynamic-filter-query">Dynamic filter query</h2>
<p>We have just created a basic prototype for our future dynamic filter
query. However, the devil&rsquo;s always in the details. We need to hide
implementation in private functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">3</span><span class="cl">      do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">4</span><span class="cl">  end
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">  defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">    for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>We suppose that inclusion and exclusion filters are keyword lists with
keys as model attributes and lists as the filter values. Therefore, we
need to check if these lists contain values or we shall skip building
query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">2</span><span class="cl">  defp present?(_), do: false</span></span></code></pre></div><p>Now we need to go straight to the implementation. <code>dynamic_query/3</code>
should finally return for us the result.</p>
<p>We will use <code>dynamic</code> macro from Ecto.Query that takes any query as
first argument and builds dynamic query for the second one. Also notice
that we need to use <code>field</code> macro to dynamically access attribute name:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">6</span><span class="cl">    dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><h2 id="restriction-of-filter-keys">Restriction of filter keys</h2>
<p>So, looks like our filter query is fully functional and dynamic! But
this is not enough when you are building a complex logic that
desperately needs to leave some attributes <strong>unfiltered</strong>.</p>
<p>For example, imagine the case when your <code>User</code> model has a
<code>relationships_status</code> attribute. If you&rsquo;re allowing your API customers
to filter any attributes they are likely to find out lonely users by
using this loophole. Therefore your customers will be dating, engaging,
tying the knots and finally will be lost for your application. Is this
what you really wished? Guess not :)</p>
<p>So let&rsquo;s restrict filtered attributes by using <code>__using__</code> macro:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  ...
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    end
</span></span><span class="line"><span class="ln">10</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">13</span><span class="cl">      do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">     defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">17</span><span class="cl">  end</span></span></code></pre></div><p>Voila! No one ever will find out how your users relationships are going.</p>
<p>Now let&rsquo;s take a quick look at our dynamic filter query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      quote do
</span></span><span class="line"><span class="ln">10</span><span class="cl">        import FilterQuery
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">13</span><span class="cl">        def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln">14</span><span class="cl">          [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">          queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln">17</span><span class="cl">          Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        end
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">        def filter(query, _) do
</span></span><span class="line"><span class="ln">21</span><span class="cl">          query
</span></span><span class="line"><span class="ln">22</span><span class="cl">        end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">25</span><span class="cl">          for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">26</span><span class="cl">            do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">27</span><span class="cl">        end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">          for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">31</span><span class="cl">        end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">34</span><span class="cl">          dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">35</span><span class="cl">        end
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">        defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">          dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">39</span><span class="cl">        end
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl">        defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">42</span><span class="cl">          do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">43</span><span class="cl">
</span></span><span class="line"><span class="ln">44</span><span class="cl">        defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">45</span><span class="cl">
</span></span><span class="line"><span class="ln">46</span><span class="cl">        defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">47</span><span class="cl">        defp present?(_), do: false
</span></span><span class="line"><span class="ln">48</span><span class="cl">      end
</span></span><span class="line"><span class="ln">49</span><span class="cl">    end
</span></span><span class="line"><span class="ln">50</span><span class="cl">  end</span></span></code></pre></div><h2 id="usage">Usage</h2>
<p>It&rsquo;s a piece of cake to use our query in another modules. Just include
our query and set the list of allowed attributes through <code>use</code>
construction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  {:ok, _} = Application.ensure_all_started(:ex_machina)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Example of using dynamic ecto queries
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    import Factory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    use FilterQuery, attributes: ~w(proficiency name)a
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def run do
</span></span><span class="line"><span class="ln">12</span><span class="cl">      insert_users()
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      IO.inspect(count([])) # 3
</span></span><span class="line"><span class="ln">15</span><span class="cl">      [relationships_status: [&#34;married&#34;]] |&gt; count([]) |&gt; IO.inspect # 3
</span></span><span class="line"><span class="ln">16</span><span class="cl">      [proficiency: [&#34;developer&#34;]] |&gt; count([]) |&gt; IO.inspect # 1
</span></span><span class="line"><span class="ln">17</span><span class="cl">      [proficiency: [&#34;soldier&#34;]] |&gt; count([]) |&gt; IO.inspect # 0
</span></span><span class="line"><span class="ln">18</span><span class="cl">      IO.inspect(count([], %{proficiency: [&#34;politic&#34;]})) # 2
</span></span><span class="line"><span class="ln">19</span><span class="cl">    end
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    defp insert_users do
</span></span><span class="line"><span class="ln">22</span><span class="cl">      Repo.delete_all(User)
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      insert(:user, relationships_status: &#34;single&#34;, proficiency: &#34;developer&#34;)
</span></span><span class="line"><span class="ln">25</span><span class="cl">      insert(:user, relationships_status: &#34;married&#34;, proficiency: &#34;politic&#34;)
</span></span><span class="line"><span class="ln">26</span><span class="cl">      insert(:user, relationships_status: &#34;dating&#34;, proficiency: &#34;thief&#34;)
</span></span><span class="line"><span class="ln">27</span><span class="cl">    end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    defp count(inclusion, exclusion \\ []) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">      User
</span></span><span class="line"><span class="ln">31</span><span class="cl">      |&gt; filter(inclusion, exclusion)
</span></span><span class="line"><span class="ln">32</span><span class="cl">      |&gt; Repo.aggregate(:count, :id)
</span></span><span class="line"><span class="ln">33</span><span class="cl">    end
</span></span><span class="line"><span class="ln">34</span><span class="cl">  end</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>However, this is not at all that we can achieve by using <code>dynamic</code> macro
in Ecto.</p>
<p>You can filter by regex, type or even your own query; sort by ascending
and descending; do aggregation or pagination; whatever comes to your
head - it all depends on your imagination and skills. Ecto provides you
a great tool to build any complex queries by writing minimal lines of
code without any duplication.</p>
<p>What&rsquo;s next? See the <a href="https://github.com/ne1ro/dynamic_ecto_query">full
example</a> for this article or read
<a href="https://hexdocs.pm/ecto/Ecto.Query.html">Ecto documentation</a> to
deepen your knowledge a little bit more.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Building dynamic queries with Ecto</title>
      <link>https://neiro.io/posts/2017-09-16-building-dynamic-queries-with-ecto.md/</link>
      <pubDate>Sat, 16 Sep 2017 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2017-09-16-building-dynamic-queries-with-ecto.md/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://github.com/elixir-ecto/ecto&#34;&gt;Ecto&lt;/a&gt; is the most popular,&#xA;robust and solid solution to work with databases in &lt;strong&gt;Elixir&lt;/strong&gt; ecosystem.&#xA;Ecto is not ORM, ODM nor it is a &lt;em&gt;Repository patern&lt;/em&gt; library. &lt;em&gt;Ecto&lt;/em&gt; is&#xA;just a wrapper for common constructions to work with databases, nothing&#xA;less and nothing more than that.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;Ecto.Query&lt;/strong&gt; is the core module for operations with database queries. It&#xA;allows us to build easily any queries with predefined conditions that we&#xA;wanted.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/elixir-ecto/ecto">Ecto</a> is the most popular,
robust and solid solution to work with databases in <strong>Elixir</strong> ecosystem.
Ecto is not ORM, ODM nor it is a <em>Repository patern</em> library. <em>Ecto</em> is
just a wrapper for common constructions to work with databases, nothing
less and nothing more than that.</p>
<p><strong>Ecto.Query</strong> is the core module for operations with database queries. It
allows us to build easily any queries with predefined conditions that we
wanted.</p>
<p>But what if we want to build a <em>really</em> dynamic query? A common case can
be filtering by list of attributes.</p>
<p>Imagine a situation when you have a large set of users in your database.
Your customers want to filter or exclude users by any attributes that
can be allowed: <code>name, nickname, gender</code> etc. Writing code for all of
model attributes can be tedious and annoying.</p>
<p>So what can we do about it?</p>
<h2 id="filter-query">Filter Query</h2>
<p>Let&rsquo;s create a new Elixir module that will implement logic of our future
dynamic query. I will name it <code>FilterQuery</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln">4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>This module should have just one public function called <code>filter</code> that
accepts incoming query, inclusion and exclusion parameters as the
arguments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def filter(query, inclusion, exclusion)</span></span></code></pre></div><p>Now let&rsquo;s implement the core of our future filter function. Assume that
we need to build two lists of dynamic queries both for inclusion and
exclusion parameters:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)</span></span></code></pre></div><p>Now we need to merge all these dynamic queries into a new big one. It
can be implemented using <code>Enum.reduce</code> :</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)</span></span></code></pre></div><p>Now our <code>filter</code> function returns a new complex query that can be easily
composed with another queries using <code>Ecto.Query</code> functions or macroses.</p>
<h2 id="dynamic-filter-query">Dynamic filter query</h2>
<p>We have just created a basic prototype for our future dynamic filter
query. However, the devil&rsquo;s always in the details. We need to hide
implementation in private functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">3</span><span class="cl">      do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">4</span><span class="cl">  end
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">  defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">7</span><span class="cl">    for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">8</span><span class="cl">  end</span></span></code></pre></div><p>We suppose that inclusion and exclusion filters are keyword lists with
keys as model attributes and lists as the filter values. Therefore, we
need to check if these lists contain values or we shall skip building
query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">2</span><span class="cl">  defp present?(_), do: false</span></span></code></pre></div><p>Now we need to go straight to the implementation. <code>dynamic_query/3</code>
should finally return for us the result.</p>
<p>We will use <code>dynamic</code> macro from Ecto.Query that takes any query as
first argument and builds dynamic query for the second one. Also notice
that we need to use <code>field</code> macro to dynamically access attribute name:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">6</span><span class="cl">    dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><h2 id="restriction-of-filter-keys">Restriction of filter keys</h2>
<p>So, looks like our filter query is fully functional and dynamic! But
this is not enough when you are building a complex logic that
desperately needs to leave some attributes <strong>unfiltered</strong>.</p>
<p>For example, imagine the case when your <code>User</code> model has a
<code>relationships_status</code> attribute. If you&rsquo;re allowing your API customers
to filter any attributes they are likely to find out lonely users by
using this loophole. Therefore your customers will be dating, engaging,
tying the knots and finally will be lost for your application. Is this
what you really wished? Guess not :)</p>
<p>So let&rsquo;s restrict filtered attributes by using <code>__using__</code> macro:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  ...
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    end
</span></span><span class="line"><span class="ln">10</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">     defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">13</span><span class="cl">      do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">     defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  ...
</span></span><span class="line"><span class="ln">17</span><span class="cl">  end</span></span></code></pre></div><p>Voila! No one ever will find out how your users relationships are going.</p>
<p>Now let&rsquo;s take a quick look at our dynamic filter query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule FilterQuery do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Query that accepts inclusion or exclusion parameters and filters by this parameters
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    defmacro __using__(attributes: allowed_attributes) do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      quote do
</span></span><span class="line"><span class="ln">10</span><span class="cl">        import FilterQuery
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        @spec filter(Ecto.Query.t, map, map) :: Ecto.Query.t
</span></span><span class="line"><span class="ln">13</span><span class="cl">        def filter(query, inclusion, exclusion) do
</span></span><span class="line"><span class="ln">14</span><span class="cl">          [inclusion, exclusion] = [sanitize(inclusion), sanitize(exclusion)]
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">          queries = dynamic_query(:inclusion, inclusion) ++ dynamic_query(:exclusion, exclusion)
</span></span><span class="line"><span class="ln">17</span><span class="cl">          Enum.reduce(queries, query, fn(q, acc) -&gt; where(acc, ^q) end)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        end
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">        def filter(query, _) do
</span></span><span class="line"><span class="ln">21</span><span class="cl">          query
</span></span><span class="line"><span class="ln">22</span><span class="cl">        end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">        defp dynamic_query(type, filters) when type in [:inclusion, :exclusion] do
</span></span><span class="line"><span class="ln">25</span><span class="cl">          for {attr, values} &lt;- filters, present?(values),
</span></span><span class="line"><span class="ln">26</span><span class="cl">            do: dynamic_query(type, attr, values)
</span></span><span class="line"><span class="ln">27</span><span class="cl">        end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">        defp dynamic_query(:exclusion, exclusion) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">          for {attr, values} &lt;- exclusion, do: dynamic_query(:exclusion, attr, values)
</span></span><span class="line"><span class="ln">31</span><span class="cl">        end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">        defp dynamic_query(:inclusion, attr, values) do
</span></span><span class="line"><span class="ln">34</span><span class="cl">          dynamic([q], field(q, ^attr) in ^values)
</span></span><span class="line"><span class="ln">35</span><span class="cl">        end
</span></span><span class="line"><span class="ln">36</span><span class="cl">
</span></span><span class="line"><span class="ln">37</span><span class="cl">        defp dynamic_query(_, attr, values) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">          dynamic([q], field(q, ^attr) not in ^values)
</span></span><span class="line"><span class="ln">39</span><span class="cl">        end
</span></span><span class="line"><span class="ln">40</span><span class="cl">
</span></span><span class="line"><span class="ln">41</span><span class="cl">        defp sanitize(keyword_list),
</span></span><span class="line"><span class="ln">42</span><span class="cl">          do: for {key, val} &lt;- keyword_list, allowed_key?(key), do: {key, val}
</span></span><span class="line"><span class="ln">43</span><span class="cl">
</span></span><span class="line"><span class="ln">44</span><span class="cl">        defp allowed_key?(key), do: key in unquote(allowed_attributes)
</span></span><span class="line"><span class="ln">45</span><span class="cl">
</span></span><span class="line"><span class="ln">46</span><span class="cl">        defp present?(list) when is_list(list), do: length(list) &gt; 0
</span></span><span class="line"><span class="ln">47</span><span class="cl">        defp present?(_), do: false
</span></span><span class="line"><span class="ln">48</span><span class="cl">      end
</span></span><span class="line"><span class="ln">49</span><span class="cl">    end
</span></span><span class="line"><span class="ln">50</span><span class="cl">  end</span></span></code></pre></div><h2 id="usage">Usage</h2>
<p>It&rsquo;s a piece of cake to use our query in another modules. Just include
our query and set the list of allowed attributes through <code>use</code>
construction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  {:ok, _} = Application.ensure_all_started(:ex_machina)
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  defmodule Example do
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Example of using dynamic ecto queries
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    import Factory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    use FilterQuery, attributes: ~w(proficiency name)a
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def run do
</span></span><span class="line"><span class="ln">12</span><span class="cl">      insert_users()
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      IO.inspect(count([])) # 3
</span></span><span class="line"><span class="ln">15</span><span class="cl">      [relationships_status: [&#34;married&#34;]] |&gt; count([]) |&gt; IO.inspect # 3
</span></span><span class="line"><span class="ln">16</span><span class="cl">      [proficiency: [&#34;developer&#34;]] |&gt; count([]) |&gt; IO.inspect # 1
</span></span><span class="line"><span class="ln">17</span><span class="cl">      [proficiency: [&#34;soldier&#34;]] |&gt; count([]) |&gt; IO.inspect # 0
</span></span><span class="line"><span class="ln">18</span><span class="cl">      IO.inspect(count([], %{proficiency: [&#34;politic&#34;]})) # 2
</span></span><span class="line"><span class="ln">19</span><span class="cl">    end
</span></span><span class="line"><span class="ln">20</span><span class="cl">
</span></span><span class="line"><span class="ln">21</span><span class="cl">    defp insert_users do
</span></span><span class="line"><span class="ln">22</span><span class="cl">      Repo.delete_all(User)
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      insert(:user, relationships_status: &#34;single&#34;, proficiency: &#34;developer&#34;)
</span></span><span class="line"><span class="ln">25</span><span class="cl">      insert(:user, relationships_status: &#34;married&#34;, proficiency: &#34;politic&#34;)
</span></span><span class="line"><span class="ln">26</span><span class="cl">      insert(:user, relationships_status: &#34;dating&#34;, proficiency: &#34;thief&#34;)
</span></span><span class="line"><span class="ln">27</span><span class="cl">    end
</span></span><span class="line"><span class="ln">28</span><span class="cl">
</span></span><span class="line"><span class="ln">29</span><span class="cl">    defp count(inclusion, exclusion \\ []) do
</span></span><span class="line"><span class="ln">30</span><span class="cl">      User
</span></span><span class="line"><span class="ln">31</span><span class="cl">      |&gt; filter(inclusion, exclusion)
</span></span><span class="line"><span class="ln">32</span><span class="cl">      |&gt; Repo.aggregate(:count, :id)
</span></span><span class="line"><span class="ln">33</span><span class="cl">    end
</span></span><span class="line"><span class="ln">34</span><span class="cl">  end</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>However, this is not at all that we can achieve by using <code>dynamic</code> macro
in Ecto.</p>
<p>You can filter by regex, type or even your own query; sort by ascending
and descending; do aggregation or pagination; whatever comes to your
head - it all depends on your imagination and skills. Ecto provides you
a great tool to build any complex queries by writing minimal lines of
code without any duplication.</p>
<p>What&rsquo;s next? See the <a href="https://github.com/ne1ro/dynamic_ecto_query">full
example</a> for this article or read
<a href="https://hexdocs.pm/ecto/Ecto.Query.html">Ecto documentation</a> to
deepen your knowledge a little bit more.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Query objects in Ruby on Rails</title>
      <link>https://neiro.io/blog/2016-10-05-query-objects-in-ruby-on-rails.md/</link>
      <pubDate>Wed, 05 Oct 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2016-10-05-query-objects-in-ruby-on-rails.md/</guid>
      <description>&lt;p&gt;Database queries are common when you develop web applications. &lt;em&gt;Ruby on&#xA;Rails&lt;/em&gt; and it&amp;rsquo;s &lt;em&gt;ActiveRecord&lt;/em&gt; liberates you from writing tons of&#xA;boilerplate SQL code and results in creation of elegant, eloquent&#xA;queries in plain Ruby.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*-oIlwIWlt0BDN4b5a9rRCQ.png&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;But plenty of immense possibilities that Ruby and ActiveRecord provide,&#xA;unfortunately, remain unused. I bet that often you see a lot of enormous&#xA;scopes in Ruby on Rails models, endless chains of queries in controllers&#xA;and even bulky chunks of raw SQL.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Database queries are common when you develop web applications. <em>Ruby on
Rails</em> and it&rsquo;s <em>ActiveRecord</em> liberates you from writing tons of
boilerplate SQL code and results in creation of elegant, eloquent
queries in plain Ruby.</p>
<figure><img src="https://cdn-images-1.medium.com/max/1600/1*-oIlwIWlt0BDN4b5a9rRCQ.png">
</figure>

<p>But plenty of immense possibilities that Ruby and ActiveRecord provide,
unfortunately, remain unused. I bet that often you see a lot of enormous
scopes in Ruby on Rails models, endless chains of queries in controllers
and even bulky chunks of raw SQL.</p>
<p>#+begin_src ruby
@articles = Article.includes(:user)
.order(&ldquo;created_at DESC&rdquo;)
.where(&ldquo;text IS NOT NULL&rdquo;)
.page(page)</p>
<p>@articles = Articles.connection
.select_all(%Q{SELECT articles.* FROM
articles WHERE (text IS NOT NULL) ORDER BY created_at DESC LIMIT 5
OFFSET 0})
#+end_src <em>Bad cases of using ActiveRecord queries</em></p>
<p>These poor practices may create obstacles and become a reason of
developer&rsquo;s headaches in the real-world web applications.</p>
<h2 id="typical-db-queries-application-problems">Typical DB queries application problems:</h2>
<ul>
<li>Big pieces of queries code in controllers/models/services mess up your
code</li>
<li>It is hard to understand complex database requests</li>
<li>Inserts of raw SQL are non-consistent and often mix with ActiveRecord
queries</li>
<li>Testing one separate query in isolation is very problematic</li>
<li>It is difficult to compose, extend or inherit queries</li>
<li>Often Single Responsibility Principle gets violated</li>
</ul>
<h2 id="solution">Solution:</h2>
<p>These problems can be solved by using <em>Query Object</em> pattern &mdash; a
common technique that isolates your complex queries.</p>
<p><em>Query Object</em> in ideal case is a separate class that contains one
specific query that implements just one business logic rule.</p>
<h2 id="implementation">Implementation:</h2>
<p>For most of the cases <em>Query Object</em> is PORO that accepts relation in
constructor and defines queries named like an <em>ActiveRecord</em> common
methods:</p>
<p>#+begin_src ruby</p>
<p>class Article &lt; ActiveRecord::Base
scope :by_title, -&gt;(direction) { order title: direction }
scope :by_date, -&gt;(direction) { order created_at: direction }
scope :by_author, -&gt;(direction) { order &ldquo;users.full_name #{direction}&rdquo; }</p>
<p>SORT_OPTIONS = %w(by_date by_title by_author).freeze</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def initialize(params = {}, relation = Article.includes(:user))
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @relation = relation
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @params = params
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  def all
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    @relation.public_send(sort_by, direction)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">  private
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">  def sort_by
</span></span><span class="line"><span class="ln">13</span><span class="cl">    @params[:sort].presence_in(SORT_OPTIONS) || :by_date
</span></span><span class="line"><span class="ln">14</span><span class="cl">  end
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  def direction
</span></span><span class="line"><span class="ln">17</span><span class="cl">    @params[:direction] == &#34;asc&#34; ? :asc : :desc
</span></span><span class="line"><span class="ln">18</span><span class="cl">  end</span></span></code></pre></div><p>end</p>
<p>index @articles = OrderedArticlesQuery.new(sort_query_params).all.page(params[:page])
end</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  private
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  def sort_query_params
</span></span><span class="line"><span class="ln">4</span><span class="cl">    params.slice(:sort_by, :direction)
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end</span></span></code></pre></div><p>end
#+end_src <em>Query Object implementation and usage in
controller</em></p>
<h3 id="heredoc-syntax-for-raw-sql">HEREDOC syntax for raw SQL:</h3>
<p>For the cases where you desperately need to use raw SQL code try to
isolate it using Ruby&rsquo;s <em>HEREDOC syntax:</em></p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"> <span class="k">class</span> <span class="nc">PopularArticlesQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="no">POPULAR_TRESHOLD</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">subscriptions</span> <span class="o">=</span> <span class="no">Subscription</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="vi">@subscriptions</span> <span class="o">=</span> <span class="n">subscriptions</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="vi">@subscriptions</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="kp">private</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="k">def</span> <span class="nf">query</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="s">&lt;&lt;-SQL
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="s"></span>      <span class="n">articles</span><span class="o">.</span><span class="n">comments_count</span> <span class="o">&gt;=</span> <span class="c1">#{POPULAR_TRESHOLD}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">      <span class="no">AND</span> <span class="n">articles</span><span class="o">.</span><span class="n">content</span> <span class="no">IS</span> <span class="no">NOT</span> <span class="no">NULL</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">      <span class="no">AND</span> <span class="n">articles</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="c1">#{Article::STATUSES[:published]}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">      <span class="no">ORDER</span> <span class="no">BY</span> <span class="n">articles</span><span class="o">.</span><span class="n">comments_count</span> <span class="no">DESC</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="no">SQL</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>HEREDOC syntax example for raw SQL inserts</em></p>
<h3 id="extending-scope">Extending scope:</h3>
<p>If your scope relates to existing <em>QueryObject</em>, you can easily extend
its relation instead of cluttering up your models.
<a href="http://apidock.com/rails/ActiveRecord/QueryMethods/extending">ActiveRecord::QueryMethods.extending</a>
method will help you:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">OrderedArticlesQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="no">SORT_OPTIONS</span> <span class="o">=</span> <span class="sx">%w(by_date by_title by_author)</span><span class="o">.</span><span class="n">freeze</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">params</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">relation</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="ss">:user</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="vi">@relation</span> <span class="o">=</span> <span class="n">relation</span><span class="o">.</span><span class="n">extending</span><span class="p">(</span><span class="no">Scopes</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="vi">@params</span> <span class="o">=</span> <span class="n">params</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="vi">@relation</span><span class="o">.</span><span class="n">public_send</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="kp">private</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="k">def</span> <span class="nf">sort_by</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="vi">@params</span><span class="o">[</span><span class="ss">:sort</span><span class="o">].</span><span class="n">presence_in</span><span class="p">(</span><span class="no">SORT_OPTIONS</span><span class="p">)</span> <span class="o">||</span> <span class="ss">:by_date</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="k">def</span> <span class="nf">direction</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="vi">@params</span><span class="o">[</span><span class="ss">:direction</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&#34;asc&#34;</span> <span class="p">?</span> <span class="ss">:asc</span> <span class="p">:</span> <span class="ss">:desc</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="c1"># Group additional scope methods in module in order to extend relation</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="k">module</span> <span class="nn">Scopes</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">def</span> <span class="nf">by_title</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">      <span class="n">order</span><span class="p">(</span><span class="ss">title</span><span class="p">:</span> <span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="k">def</span> <span class="nf">by_date</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">      <span class="n">order</span><span class="p">(</span><span class="ss">created_at</span><span class="p">:</span> <span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="k">def</span> <span class="nf">by_author</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">      <span class="n">order</span><span class="p">(</span><span class="s2">&#34;users.full_name </span><span class="si">#{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Extending scope for Query Objects relations</em></p>
<h2 id="composing-query-objects">Composing Query Objects:</h2>
<p><em>Query Objects</em> should be devised to support composition with other
<em>Query Objects</em> and other ActiveRecord relations. In the example below
two composed Query Objects represent one SQL query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">FeaturedQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">relation</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="vi">@relation</span> <span class="o">=</span> <span class="n">relation</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="vi">@relation</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">featured</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&#34;views_count &gt; ?&#34;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">class</span> <span class="nc">ArticlesController</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">def</span> <span class="nf">index</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="vi">@articles</span> <span class="o">=</span> <span class="no">FeaturedArticlesQuery</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">sorted_articles</span><span class="p">)</span><span class="o">.</span><span class="n">all</span> <span class="c1"># SELECT &#34;articles&#34;.* FROM &#34;articles&#34; WHERE &#34;articles&#34;.&#34;featured&#34; = $1 # AND (views_count &gt;100) ORDER BY &#34;articles&#34;.&#34;created_at&#34; DESC LIMIT 10 OFFSET 0</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="kp">private</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">def</span> <span class="nf">sorted_articles</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="no">SortedArticlesQuery</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">sort_query_params</span><span class="p">)</span><span class="o">.</span><span class="n">all</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="k">def</span> <span class="nf">sort_query_params</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">{</span> <span class="ss">sort</span><span class="p">:</span> <span class="ss">:by_title</span><span class="p">,</span> <span class="ss">direction</span><span class="p">:</span> <span class="ss">:desc</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Composing two Query Objects</em></p>
<h2 id="inheritance-of-query-objects">Inheritance of Query Objects:</h2>
<p>If you have similar queries you may want them to be inherited to reduce
repetition and follow DRY principle:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">ArticlesQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="no">TEXT_LENGTH</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">#+BEGIN_EXAMPLE</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">comments</span> <span class="o">=</span> <span class="no">Comment</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="vi">@comments</span> <span class="o">=</span> <span class="n">comments</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">comments</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">      <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&#34;user_id IS NOT NULL&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">      <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&#34;LENGTH(content) </span><span class="si">#{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="k">def</span> <span class="nf">condition</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="s2">&#34;&gt; </span><span class="si">#{</span><span class="no">TEXT_LENGTH</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">class</span> <span class="nc">LongArticlesQuery</span> <span class="o">&lt;</span> <span class="no">ArticlesQuery</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="no">TEXT_LENGTH</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="c1">#+BEGIN_EXAMPLE</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="k">def</span> <span class="nf">condition</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="s2">&#34;&gt;= </span><span class="si">#{</span><span class="no">TEXT_LENGTH</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Inheritance of Query Objects</em></p>
<h2 id="testing-query-objects">Testing Query Objects:</h2>
<p>Query Objects should be designed to be pleasant for testing. In most
cases you just need to test core methods defined in query for their
results:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nb">require</span> <span class="s2">&#34;rails_helper&#34;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">describe</span> <span class="no">LongArticlesQuery</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">describe</span> <span class="s2">&#34;#all&#34;</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">subject</span><span class="p">(</span><span class="ss">:all</span><span class="p">)</span> <span class="p">{</span> <span class="n">described_class</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">all</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">before</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      <span class="n">create</span> <span class="ss">:article</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s2">&#34;abc&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      <span class="n">create</span> <span class="ss">:article</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s2">&#34;this is long article&#34;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">it</span> <span class="s2">&#34;returns one short comment&#34;</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">      <span class="n">expect</span><span class="p">(</span><span class="n">all</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Testing Query Objects</em></p>
<h2 id="summary">Summary:</h2>
<h3 id="good-query-object">Good Query Object:</h3>
<ul>
<li>Follows <em>Single Responsibility Principle</em></li>
<li>Can be easily tested in isolation</li>
<li>Can be combined/extended with another Query Object</li>
<li>Can be effortlessly reused in any other parts of an application</li>
<li>Returns <em>ActiveRecord::Relation</em>, not <em>Array</em></li>
<li>Represents only database query, not business logic or action</li>
<li>Methods of Query Object are named like <em>ActiveRecord</em> methods (<em>all,
last, count, etc</em>)</li>
</ul>
<h3 id="use-query-objects-when">Use Query Objects when:</h3>
<ul>
<li>You need to reuse one query in multiple places of application</li>
<li>You need to extend, compose or inherit queries and their relations</li>
<li>You need to write a lot of raw SQL, but don&rsquo;t want to mess up your
code</li>
<li>Your query is too complex / vast for just one method or scope</li>
<li>Your query causes <em>feature envy</em></li>
</ul>
<h3 id="dont-use-query-objects-when">Don&rsquo;t use Query Objects when:</h3>
<ul>
<li>Your query is simple enough for just one method or scope</li>
<li>You don&rsquo;t need to extend, compose or inherit your query</li>
<li>Your query is unique and you don&rsquo;t want to make it reusable</li>
</ul>
<p>I hope this article will help you to build awesome queries in your
applications. Good luck and happy coding!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Query objects in Ruby on Rails</title>
      <link>https://neiro.io/posts/2016-10-05-query-objects-in-ruby-on-rails.md/</link>
      <pubDate>Wed, 05 Oct 2016 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2016-10-05-query-objects-in-ruby-on-rails.md/</guid>
      <description>&lt;p&gt;Database queries are common when you develop web applications. &lt;em&gt;Ruby on&#xA;Rails&lt;/em&gt; and it&amp;rsquo;s &lt;em&gt;ActiveRecord&lt;/em&gt; liberates you from writing tons of&#xA;boilerplate SQL code and results in creation of elegant, eloquent&#xA;queries in plain Ruby.&lt;/p&gt;&#xA;&lt;figure&gt;&lt;img src=&#34;https://cdn-images-1.medium.com/max/1600/1*-oIlwIWlt0BDN4b5a9rRCQ.png&#34;&gt;&#xA;&lt;/figure&gt;&#xA;&#xA;&lt;p&gt;But plenty of immense possibilities that Ruby and ActiveRecord provide,&#xA;unfortunately, remain unused. I bet that often you see a lot of enormous&#xA;scopes in Ruby on Rails models, endless chains of queries in controllers&#xA;and even bulky chunks of raw SQL.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Database queries are common when you develop web applications. <em>Ruby on
Rails</em> and it&rsquo;s <em>ActiveRecord</em> liberates you from writing tons of
boilerplate SQL code and results in creation of elegant, eloquent
queries in plain Ruby.</p>
<figure><img src="https://cdn-images-1.medium.com/max/1600/1*-oIlwIWlt0BDN4b5a9rRCQ.png">
</figure>

<p>But plenty of immense possibilities that Ruby and ActiveRecord provide,
unfortunately, remain unused. I bet that often you see a lot of enormous
scopes in Ruby on Rails models, endless chains of queries in controllers
and even bulky chunks of raw SQL.</p>
<p>#+begin_src ruby
@articles = Article.includes(:user)
.order(&ldquo;created_at DESC&rdquo;)
.where(&ldquo;text IS NOT NULL&rdquo;)
.page(page)</p>
<p>@articles = Articles.connection
.select_all(%Q{SELECT articles.* FROM
articles WHERE (text IS NOT NULL) ORDER BY created_at DESC LIMIT 5
OFFSET 0})
#+end_src <em>Bad cases of using ActiveRecord queries</em></p>
<p>These poor practices may create obstacles and become a reason of
developer&rsquo;s headaches in the real-world web applications.</p>
<h2 id="typical-db-queries-application-problems">Typical DB queries application problems:</h2>
<ul>
<li>Big pieces of queries code in controllers/models/services mess up your
code</li>
<li>It is hard to understand complex database requests</li>
<li>Inserts of raw SQL are non-consistent and often mix with ActiveRecord
queries</li>
<li>Testing one separate query in isolation is very problematic</li>
<li>It is difficult to compose, extend or inherit queries</li>
<li>Often Single Responsibility Principle gets violated</li>
</ul>
<h2 id="solution">Solution:</h2>
<p>These problems can be solved by using <em>Query Object</em> pattern &mdash; a
common technique that isolates your complex queries.</p>
<p><em>Query Object</em> in ideal case is a separate class that contains one
specific query that implements just one business logic rule.</p>
<h2 id="implementation">Implementation:</h2>
<p>For most of the cases <em>Query Object</em> is PORO that accepts relation in
constructor and defines queries named like an <em>ActiveRecord</em> common
methods:</p>
<p>#+begin_src ruby</p>
<p>class Article &lt; ActiveRecord::Base
scope :by_title, -&gt;(direction) { order title: direction }
scope :by_date, -&gt;(direction) { order created_at: direction }
scope :by_author, -&gt;(direction) { order &ldquo;users.full_name #{direction}&rdquo; }</p>
<p>SORT_OPTIONS = %w(by_date by_title by_author).freeze</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def initialize(params = {}, relation = Article.includes(:user))
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @relation = relation
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @params = params
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  def all
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    @relation.public_send(sort_by, direction)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">  private
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">  def sort_by
</span></span><span class="line"><span class="ln">13</span><span class="cl">    @params[:sort].presence_in(SORT_OPTIONS) || :by_date
</span></span><span class="line"><span class="ln">14</span><span class="cl">  end
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  def direction
</span></span><span class="line"><span class="ln">17</span><span class="cl">    @params[:direction] == &#34;asc&#34; ? :asc : :desc
</span></span><span class="line"><span class="ln">18</span><span class="cl">  end</span></span></code></pre></div><p>end</p>
<p>index @articles = OrderedArticlesQuery.new(sort_query_params).all.page(params[:page])
end</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  private
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  def sort_query_params
</span></span><span class="line"><span class="ln">4</span><span class="cl">    params.slice(:sort_by, :direction)
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end</span></span></code></pre></div><p>end
#+end_src <em>Query Object implementation and usage in
controller</em></p>
<h3 id="heredoc-syntax-for-raw-sql">HEREDOC syntax for raw SQL:</h3>
<p>For the cases where you desperately need to use raw SQL code try to
isolate it using Ruby&rsquo;s <em>HEREDOC syntax:</em></p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"> <span class="k">class</span> <span class="nc">PopularArticlesQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="no">POPULAR_TRESHOLD</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">subscriptions</span> <span class="o">=</span> <span class="no">Subscription</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="vi">@subscriptions</span> <span class="o">=</span> <span class="n">subscriptions</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="vi">@subscriptions</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="kp">private</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="k">def</span> <span class="nf">query</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">    <span class="s">&lt;&lt;-SQL
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="s"></span>      <span class="n">articles</span><span class="o">.</span><span class="n">comments_count</span> <span class="o">&gt;=</span> <span class="c1">#{POPULAR_TRESHOLD}</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">      <span class="no">AND</span> <span class="n">articles</span><span class="o">.</span><span class="n">content</span> <span class="no">IS</span> <span class="no">NOT</span> <span class="no">NULL</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">      <span class="no">AND</span> <span class="n">articles</span><span class="o">.</span><span class="n">status</span> <span class="o">=</span> <span class="c1">#{Article::STATUSES[:published]}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">      <span class="no">ORDER</span> <span class="no">BY</span> <span class="n">articles</span><span class="o">.</span><span class="n">comments_count</span> <span class="no">DESC</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">    <span class="no">SQL</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>HEREDOC syntax example for raw SQL inserts</em></p>
<h3 id="extending-scope">Extending scope:</h3>
<p>If your scope relates to existing <em>QueryObject</em>, you can easily extend
its relation instead of cluttering up your models.
<a href="http://apidock.com/rails/ActiveRecord/QueryMethods/extending">ActiveRecord::QueryMethods.extending</a>
method will help you:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">OrderedArticlesQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="no">SORT_OPTIONS</span> <span class="o">=</span> <span class="sx">%w(by_date by_title by_author)</span><span class="o">.</span><span class="n">freeze</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">params</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">relation</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">includes</span><span class="p">(</span><span class="ss">:user</span><span class="p">))</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="vi">@relation</span> <span class="o">=</span> <span class="n">relation</span><span class="o">.</span><span class="n">extending</span><span class="p">(</span><span class="no">Scopes</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="vi">@params</span> <span class="o">=</span> <span class="n">params</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="vi">@relation</span><span class="o">.</span><span class="n">public_send</span><span class="p">(</span><span class="n">sort_by</span><span class="p">,</span> <span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="kp">private</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="k">def</span> <span class="nf">sort_by</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">    <span class="vi">@params</span><span class="o">[</span><span class="ss">:sort</span><span class="o">].</span><span class="n">presence_in</span><span class="p">(</span><span class="no">SORT_OPTIONS</span><span class="p">)</span> <span class="o">||</span> <span class="ss">:by_date</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="k">def</span> <span class="nf">direction</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">    <span class="vi">@params</span><span class="o">[</span><span class="ss">:direction</span><span class="o">]</span> <span class="o">==</span> <span class="s2">&#34;asc&#34;</span> <span class="p">?</span> <span class="ss">:asc</span> <span class="p">:</span> <span class="ss">:desc</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="c1"># Group additional scope methods in module in order to extend relation</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="k">module</span> <span class="nn">Scopes</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">    <span class="k">def</span> <span class="nf">by_title</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">      <span class="n">order</span><span class="p">(</span><span class="ss">title</span><span class="p">:</span> <span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">28</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">
</span></span><span class="line"><span class="ln">30</span><span class="cl">    <span class="k">def</span> <span class="nf">by_date</span><span class="p">(</span><span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">31</span><span class="cl">      <span class="n">order</span><span class="p">(</span><span class="ss">created_at</span><span class="p">:</span> <span class="n">direction</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">33</span><span class="cl">
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="k">def</span> <span class="nf">by_author</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">      <span class="n">order</span><span class="p">(</span><span class="s2">&#34;users.full_name </span><span class="si">#{</span><span class="n">direction</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Extending scope for Query Objects relations</em></p>
<h2 id="composing-query-objects">Composing Query Objects:</h2>
<p><em>Query Objects</em> should be devised to support composition with other
<em>Query Objects</em> and other ActiveRecord relations. In the example below
two composed Query Objects represent one SQL query:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">FeaturedQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">relation</span> <span class="o">=</span> <span class="no">Article</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    <span class="vi">@relation</span> <span class="o">=</span> <span class="n">relation</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="vi">@relation</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="ss">featured</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&#34;views_count &gt; ?&#34;</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="k">class</span> <span class="nc">ArticlesController</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="k">def</span> <span class="nf">index</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="vi">@articles</span> <span class="o">=</span> <span class="no">FeaturedArticlesQuery</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">sorted_articles</span><span class="p">)</span><span class="o">.</span><span class="n">all</span> <span class="c1"># SELECT &#34;articles&#34;.* FROM &#34;articles&#34; WHERE &#34;articles&#34;.&#34;featured&#34; = $1 # AND (views_count &gt;100) ORDER BY &#34;articles&#34;.&#34;created_at&#34; DESC LIMIT 10 OFFSET 0</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="kp">private</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">
</span></span><span class="line"><span class="ln">18</span><span class="cl">  <span class="k">def</span> <span class="nf">sorted_articles</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="no">SortedArticlesQuery</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">sort_query_params</span><span class="p">)</span><span class="o">.</span><span class="n">all</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="k">def</span> <span class="nf">sort_query_params</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">    <span class="p">{</span> <span class="ss">sort</span><span class="p">:</span> <span class="ss">:by_title</span><span class="p">,</span> <span class="ss">direction</span><span class="p">:</span> <span class="ss">:desc</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Composing two Query Objects</em></p>
<h2 id="inheritance-of-query-objects">Inheritance of Query Objects:</h2>
<p>If you have similar queries you may want them to be inherited to reduce
repetition and follow DRY principle:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="k">class</span> <span class="nc">ArticlesQuery</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="no">TEXT_LENGTH</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="c1">#+BEGIN_EXAMPLE</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">comments</span> <span class="o">=</span> <span class="no">Comment</span><span class="o">.</span><span class="n">all</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    <span class="vi">@comments</span> <span class="o">=</span> <span class="n">comments</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="k">def</span> <span class="nf">all</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="n">comments</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">      <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&#34;user_id IS NOT NULL&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">      <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="s2">&#34;LENGTH(content) </span><span class="si">#{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="k">def</span> <span class="nf">condition</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="s2">&#34;&gt; </span><span class="si">#{</span><span class="no">TEXT_LENGTH</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="k">end</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">class</span> <span class="nc">LongArticlesQuery</span> <span class="o">&lt;</span> <span class="no">ArticlesQuery</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="no">TEXT_LENGTH</span> <span class="o">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">  <span class="c1">#+BEGIN_EXAMPLE</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="k">def</span> <span class="nf">condition</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">    <span class="s2">&#34;&gt;= </span><span class="si">#{</span><span class="no">TEXT_LENGTH</span><span class="si">}</span><span class="s2">&#34;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Inheritance of Query Objects</em></p>
<h2 id="testing-query-objects">Testing Query Objects:</h2>
<p>Query Objects should be designed to be pleasant for testing. In most
cases you just need to test core methods defined in query for their
results:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-ruby" data-lang="ruby"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nb">require</span> <span class="s2">&#34;rails_helper&#34;</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="n">describe</span> <span class="no">LongArticlesQuery</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="n">describe</span> <span class="s2">&#34;#all&#34;</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    <span class="n">subject</span><span class="p">(</span><span class="ss">:all</span><span class="p">)</span> <span class="p">{</span> <span class="n">described_class</span><span class="o">.</span><span class="n">new</span><span class="o">.</span><span class="n">all</span> <span class="p">}</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">    <span class="n">before</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">      <span class="n">create</span> <span class="ss">:article</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s2">&#34;abc&#34;</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      <span class="n">create</span> <span class="ss">:article</span><span class="p">,</span> <span class="ss">text</span><span class="p">:</span> <span class="s2">&#34;this is long article&#34;</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    <span class="n">it</span> <span class="s2">&#34;returns one short comment&#34;</span> <span class="k">do</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">      <span class="n">expect</span><span class="p">(</span><span class="n">all</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">to</span> <span class="n">eq</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="k">end</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">  <span class="k">end</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="k">end</span></span></span></code></pre></div><p><em>Testing Query Objects</em></p>
<h2 id="summary">Summary:</h2>
<h3 id="good-query-object">Good Query Object:</h3>
<ul>
<li>Follows <em>Single Responsibility Principle</em></li>
<li>Can be easily tested in isolation</li>
<li>Can be combined/extended with another Query Object</li>
<li>Can be effortlessly reused in any other parts of an application</li>
<li>Returns <em>ActiveRecord::Relation</em>, not <em>Array</em></li>
<li>Represents only database query, not business logic or action</li>
<li>Methods of Query Object are named like <em>ActiveRecord</em> methods (<em>all,
last, count, etc</em>)</li>
</ul>
<h3 id="use-query-objects-when">Use Query Objects when:</h3>
<ul>
<li>You need to reuse one query in multiple places of application</li>
<li>You need to extend, compose or inherit queries and their relations</li>
<li>You need to write a lot of raw SQL, but don&rsquo;t want to mess up your
code</li>
<li>Your query is too complex / vast for just one method or scope</li>
<li>Your query causes <em>feature envy</em></li>
</ul>
<h3 id="dont-use-query-objects-when">Don&rsquo;t use Query Objects when:</h3>
<ul>
<li>Your query is simple enough for just one method or scope</li>
<li>You don&rsquo;t need to extend, compose or inherit your query</li>
<li>Your query is unique and you don&rsquo;t want to make it reusable</li>
</ul>
<p>I hope this article will help you to build awesome queries in your
applications. Good luck and happy coding!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
