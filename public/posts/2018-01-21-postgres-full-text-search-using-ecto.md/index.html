<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://neiro.io/images/favicon.png" />
<title>Postgres full-text search using Ecto | neiro blog</title>
<meta name="title" content="Postgres full-text search using Ecto" />
<meta name="description" content="PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.
If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records." />
<meta name="author" content="[neiro]" />
<meta name="keywords" content="elixir,query,postgres,search," />






  





  













<meta property="og:title" content="Postgres full-text search using Ecto" />
<meta property="og:description" content="PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.
If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/" />

<meta property="og:image" content="https://neiro.io/images/social_card_bg_hu4291665225748502129.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-01-21T10:00:00+01:00" />
<meta property="article:modified_time" content="2018-01-21T10:00:00+01:00" /><meta property="og:site_name" content="neiro" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://neiro.io/images/social_card_bg_hu4291665225748502129.webp"/>
<meta name="twitter:title" content="Postgres full-text search using Ecto"/>
<meta name="twitter:description" content="PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.
If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records."/>



<meta itemprop="name" content="Postgres full-text search using Ecto">
<meta itemprop="description" content="PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.
If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records."><meta itemprop="datePublished" content="2018-01-21T10:00:00+01:00" />
<meta itemprop="dateModified" content="2018-01-21T10:00:00+01:00" />
<meta itemprop="wordCount" content="792">

<meta itemprop="image" content="https://neiro.io/images/social_card_bg_hu4291665225748502129.webp"/>


<meta itemprop="keywords" content="elixir,query,postgres,search," />

<meta name="referrer" content="no-referrer-when-downgrade" />

  
  <link href="/herman.min.css" rel="stylesheet">

  
    
    <link href="/syntax.min.css" rel="stylesheet">
  

  

  
</head>

<body>
  <header><a class="skip-link" href="#main-content">Skip to main content</a>

<a href="/" class="title"><h1>neiro blog</h1></a>
<nav>
  <a href="/">Home</a>

  <a href="/blog/">Blog</a>

<a href='https://neiro.io/index.xml'>RSS</a>







</nav>
</header>
  <main id="main-content">

<h1>Postgres full-text search using Ecto</h1>
<p class="byline">
  <time datetime='2018-01-21' pubdate>
    2018-01-21
  </time>
  · [neiro]
</p>

<content>
  <p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>

</content>
<p>
  
    <a class="blog-tags" href="/tags/elixir/">#elixir</a>
  
    <a class="blog-tags" href="/tags/query/">#query</a>
  
    <a class="blog-tags" href="/tags/postgres/">#postgres</a>
  
    <a class="blog-tags" href="/tags/search/">#search</a>
  
</p>




  </main>
  <footer><small>
  neiro © 2012-2025 | Made with <a href="https://github.com/clente/hugo-bearcub">Bear Cub</a>
</small></footer>

    
</body>

</html>
