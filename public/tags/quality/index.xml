<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Quality on neiro blog</title>
    <link>https://neiro.io/tags/quality/</link>
    <description>Recent content in Quality on neiro blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <copyright>neiro Â© 2012-2025</copyright>
    <lastBuildDate>Tue, 19 Jun 2018 10:00:00 +0200</lastBuildDate>
    <atom:link href="https://neiro.io/tags/quality/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Elixir continious integration with CircleCI</title>
      <link>https://neiro.io/blog/2018-06-19-elixir-continious-integration-with-circleci.md/</link>
      <pubDate>Tue, 19 Jun 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2018-06-19-elixir-continious-integration-with-circleci.md/</guid>
      <description>&lt;p&gt;Elixir programming language has gained popularity and now it is&#xA;supported at many platforms, including plenty of CI services. In this&#xA;article we will see how we can achieve seamless and &lt;em&gt;(almost)&lt;/em&gt; dead&#xA;simple continious integration by using CircleCI in our Elixir projects.&lt;/p&gt;&#xA;&lt;h2 id=&#34;circleci-2.0&#34;&gt;CircleCI 2.0&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com&#34;&gt;CircleCI&lt;/a&gt; is one of the most popular and&#xA;user-friendly continious integration solutions. It supports many&#xA;programming languages and tools, including Elixir and Erlang/OTP.&lt;/p&gt;&#xA;&lt;p&gt;CircleCI is entirely free when it comes to open-source GitHub&#xA;repositories, but it also provides free 1500 minutes a month for any&#xA;private repos.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has gained popularity and now it is
supported at many platforms, including plenty of CI services. In this
article we will see how we can achieve seamless and <em>(almost)</em> dead
simple continious integration by using CircleCI in our Elixir projects.</p>
<h2 id="circleci-2.0">CircleCI 2.0</h2>
<p><a href="https://circleci.com">CircleCI</a> is one of the most popular and
user-friendly continious integration solutions. It supports many
programming languages and tools, including Elixir and Erlang/OTP.</p>
<p>CircleCI is entirely free when it comes to open-source GitHub
repositories, but it also provides free 1500 minutes a month for any
private repos.</p>
<p>Starting version 2.0 CircleCI can create jobs based on any images from
<a href="https://hub.docker.com/">DockerHub</a>. This feature makes possible to
build any programming language or platform that can be placed in Docker
image.</p>
<p>Imagine you have a standard Elixir Phoenix / Ecto application. You need
to run it on the latest versions of Elixir and Erlang/OTP and run the
tests on PostgreSQL database.</p>
<p>Let&rsquo;s start by creating a CircleCI configuration file in
<code>.circleci/config.yml</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  version: 2  # use CircleCI 2.0 instead of CircleCI Classic
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  jobs:  # basic units of work in a run
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build:  # runs not using Workflows must have a `build` job as entry point
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      parallelism: 1  # run only one instance of this job in parallel
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      docker:  # run the steps with Docker
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - image: circleci/elixir:1.6 # ...with this image as the primary container; this is where all `steps` will run
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            MIX_ENV: test
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - image: mdillon/postgis:9.6-alpine  # database image
</span></span><span class="line"><span class="ln">11</span><span class="cl">          environment:  # environment variables for database
</span></span><span class="line"><span class="ln">12</span><span class="cl">            POSTGRES_DB: app_test
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      steps:  # commands that comprise the `build` job
</span></span><span class="line"><span class="ln">15</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)</span></span></code></pre></div><p>As you can see here, we are declaring the <code>build</code> continious integration
job. Basically we will use the Elixir 1.6 with PostgreSQL 9.6 to run
tests on the <code>app_test</code> database. After that we will checkout source
code base to fetch our recent changes into the build. <code>mix local</code> tasks
are also necessary in order to use any of <em>Mix</em> tasks later.</p>
<h2 id="running-tests-and-code-quality">Running tests and code quality</h2>
<p>All of us want to run all common continious integration steps such as:</p>
<ul>
<li>Fetch dependencies and compile application</li>
<li>Run code quality tools and checks (<em>you can read more about it
<a href="https://neiro.io/2018/04/28/elixir-code-quality-tools-and-checks.html">here</a>)</em></li>
<li>Execute all tests to make sure that our build is successful and
infallible</li>
<li>Run heavy and bulky static analysis tools</li>
</ul>
<p>Also we want to make our builds as fast as possible, so we definitely
need caching. Let&rsquo;s continue with our config and implement the steps
above:</p>
<p>{% raw %}</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">        - restore_cache:  # restores saved mix cache
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">            keys:  # list of cache keys, in decreasing specificity
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">              - v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">              - v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">              - v1-mix-cache
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - restore_cache:  # restores saved build cache
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">              - v1-build-cache
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - restore_cache:  # restores saved plt cache
</span></span><span class="line"><span class="ln">11</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln">12</span><span class="cl">              - dialyzer-cache
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - save_cache:  # generate and store cache so `restore_cache` works
</span></span><span class="line"><span class="ln">17</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln">18</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">19</span><span class="cl">        - save_cache:  # make another less specific cache
</span></span><span class="line"><span class="ln">20</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">21</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - save_cache:  # you should really save one more cache just in case
</span></span><span class="line"><span class="ln">23</span><span class="cl">            key: v1-mix-cache
</span></span><span class="line"><span class="ln">24</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - save_cache: # don&#39;t forget to save a *build* cache, too
</span></span><span class="line"><span class="ln">26</span><span class="cl">            key: v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">27</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">28</span><span class="cl">        - save_cache: # and one more build cache for good measure
</span></span><span class="line"><span class="ln">29</span><span class="cl">            key: v1-build-cache
</span></span><span class="line"><span class="ln">30</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">        - run: mix do format --check-formatted, credo --strict, security
</span></span><span class="line"><span class="ln">33</span><span class="cl">        - run: mix do xref deprecated --include-siblings, xref unreachable --include-siblings, xref graph --format stats
</span></span><span class="line"><span class="ln">34</span><span class="cl">
</span></span><span class="line"><span class="ln">35</span><span class="cl">        - run:  # special utility that stalls main process until DB is ready
</span></span><span class="line"><span class="ln">36</span><span class="cl">            name: Wait for DB
</span></span><span class="line"><span class="ln">37</span><span class="cl">            command: dockerize -wait tcp://localhost:5432 -timeout 1m
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">        - run: mix do ecto.migrations, ecto.load
</span></span><span class="line"><span class="ln">40</span><span class="cl">        - run: mix test  # run all tests in project
</span></span><span class="line"><span class="ln">41</span><span class="cl">
</span></span><span class="line"><span class="ln">42</span><span class="cl">        - run: mix dialyzer --halt-exit-status
</span></span><span class="line"><span class="ln">43</span><span class="cl">        - save_cache:
</span></span><span class="line"><span class="ln">44</span><span class="cl">            key: dialyzer-cache
</span></span><span class="line"><span class="ln">45</span><span class="cl">            paths: &#34;_build/test/dialyxir*.plt&#34;
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">        - store_test_results:  # upload test results for display in Test Summary
</span></span><span class="line"><span class="ln">48</span><span class="cl">            path: _build/test/lib/app/results.xml</span></span></code></pre></div><p>{% endraw %}</p>
<p>Now you can start new builds by signing up into CircleCI as it will run
the configuration and steps from your config. Every commit in any branch
will run the build job and you will know if something is wrong with your
code.</p>
<h2 id="deploying">Deploying</h2>
<p>However, having only one build job is not enough even for the simplest
CI process. Most often we need to make a staging/production release by
using <a href="https://github.com/bitwalker/distillery">Distillery</a>.</p>
<p>Let&rsquo;s continue filling up our configuration file by adding a new
<code>deploy</code> job:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    deploy:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      docker:
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        - image: circleci/elixir:1.6
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            MIX_ENV: staging
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      steps:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">11</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        # set MIX_ENV to prod or staging value according to the source branch
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - run:
</span></span><span class="line"><span class="ln">17</span><span class="cl">            name: Update MIX_ENV environment variable
</span></span><span class="line"><span class="ln">18</span><span class="cl">            command: |
</span></span><span class="line"><span class="ln">19</span><span class="cl">              echo &#34;export MIX_ENV=$(if [ &#39;$CIRCLE_BRANCH&#39; &#39;==&#39; &#39;master&#39; ]; then echo &#39;prod&#39;; else echo &#39;staging&#39;; fi)&#34; &gt;&gt; $BASH_ENV
</span></span><span class="line"><span class="ln">20</span><span class="cl">              source $BASH_ENV
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - run: cd deps/argon2_elixir &amp;&amp; make clean &amp;&amp; make &amp;&amp; cd -
</span></span><span class="line"><span class="ln">23</span><span class="cl">        - run: MIX_ENV=staging mix release --env $MIX_ENV
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - run: tar -zcvf $CIRCLE_SHA1.tar.gz bin appspec.yml VERSION _build/$MIX_ENV/rel/app/releases/$(cat VERSION)/app.tar.gz</span></span></code></pre></div><p>This will be enough to create a separate deploy job that will run on a
separate Docker image. However, we will need to run it only on develop
and master branches in order to upload staging/production releases
accordingly. We can achieve this by using CircleCI workflow and
providing a simple configuration at the bottom of our config file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  workflows:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    version: 2
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build-and-deploy:
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      jobs:
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        - build
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - deploy:
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            requires:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - build
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            filters:
</span></span><span class="line"><span class="ln">10</span><span class="cl">              branches:
</span></span><span class="line"><span class="ln">11</span><span class="cl">                only:
</span></span><span class="line"><span class="ln">12</span><span class="cl">                  - develop
</span></span><span class="line"><span class="ln">13</span><span class="cl">                  - master</span></span></code></pre></div><p>After that you are free to upload the built release to any server or any
platform you want. You can use Edeliver, Ansible, Chef, Docker - it&rsquo;s up
to you.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see above, it&rsquo;s not so hard to build and deploy Elixir
applications with CircleCI 2.0. This platform is flexible and fast
enough to make your continious integration bright and shiny.</p>
<p>If you want to discover even more on the topic then let&rsquo;s read
<a href="https://circleci.com/docs/2.0/">CircleCI 2.0 documentation</a> and
<a href="https://circleci.com/docs/2.0/language-elixir/">Elixir Language
Guide</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir continious integration with CircleCI</title>
      <link>https://neiro.io/posts/2018-06-19-elixir-continious-integration-with-circleci.md/</link>
      <pubDate>Tue, 19 Jun 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2018-06-19-elixir-continious-integration-with-circleci.md/</guid>
      <description>&lt;p&gt;Elixir programming language has gained popularity and now it is&#xA;supported at many platforms, including plenty of CI services. In this&#xA;article we will see how we can achieve seamless and &lt;em&gt;(almost)&lt;/em&gt; dead&#xA;simple continious integration by using CircleCI in our Elixir projects.&lt;/p&gt;&#xA;&lt;h2 id=&#34;circleci-2.0&#34;&gt;CircleCI 2.0&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://circleci.com&#34;&gt;CircleCI&lt;/a&gt; is one of the most popular and&#xA;user-friendly continious integration solutions. It supports many&#xA;programming languages and tools, including Elixir and Erlang/OTP.&lt;/p&gt;&#xA;&lt;p&gt;CircleCI is entirely free when it comes to open-source GitHub&#xA;repositories, but it also provides free 1500 minutes a month for any&#xA;private repos.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has gained popularity and now it is
supported at many platforms, including plenty of CI services. In this
article we will see how we can achieve seamless and <em>(almost)</em> dead
simple continious integration by using CircleCI in our Elixir projects.</p>
<h2 id="circleci-2.0">CircleCI 2.0</h2>
<p><a href="https://circleci.com">CircleCI</a> is one of the most popular and
user-friendly continious integration solutions. It supports many
programming languages and tools, including Elixir and Erlang/OTP.</p>
<p>CircleCI is entirely free when it comes to open-source GitHub
repositories, but it also provides free 1500 minutes a month for any
private repos.</p>
<p>Starting version 2.0 CircleCI can create jobs based on any images from
<a href="https://hub.docker.com/">DockerHub</a>. This feature makes possible to
build any programming language or platform that can be placed in Docker
image.</p>
<p>Imagine you have a standard Elixir Phoenix / Ecto application. You need
to run it on the latest versions of Elixir and Erlang/OTP and run the
tests on PostgreSQL database.</p>
<p>Let&rsquo;s start by creating a CircleCI configuration file in
<code>.circleci/config.yml</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  version: 2  # use CircleCI 2.0 instead of CircleCI Classic
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  jobs:  # basic units of work in a run
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build:  # runs not using Workflows must have a `build` job as entry point
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      parallelism: 1  # run only one instance of this job in parallel
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      docker:  # run the steps with Docker
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - image: circleci/elixir:1.6 # ...with this image as the primary container; this is where all `steps` will run
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">            MIX_ENV: test
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - image: mdillon/postgis:9.6-alpine  # database image
</span></span><span class="line"><span class="ln">11</span><span class="cl">          environment:  # environment variables for database
</span></span><span class="line"><span class="ln">12</span><span class="cl">            POSTGRES_DB: app_test
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">      steps:  # commands that comprise the `build` job
</span></span><span class="line"><span class="ln">15</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">18</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)</span></span></code></pre></div><p>As you can see here, we are declaring the <code>build</code> continious integration
job. Basically we will use the Elixir 1.6 with PostgreSQL 9.6 to run
tests on the <code>app_test</code> database. After that we will checkout source
code base to fetch our recent changes into the build. <code>mix local</code> tasks
are also necessary in order to use any of <em>Mix</em> tasks later.</p>
<h2 id="running-tests-and-code-quality">Running tests and code quality</h2>
<p>All of us want to run all common continious integration steps such as:</p>
<ul>
<li>Fetch dependencies and compile application</li>
<li>Run code quality tools and checks (<em>you can read more about it
<a href="https://neiro.io/2018/04/28/elixir-code-quality-tools-and-checks.html">here</a>)</em></li>
<li>Execute all tests to make sure that our build is successful and
infallible</li>
<li>Run heavy and bulky static analysis tools</li>
</ul>
<p>Also we want to make our builds as fast as possible, so we definitely
need caching. Let&rsquo;s continue with our config and implement the steps
above:</p>
<p>{% raw %}</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">        - restore_cache:  # restores saved mix cache
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">            keys:  # list of cache keys, in decreasing specificity
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">              - v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">              - v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">              - v1-mix-cache
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - restore_cache:  # restores saved build cache
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">              - v1-build-cache
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - restore_cache:  # restores saved plt cache
</span></span><span class="line"><span class="ln">11</span><span class="cl">            keys:
</span></span><span class="line"><span class="ln">12</span><span class="cl">              - dialyzer-cache
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - save_cache:  # generate and store cache so `restore_cache` works
</span></span><span class="line"><span class="ln">17</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}-{{ checksum &#34;mix.lock&#34; }}
</span></span><span class="line"><span class="ln">18</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">19</span><span class="cl">        - save_cache:  # make another less specific cache
</span></span><span class="line"><span class="ln">20</span><span class="cl">            key: v1-mix-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">21</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - save_cache:  # you should really save one more cache just in case
</span></span><span class="line"><span class="ln">23</span><span class="cl">            key: v1-mix-cache
</span></span><span class="line"><span class="ln">24</span><span class="cl">            paths: &#34;deps&#34;
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - save_cache: # don&#39;t forget to save a *build* cache, too
</span></span><span class="line"><span class="ln">26</span><span class="cl">            key: v1-build-cache-{{ .Branch }}
</span></span><span class="line"><span class="ln">27</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">28</span><span class="cl">        - save_cache: # and one more build cache for good measure
</span></span><span class="line"><span class="ln">29</span><span class="cl">            key: v1-build-cache
</span></span><span class="line"><span class="ln">30</span><span class="cl">            paths: &#34;_build&#34;
</span></span><span class="line"><span class="ln">31</span><span class="cl">
</span></span><span class="line"><span class="ln">32</span><span class="cl">        - run: mix do format --check-formatted, credo --strict, security
</span></span><span class="line"><span class="ln">33</span><span class="cl">        - run: mix do xref deprecated --include-siblings, xref unreachable --include-siblings, xref graph --format stats
</span></span><span class="line"><span class="ln">34</span><span class="cl">
</span></span><span class="line"><span class="ln">35</span><span class="cl">        - run:  # special utility that stalls main process until DB is ready
</span></span><span class="line"><span class="ln">36</span><span class="cl">            name: Wait for DB
</span></span><span class="line"><span class="ln">37</span><span class="cl">            command: dockerize -wait tcp://localhost:5432 -timeout 1m
</span></span><span class="line"><span class="ln">38</span><span class="cl">
</span></span><span class="line"><span class="ln">39</span><span class="cl">        - run: mix do ecto.migrations, ecto.load
</span></span><span class="line"><span class="ln">40</span><span class="cl">        - run: mix test  # run all tests in project
</span></span><span class="line"><span class="ln">41</span><span class="cl">
</span></span><span class="line"><span class="ln">42</span><span class="cl">        - run: mix dialyzer --halt-exit-status
</span></span><span class="line"><span class="ln">43</span><span class="cl">        - save_cache:
</span></span><span class="line"><span class="ln">44</span><span class="cl">            key: dialyzer-cache
</span></span><span class="line"><span class="ln">45</span><span class="cl">            paths: &#34;_build/test/dialyxir*.plt&#34;
</span></span><span class="line"><span class="ln">46</span><span class="cl">
</span></span><span class="line"><span class="ln">47</span><span class="cl">        - store_test_results:  # upload test results for display in Test Summary
</span></span><span class="line"><span class="ln">48</span><span class="cl">            path: _build/test/lib/app/results.xml</span></span></code></pre></div><p>{% endraw %}</p>
<p>Now you can start new builds by signing up into CircleCI as it will run
the configuration and steps from your config. Every commit in any branch
will run the build job and you will know if something is wrong with your
code.</p>
<h2 id="deploying">Deploying</h2>
<p>However, having only one build job is not enough even for the simplest
CI process. Most often we need to make a staging/production release by
using <a href="https://github.com/bitwalker/distillery">Distillery</a>.</p>
<p>Let&rsquo;s continue filling up our configuration file by adding a new
<code>deploy</code> job:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    deploy:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      docker:
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        - image: circleci/elixir:1.6
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">          environment:  # environment variables for primary container
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">            SHELL: /bin/bash
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">            MIX_ENV: staging
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      steps:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        - checkout  # check out source code to working directory
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">        - run: mix local.hex --force  # install Hex locally (without prompt)
</span></span><span class="line"><span class="ln">11</span><span class="cl">        - run: mix local.rebar --force  # fetch a copy of rebar (without prompt)
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl">        - run: mix do deps.get, compile # get updated dependencies &amp; compile them
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        # set MIX_ENV to prod or staging value according to the source branch
</span></span><span class="line"><span class="ln">16</span><span class="cl">        - run:
</span></span><span class="line"><span class="ln">17</span><span class="cl">            name: Update MIX_ENV environment variable
</span></span><span class="line"><span class="ln">18</span><span class="cl">            command: |
</span></span><span class="line"><span class="ln">19</span><span class="cl">              echo &#34;export MIX_ENV=$(if [ &#39;$CIRCLE_BRANCH&#39; &#39;==&#39; &#39;master&#39; ]; then echo &#39;prod&#39;; else echo &#39;staging&#39;; fi)&#34; &gt;&gt; $BASH_ENV
</span></span><span class="line"><span class="ln">20</span><span class="cl">              source $BASH_ENV
</span></span><span class="line"><span class="ln">21</span><span class="cl">
</span></span><span class="line"><span class="ln">22</span><span class="cl">        - run: cd deps/argon2_elixir &amp;&amp; make clean &amp;&amp; make &amp;&amp; cd -
</span></span><span class="line"><span class="ln">23</span><span class="cl">        - run: MIX_ENV=staging mix release --env $MIX_ENV
</span></span><span class="line"><span class="ln">24</span><span class="cl">
</span></span><span class="line"><span class="ln">25</span><span class="cl">        - run: tar -zcvf $CIRCLE_SHA1.tar.gz bin appspec.yml VERSION _build/$MIX_ENV/rel/app/releases/$(cat VERSION)/app.tar.gz</span></span></code></pre></div><p>This will be enough to create a separate deploy job that will run on a
separate Docker image. However, we will need to run it only on develop
and master branches in order to upload staging/production releases
accordingly. We can achieve this by using CircleCI workflow and
providing a simple configuration at the bottom of our config file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  workflows:
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    version: 2
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    build-and-deploy:
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      jobs:
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        - build
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        - deploy:
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">            requires:
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">              - build
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">            filters:
</span></span><span class="line"><span class="ln">10</span><span class="cl">              branches:
</span></span><span class="line"><span class="ln">11</span><span class="cl">                only:
</span></span><span class="line"><span class="ln">12</span><span class="cl">                  - develop
</span></span><span class="line"><span class="ln">13</span><span class="cl">                  - master</span></span></code></pre></div><p>After that you are free to upload the built release to any server or any
platform you want. You can use Edeliver, Ansible, Chef, Docker - it&rsquo;s up
to you.</p>
<h2 id="conclusion">Conclusion</h2>
<p>As you can see above, it&rsquo;s not so hard to build and deploy Elixir
applications with CircleCI 2.0. This platform is flexible and fast
enough to make your continious integration bright and shiny.</p>
<p>If you want to discover even more on the topic then let&rsquo;s read
<a href="https://circleci.com/docs/2.0/">CircleCI 2.0 documentation</a> and
<a href="https://circleci.com/docs/2.0/language-elixir/">Elixir Language
Guide</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir code quality tools and checks</title>
      <link>https://neiro.io/blog/2018-04-28-elixir-code-quality-tools-and-checks.md/</link>
      <pubDate>Sat, 28 Apr 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2018-04-28-elixir-code-quality-tools-and-checks.md/</guid>
      <description>&lt;p&gt;Elixir programming language has its great, huge community and ecosystem.&#xA;As for now, we can easily do static code analysis and code quality&#xA;checks by using plenty of standard or external tools. This allows us to&#xA;write robust solid Elixir code in a uniform way according to the&#xA;&lt;a href=&#34;https://github.com/christopheradams/elixir_style_guide&#34;&gt;style guide&lt;/a&gt;&#xA;.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with the most popular tools and solutions:&lt;/p&gt;&#xA;&lt;h2 id=&#34;mix-compile-warnings-as-errors&#34;&gt;mix compile &amp;ndash;warnings-as-errors&lt;/h2&gt;&#xA;&lt;p&gt;The first and the simplest check that could possibly exist. Elixir&#xA;compiler is smart enough to detect easily harsh mistakes like unused&#xA;variables or mismatched module names. At the same time it is pretty&#xA;friendly, because compiler just warns you about these problems, but does&#xA;not stop compilation. For some reasons, especially if we are running the&#xA;CI, we want to make it more obvious and stop any further checks. This&#xA;can be achieved by running &lt;code&gt;mix compile&lt;/code&gt; task with related option:&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has its great, huge community and ecosystem.
As for now, we can easily do static code analysis and code quality
checks by using plenty of standard or external tools. This allows us to
write robust solid Elixir code in a uniform way according to the
<a href="https://github.com/christopheradams/elixir_style_guide">style guide</a>
.</p>
<p>Let&rsquo;s start with the most popular tools and solutions:</p>
<h2 id="mix-compile-warnings-as-errors">mix compile &ndash;warnings-as-errors</h2>
<p>The first and the simplest check that could possibly exist. Elixir
compiler is smart enough to detect easily harsh mistakes like unused
variables or mismatched module names. At the same time it is pretty
friendly, because compiler just warns you about these problems, but does
not stop compilation. For some reasons, especially if we are running the
CI, we want to make it more obvious and stop any further checks. This
can be achieved by running <code>mix compile</code> task with related option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix compile --warnings-as-errors</span></span></code></pre></div><h2 id="mix-format-check-formatted">mix format &ndash;check-formatted</h2>
<p>Elixir 1.6 introduced yet another useful tool - the formatter. After
that we can keep our codebase consistent in one uniform code style
without any contradictions. However, in the real life, not everyone uses
the formatter and we need to force this option by running <code>mix format</code>
task with the <code>--check-formatted</code> option during CI.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix format --check-formatted</span></span></code></pre></div><h2 id="credo">Credo</h2>
<p><a href="https://github.com/rrrene/credo">Credo</a> is a static analysis code
tool for Elixir. It&rsquo;s more than just a usual code checker - it can teach
you how to write your code better, show refactoring possibilities and
inconsistencies in naming.</p>
<p>In order to start using Credo you need to add this line to your
<code>mix.exs</code> deps:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  {:credo, &#34;~&gt; 0.9.1&#34;, only: ~w(dev test)a, runtime: false}</span></span></code></pre></div><p>You can enforce your own code style for your team by using Credo
configuration file. For example, you can create <code>config/.credo.exs</code> file
with this content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  %{
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    #
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    # You can have as many configs as you like in the `configs:` field.
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    configs: [
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      %{
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        #
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        # Run any exec using `mix credo -C &lt;name&gt;`. If no exec name is given
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # &#34;default&#34; is used.
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        name: &#34;default&#34;,
</span></span><span class="line"><span class="ln">10</span><span class="cl">        #
</span></span><span class="line"><span class="ln">11</span><span class="cl">        # These are the files included in the analysis:
</span></span><span class="line"><span class="ln">12</span><span class="cl">        files: %{
</span></span><span class="line"><span class="ln">13</span><span class="cl">          #
</span></span><span class="line"><span class="ln">14</span><span class="cl">          # You can give explicit globs or simply directories.
</span></span><span class="line"><span class="ln">15</span><span class="cl">          # In the latter case `**/*.{ex,exs}` will be used.
</span></span><span class="line"><span class="ln">16</span><span class="cl">          excluded: [~r&#34;/_build/&#34;, ~r&#34;/deps/&#34;, ~r&#34;/priv/&#34;]
</span></span><span class="line"><span class="ln">17</span><span class="cl">        },
</span></span><span class="line"><span class="ln">18</span><span class="cl">        #
</span></span><span class="line"><span class="ln">19</span><span class="cl">        # If you create your own checks, you must specify the source files for
</span></span><span class="line"><span class="ln">20</span><span class="cl">        # them here, so they can be loaded by Credo before running the analysis.
</span></span><span class="line"><span class="ln">21</span><span class="cl">        requires: [],
</span></span><span class="line"><span class="ln">22</span><span class="cl">        #
</span></span><span class="line"><span class="ln">23</span><span class="cl">        # Credo automatically checks for updates, like e.g. Hex does.
</span></span><span class="line"><span class="ln">24</span><span class="cl">        # You can disable this behaviour below:
</span></span><span class="line"><span class="ln">25</span><span class="cl">        check_for_updates: true,
</span></span><span class="line"><span class="ln">26</span><span class="cl">        #
</span></span><span class="line"><span class="ln">27</span><span class="cl">        # If you want to enforce a style guide and need a more traditional linting
</span></span><span class="line"><span class="ln">28</span><span class="cl">        # experience, you can change `strict` to `true` below:
</span></span><span class="line"><span class="ln">29</span><span class="cl">        strict: true,
</span></span><span class="line"><span class="ln">30</span><span class="cl">        #
</span></span><span class="line"><span class="ln">31</span><span class="cl">        # If you want to use uncolored output by default, you can change `color`
</span></span><span class="line"><span class="ln">32</span><span class="cl">        # to `false` below:
</span></span><span class="line"><span class="ln">33</span><span class="cl">        color: true,
</span></span><span class="line"><span class="ln">34</span><span class="cl">        #
</span></span><span class="line"><span class="ln">35</span><span class="cl">        # You can customize the parameters of any check by adding a second element
</span></span><span class="line"><span class="ln">36</span><span class="cl">        # to the tuple.
</span></span><span class="line"><span class="ln">37</span><span class="cl">        #
</span></span><span class="line"><span class="ln">38</span><span class="cl">        # To disable a check put `false` as second element:
</span></span><span class="line"><span class="ln">39</span><span class="cl">        #
</span></span><span class="line"><span class="ln">40</span><span class="cl">        #     {Credo.Check.Design.DuplicatedCode, false}
</span></span><span class="line"><span class="ln">41</span><span class="cl">        #
</span></span><span class="line"><span class="ln">42</span><span class="cl">        checks: [
</span></span><span class="line"><span class="ln">43</span><span class="cl">          {Credo.Check.Readability.Specs, priority: :low},
</span></span><span class="line"><span class="ln">44</span><span class="cl">          {Credo.Check.Design.TagTODO, exit_status: 0},
</span></span><span class="line"><span class="ln">45</span><span class="cl">          {Credo.Check.Design.TagFIXME, exit_status: 0},
</span></span><span class="line"><span class="ln">46</span><span class="cl">          {Credo.Check.Readability.MaxLineLength, priority: :low, max_length: 100}
</span></span><span class="line"><span class="ln">47</span><span class="cl">        ]
</span></span><span class="line"><span class="ln">48</span><span class="cl">      }
</span></span><span class="line"><span class="ln">49</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">50</span><span class="cl">  }</span></span></code></pre></div><p>After that, it would be nice to force these settings by running Credo
mix task with <code>--strict</code> option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix credo --strict</span></span></code></pre></div><h2 id="xref">Xref</h2>
<p>Elixir has a <code>mix xref</code> task that performs cross-reference checks
between modules. This check can print all unavailable or deprecated
references, create a dependencies graph and show callers of the given
function. During the CI we want to check if we have any unavailable or
deprecated functions/modules:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix xref unavailable
</span></span><span class="line"><span class="ln">2</span><span class="cl">  mix xref deprecated</span></span></code></pre></div><p>Don&rsquo;t forget to include <code>--include-siblings</code> option if you are using
this in umbrella application.</p>
<h2 id="sobelow">Sobelow</h2>
<p><a href="https://github.com/nccgroup/sobelow">Sobelow</a> is a security-based
static analysis tool. Unfortunately, it comes just for the Phoenix
framework, so you can use it only in your web applications. Sobelow can
detect the following types of security issues:</p>
<ul>
<li>Insecure configuration</li>
<li>Known-vulnerable Dependencies</li>
<li>Cross-Site Scripting</li>
<li>SQL injection</li>
<li>Command injection</li>
<li>Denial of Service</li>
<li>Directory traversal</li>
<li>Unsafe serialization</li>
</ul>
<p>To install Sobelow you can use the next command:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix archive.install hex sobelow</span></span></code></pre></div><p>To run Sobelow just start the related mix task:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix sobelow</span></span></code></pre></div><h2 id="dialyzer">Dialyzer</h2>
<p><a href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a> is the most
powerful and yet complex analysis tool for the BEAM platform. Dialyzer
means DIscrepancy AnaLYZer for ERlang programs, but it could be used in
Elixir too. It identifies software discrepancies like definite type
errors, dead or unreachable code.</p>
<p>To use Dialyzer in your Elixir application you may want to use
<a href="identifies%20software%20discrepancies">Dialyxir</a>. Just add this
line to your <code>mix.exs</code> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp deps do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [{:dialyxir, &#34;~&gt; 0.5&#34;, only: [:dev], runtime: false}]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>You can also configure warnings, dependencies and paths in <code>mix.exs</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [
</span></span><span class="line"><span class="ln">3</span><span class="cl">    dialyzer: [plt_add_deps: :apps_direct, plt_add_apps: [:wx]]
</span></span><span class="line"><span class="ln">4</span><span class="cl">    # flags: [&#34;-Wunmatched_returns&#34;, :error_handling, :race_conditions, :underspecs]
</span></span><span class="line"><span class="ln">5</span><span class="cl">    # paths: [&#34;_build/dev/lib/my_app/ebin&#34;, &#34;_build/dev/lib/foo/ebin&#34;]
</span></span><span class="line"><span class="ln">6</span><span class="cl">      ]
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>You can ignore any unwanted warnings by providing <code>ignore_warnings</code>
option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [dialyzer: [ignore_warnings: &#34;dialyzer.ignore-warnings&#34;]]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>To run dialyzer on the CI add the next option to make sure that the
build fails in case of any errors:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix dialyzer --halt-exit-status</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>As you can see, Elixir by itself and by its ecosystem has many useful
checks and tools that allow you to keep your code nice, simple, robust
and consistent. These checks are also highly configurable and
extensible. You can easily use them for any CI platforms to keep your
development workflow bright and shiny.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Elixir code quality tools and checks</title>
      <link>https://neiro.io/posts/2018-04-28-elixir-code-quality-tools-and-checks.md/</link>
      <pubDate>Sat, 28 Apr 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2018-04-28-elixir-code-quality-tools-and-checks.md/</guid>
      <description>&lt;p&gt;Elixir programming language has its great, huge community and ecosystem.&#xA;As for now, we can easily do static code analysis and code quality&#xA;checks by using plenty of standard or external tools. This allows us to&#xA;write robust solid Elixir code in a uniform way according to the&#xA;&lt;a href=&#34;https://github.com/christopheradams/elixir_style_guide&#34;&gt;style guide&lt;/a&gt;&#xA;.&lt;/p&gt;&#xA;&lt;p&gt;Let&amp;rsquo;s start with the most popular tools and solutions:&lt;/p&gt;&#xA;&lt;h2 id=&#34;mix-compile-warnings-as-errors&#34;&gt;mix compile &amp;ndash;warnings-as-errors&lt;/h2&gt;&#xA;&lt;p&gt;The first and the simplest check that could possibly exist. Elixir&#xA;compiler is smart enough to detect easily harsh mistakes like unused&#xA;variables or mismatched module names. At the same time it is pretty&#xA;friendly, because compiler just warns you about these problems, but does&#xA;not stop compilation. For some reasons, especially if we are running the&#xA;CI, we want to make it more obvious and stop any further checks. This&#xA;can be achieved by running &lt;code&gt;mix compile&lt;/code&gt; task with related option:&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Elixir programming language has its great, huge community and ecosystem.
As for now, we can easily do static code analysis and code quality
checks by using plenty of standard or external tools. This allows us to
write robust solid Elixir code in a uniform way according to the
<a href="https://github.com/christopheradams/elixir_style_guide">style guide</a>
.</p>
<p>Let&rsquo;s start with the most popular tools and solutions:</p>
<h2 id="mix-compile-warnings-as-errors">mix compile &ndash;warnings-as-errors</h2>
<p>The first and the simplest check that could possibly exist. Elixir
compiler is smart enough to detect easily harsh mistakes like unused
variables or mismatched module names. At the same time it is pretty
friendly, because compiler just warns you about these problems, but does
not stop compilation. For some reasons, especially if we are running the
CI, we want to make it more obvious and stop any further checks. This
can be achieved by running <code>mix compile</code> task with related option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix compile --warnings-as-errors</span></span></code></pre></div><h2 id="mix-format-check-formatted">mix format &ndash;check-formatted</h2>
<p>Elixir 1.6 introduced yet another useful tool - the formatter. After
that we can keep our codebase consistent in one uniform code style
without any contradictions. However, in the real life, not everyone uses
the formatter and we need to force this option by running <code>mix format</code>
task with the <code>--check-formatted</code> option during CI.</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix format --check-formatted</span></span></code></pre></div><h2 id="credo">Credo</h2>
<p><a href="https://github.com/rrrene/credo">Credo</a> is a static analysis code
tool for Elixir. It&rsquo;s more than just a usual code checker - it can teach
you how to write your code better, show refactoring possibilities and
inconsistencies in naming.</p>
<p>In order to start using Credo you need to add this line to your
<code>mix.exs</code> deps:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  {:credo, &#34;~&gt; 0.9.1&#34;, only: ~w(dev test)a, runtime: false}</span></span></code></pre></div><p>You can enforce your own code style for your team by using Credo
configuration file. For example, you can create <code>config/.credo.exs</code> file
with this content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  %{
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    #
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    # You can have as many configs as you like in the `configs:` field.
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    configs: [
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      %{
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        #
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        # Run any exec using `mix credo -C &lt;name&gt;`. If no exec name is given
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # &#34;default&#34; is used.
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        name: &#34;default&#34;,
</span></span><span class="line"><span class="ln">10</span><span class="cl">        #
</span></span><span class="line"><span class="ln">11</span><span class="cl">        # These are the files included in the analysis:
</span></span><span class="line"><span class="ln">12</span><span class="cl">        files: %{
</span></span><span class="line"><span class="ln">13</span><span class="cl">          #
</span></span><span class="line"><span class="ln">14</span><span class="cl">          # You can give explicit globs or simply directories.
</span></span><span class="line"><span class="ln">15</span><span class="cl">          # In the latter case `**/*.{ex,exs}` will be used.
</span></span><span class="line"><span class="ln">16</span><span class="cl">          excluded: [~r&#34;/_build/&#34;, ~r&#34;/deps/&#34;, ~r&#34;/priv/&#34;]
</span></span><span class="line"><span class="ln">17</span><span class="cl">        },
</span></span><span class="line"><span class="ln">18</span><span class="cl">        #
</span></span><span class="line"><span class="ln">19</span><span class="cl">        # If you create your own checks, you must specify the source files for
</span></span><span class="line"><span class="ln">20</span><span class="cl">        # them here, so they can be loaded by Credo before running the analysis.
</span></span><span class="line"><span class="ln">21</span><span class="cl">        requires: [],
</span></span><span class="line"><span class="ln">22</span><span class="cl">        #
</span></span><span class="line"><span class="ln">23</span><span class="cl">        # Credo automatically checks for updates, like e.g. Hex does.
</span></span><span class="line"><span class="ln">24</span><span class="cl">        # You can disable this behaviour below:
</span></span><span class="line"><span class="ln">25</span><span class="cl">        check_for_updates: true,
</span></span><span class="line"><span class="ln">26</span><span class="cl">        #
</span></span><span class="line"><span class="ln">27</span><span class="cl">        # If you want to enforce a style guide and need a more traditional linting
</span></span><span class="line"><span class="ln">28</span><span class="cl">        # experience, you can change `strict` to `true` below:
</span></span><span class="line"><span class="ln">29</span><span class="cl">        strict: true,
</span></span><span class="line"><span class="ln">30</span><span class="cl">        #
</span></span><span class="line"><span class="ln">31</span><span class="cl">        # If you want to use uncolored output by default, you can change `color`
</span></span><span class="line"><span class="ln">32</span><span class="cl">        # to `false` below:
</span></span><span class="line"><span class="ln">33</span><span class="cl">        color: true,
</span></span><span class="line"><span class="ln">34</span><span class="cl">        #
</span></span><span class="line"><span class="ln">35</span><span class="cl">        # You can customize the parameters of any check by adding a second element
</span></span><span class="line"><span class="ln">36</span><span class="cl">        # to the tuple.
</span></span><span class="line"><span class="ln">37</span><span class="cl">        #
</span></span><span class="line"><span class="ln">38</span><span class="cl">        # To disable a check put `false` as second element:
</span></span><span class="line"><span class="ln">39</span><span class="cl">        #
</span></span><span class="line"><span class="ln">40</span><span class="cl">        #     {Credo.Check.Design.DuplicatedCode, false}
</span></span><span class="line"><span class="ln">41</span><span class="cl">        #
</span></span><span class="line"><span class="ln">42</span><span class="cl">        checks: [
</span></span><span class="line"><span class="ln">43</span><span class="cl">          {Credo.Check.Readability.Specs, priority: :low},
</span></span><span class="line"><span class="ln">44</span><span class="cl">          {Credo.Check.Design.TagTODO, exit_status: 0},
</span></span><span class="line"><span class="ln">45</span><span class="cl">          {Credo.Check.Design.TagFIXME, exit_status: 0},
</span></span><span class="line"><span class="ln">46</span><span class="cl">          {Credo.Check.Readability.MaxLineLength, priority: :low, max_length: 100}
</span></span><span class="line"><span class="ln">47</span><span class="cl">        ]
</span></span><span class="line"><span class="ln">48</span><span class="cl">      }
</span></span><span class="line"><span class="ln">49</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">50</span><span class="cl">  }</span></span></code></pre></div><p>After that, it would be nice to force these settings by running Credo
mix task with <code>--strict</code> option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix credo --strict</span></span></code></pre></div><h2 id="xref">Xref</h2>
<p>Elixir has a <code>mix xref</code> task that performs cross-reference checks
between modules. This check can print all unavailable or deprecated
references, create a dependencies graph and show callers of the given
function. During the CI we want to check if we have any unavailable or
deprecated functions/modules:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix xref unavailable
</span></span><span class="line"><span class="ln">2</span><span class="cl">  mix xref deprecated</span></span></code></pre></div><p>Don&rsquo;t forget to include <code>--include-siblings</code> option if you are using
this in umbrella application.</p>
<h2 id="sobelow">Sobelow</h2>
<p><a href="https://github.com/nccgroup/sobelow">Sobelow</a> is a security-based
static analysis tool. Unfortunately, it comes just for the Phoenix
framework, so you can use it only in your web applications. Sobelow can
detect the following types of security issues:</p>
<ul>
<li>Insecure configuration</li>
<li>Known-vulnerable Dependencies</li>
<li>Cross-Site Scripting</li>
<li>SQL injection</li>
<li>Command injection</li>
<li>Denial of Service</li>
<li>Directory traversal</li>
<li>Unsafe serialization</li>
</ul>
<p>To install Sobelow you can use the next command:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix archive.install hex sobelow</span></span></code></pre></div><p>To run Sobelow just start the related mix task:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix sobelow</span></span></code></pre></div><h2 id="dialyzer">Dialyzer</h2>
<p><a href="http://erlang.org/doc/man/dialyzer.html">Dialyzer</a> is the most
powerful and yet complex analysis tool for the BEAM platform. Dialyzer
means DIscrepancy AnaLYZer for ERlang programs, but it could be used in
Elixir too. It identifies software discrepancies like definite type
errors, dead or unreachable code.</p>
<p>To use Dialyzer in your Elixir application you may want to use
<a href="identifies%20software%20discrepancies">Dialyxir</a>. Just add this
line to your <code>mix.exs</code> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp deps do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [{:dialyxir, &#34;~&gt; 0.5&#34;, only: [:dev], runtime: false}]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>You can also configure warnings, dependencies and paths in <code>mix.exs</code>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [
</span></span><span class="line"><span class="ln">3</span><span class="cl">    dialyzer: [plt_add_deps: :apps_direct, plt_add_apps: [:wx]]
</span></span><span class="line"><span class="ln">4</span><span class="cl">    # flags: [&#34;-Wunmatched_returns&#34;, :error_handling, :race_conditions, :underspecs]
</span></span><span class="line"><span class="ln">5</span><span class="cl">    # paths: [&#34;_build/dev/lib/my_app/ebin&#34;, &#34;_build/dev/lib/foo/ebin&#34;]
</span></span><span class="line"><span class="ln">6</span><span class="cl">      ]
</span></span><span class="line"><span class="ln">7</span><span class="cl">  end</span></span></code></pre></div><p>You can ignore any unwanted warnings by providing <code>ignore_warnings</code>
option:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  def project do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    [dialyzer: [ignore_warnings: &#34;dialyzer.ignore-warnings&#34;]]
</span></span><span class="line"><span class="ln">3</span><span class="cl">  end</span></span></code></pre></div><p>To run dialyzer on the CI add the next option to make sure that the
build fails in case of any errors:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mix dialyzer --halt-exit-status</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>As you can see, Elixir by itself and by its ecosystem has many useful
checks and tools that allow you to keep your code nice, simple, robust
and consistent. These checks are also highly configurable and
extensible. You can easily use them for any CI platforms to keep your
development workflow bright and shiny.</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
