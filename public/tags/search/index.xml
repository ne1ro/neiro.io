<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Search on neiro blog</title>
    <link>https://neiro.io/tags/search/</link>
    <description>Recent content in Search on neiro blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <copyright>neiro Â© 2012-2025</copyright>
    <lastBuildDate>Sun, 21 Jan 2018 10:00:00 +0100</lastBuildDate>
    <atom:link href="https://neiro.io/tags/search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Postgres full-text search using Ecto</title>
      <link>https://neiro.io/blog/2018-01-21-postgres-full-text-search-using-ecto.md/</link>
      <pubDate>Sun, 21 Jan 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/blog/2018-01-21-postgres-full-text-search-using-ecto.md/</guid>
      <description>&lt;p&gt;PostgreSQL is one of the most popular, stable and common relational&#xA;database. It&amp;rsquo;s widely used in Elixir infrastructure and has a great&#xA;integration with Ecto library.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re into web development you can often face the search problem.&#xA;You have a large stable database, you have tons of useful information,&#xA;great tools, but your users desire to find something by arbitrary&#xA;questions. You can&amp;rsquo;t use your favourite plain SELECT &amp;hellip; WHERE &amp;hellip;&#xA;queries because you need to search for the words, not columns or&#xA;records.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Postgres full-text search using Ecto</title>
      <link>https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/</link>
      <pubDate>Sun, 21 Jan 2018 10:00:00 +0100</pubDate>
      <guid>https://neiro.io/posts/2018-01-21-postgres-full-text-search-using-ecto.md/</guid>
      <description>&lt;p&gt;PostgreSQL is one of the most popular, stable and common relational&#xA;database. It&amp;rsquo;s widely used in Elixir infrastructure and has a great&#xA;integration with Ecto library.&lt;/p&gt;&#xA;&lt;p&gt;If you&amp;rsquo;re into web development you can often face the search problem.&#xA;You have a large stable database, you have tons of useful information,&#xA;great tools, but your users desire to find something by arbitrary&#xA;questions. You can&amp;rsquo;t use your favourite plain SELECT &amp;hellip; WHERE &amp;hellip;&#xA;queries because you need to search for the words, not columns or&#xA;records.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>PostgreSQL is one of the most popular, stable and common relational
database. It&rsquo;s widely used in Elixir infrastructure and has a great
integration with Ecto library.</p>
<p>If you&rsquo;re into web development you can often face the search problem.
You have a large stable database, you have tons of useful information,
great tools, but your users desire to find something by arbitrary
questions. You can&rsquo;t use your favourite plain SELECT &hellip; WHERE &hellip;
queries because you need to search for the words, not columns or
records.</p>
<p>This if what the full text search stands for.</p>
<p>Fortunately, PostgreSQL has a built-in support of the full-text search.
It allows you to parse your data into tokens, convert these tokens to
lexemes - normalised forms of words - and, finally, search and make
search optimisations.</p>
<h2 id="ecto-migration-to-use-the-search">Ecto migration to use the search</h2>
<p>Let&rsquo;s start by creating a migration. Create a new Elixir project and a
new migration in priv/repo/migrations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">13</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">14</span><span class="cl">    end
</span></span><span class="line"><span class="ln">15</span><span class="cl">  end</span></span></code></pre></div><p>As you can see, we will use PostgreSQL extension called pg_trgm. Run
ecto.migrate to execute this migration. Now you can use trigram indices
and trigram matching for your full-text search.</p>
<h2 id="create-a-search-module">Create a search module</h2>
<p>Our next step will be creating a search module. Let&rsquo;s suppose that you
already have a User schema with a username, first name and last name
defined. In that case we can implement a simple search query that can be
used in your contexts or controllers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Users.Search do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Implementation of the full-text user search
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    import Ecto.Query
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    @spec run(Ecto.Query.t(), any()) :: Ecto.Query.t()
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    def run(query, search_term) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end
</span></span><span class="line"><span class="ln">11</span><span class="cl">  end</span></span></code></pre></div><p>As you can see here, we&rsquo;re defining the run function that will accept
another Ecto.Query with the search term and will return Ecto.Query
though.</p>
<p>We need to escape all of non-words characters from user&rsquo;s input:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  String.replace(term, ~r/\W/u, &#34;&#34;)</span></span></code></pre></div><p>Also we need to allow to search by prefix - beginning of the word. Let&rsquo;s
add :* to our search term*:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defp prefix_search(term), do: String.replace(term, ~r/\W/u, &#34;&#34;) &lt;&gt; &#34;:*&#34;</span></span></code></pre></div><p>Now we need to implement the search by using Ecto&rsquo;s fragment macro and
to_tsquery PostgreSQL function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  def run(query, search_term) do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">      where(
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">        query,
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">        fragment(
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">          &#34;to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">          to_tsquery(?)&#34;,
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          ^prefix_search(search_term)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        )
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      )
</span></span><span class="line"><span class="ln">10</span><span class="cl">    end</span></span></code></pre></div><p>Let&rsquo;s take a look at the implementation. At first, we need to compose a
search token by joining columns:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  to_tsvector(&#39;english&#39;, username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)) @@ to_tsquery(?)</span></span></code></pre></div><p>Created tsvector will be tested by operator @@ with tsquery and will
return the result if the matching was sucessful.</p>
<p>But this result won&rsquo;t be as fast as we wanted. Let&rsquo;s suppose that we
have <em>11K</em> users:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Filter: (to_tsvector(&#39;english&#39;::regconfig,
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text)
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  || (COALESCE(last_name, &#39; &#39;::character varying))::text)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Rows Removed by Filter: 11285
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Planning time: 1.640 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  Execution time: 62.235 ms
</span></span><span class="line"><span class="ln">12</span><span class="cl">  ###</span></span></code></pre></div><h2 id="create-an-index">Create an index</h2>
<p>Auspiciously, we have opportunity to use the PostgreSQL trigram index in
order to improve performance of full-text queries. Let&rsquo;s modify our
transaction:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  defmodule App.Repo.Migrations.IntroducePgSearch do
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    @moduledoc &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    Create postgres extension and indices
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    &#34;&#34;&#34;
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    use Ecto.Migration
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    def up do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">      execute(&#34;CREATE EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">      execute(&#34;&#34;&#34;
</span></span><span class="line"><span class="ln">12</span><span class="cl">      CREATE INDEX users_trgm_idx ON users USING GIN (to_tsvector(&#39;english&#39;,
</span></span><span class="line"><span class="ln">13</span><span class="cl">        username || &#39; &#39; || first_name || &#39; &#39; || coalesce(last_name, &#39; &#39;)))
</span></span><span class="line"><span class="ln">14</span><span class="cl">      &#34;&#34;&#34;)
</span></span><span class="line"><span class="ln">15</span><span class="cl">    end
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">    def down do
</span></span><span class="line"><span class="ln">18</span><span class="cl">      execute(&#34;DROP INDEX users_trgm_idx&#34;)
</span></span><span class="line"><span class="ln">19</span><span class="cl">      execute(&#34;DROP EXTENSION pg_trgm&#34;)
</span></span><span class="line"><span class="ln">20</span><span class="cl">    end
</span></span><span class="line"><span class="ln">21</span><span class="cl">  end</span></span></code></pre></div><p>Now run mix do ecto.rollback, eco.migrate and try to run the search:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  User |&gt; App.Users.Search.run(&#34;meta&#34;) |&gt; Repo.explain
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  ###
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  Recheck Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    Heap Blocks: exact=57
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    -&gt;  Bitmap Index Scan on users_trgm_idx  (cost=0.00..20.74 rows=65 width=0) (actual time=0.093..0.093 rows=65 loops=1)
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">          Index Cond: (to_tsvector(&#39;english&#39;::regconfig, (((((username)::text || &#39; &#39;::text) || (first_name)::text) || &#39; &#39;::text) || (COALESCE(last_name, &#39; &#39;::character varying))::text)) @@ to_tsquery(&#39;meta:*&#39;::text))
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  Planning time: 1.348 ms
</span></span><span class="line"><span class="ln">10</span><span class="cl">  Execution time: 0.457 ms
</span></span><span class="line"><span class="ln">11</span><span class="cl">  ###</span></span></code></pre></div><p>Voila! Now that&rsquo;s the speed we wanted. Our users will be so happy with
this search!</p>
<h2 id="conclusion">Conclusion</h2>
<p>What&rsquo;s next? You can try using the functionality of pg_trgm module,
search for similar words or making the search not just prefix-only. See
the docs for
<a href="https://www.postgresql.org/docs/10/static/textsearch.html">PostgreSQL
full-text search</a> and
<a href="https://www.postgresql.org/docs/10/static/pgtrgm.html">trigram</a> .</p>
<p>Happy hacking!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
