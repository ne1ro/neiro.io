<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Testing on neiro blog</title>
    <link>https://neiro.io/tags/testing/</link>
    <description>Recent content in Testing on neiro blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <copyright>neiro Â© 2012-2025</copyright>
    <lastBuildDate>Sun, 29 Jul 2018 10:00:00 +0200</lastBuildDate>
    <atom:link href="https://neiro.io/tags/testing/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Asynchronous testing in Elixir with Mox</title>
      <link>https://neiro.io/blog/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</link>
      <pubDate>Sun, 29 Jul 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</guid>
      <description>&lt;p&gt;Testing in Elixir is pretty neat. You can easily test anything written,&#xA;you have instruments like ExUnit or ESpec, you can&#xA;&lt;a href=&#34;https://github.com/lpil/mix-test.watch&#34;&gt;practice TDD&lt;/a&gt; and more and&#xA;more. Functional programming paradigm helps you a lot to make your&#xA;testing even simpler by forcing you to use pure, small functions that&#xA;will be pleasant to test. Concurrency of Elixir allows you to run all&#xA;your tests asynchronously and blazingly fast.&lt;/p&gt;&#xA;&lt;p&gt;However, there can be some pitfalls.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Testing in Elixir is pretty neat. You can easily test anything written,
you have instruments like ExUnit or ESpec, you can
<a href="https://github.com/lpil/mix-test.watch">practice TDD</a> and more and
more. Functional programming paradigm helps you a lot to make your
testing even simpler by forcing you to use pure, small functions that
will be pleasant to test. Concurrency of Elixir allows you to run all
your tests asynchronously and blazingly fast.</p>
<p>However, there can be some pitfalls.</p>
<h2 id="mocks-problem">Mocks problem</h2>
<p>If you&rsquo;re programming a big project then I suppose that you will be
using third-party services anyway. Imagine that you are sending SMS
through you favorite provider services. This code can look like that:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>In this case you are using some external provider API in order to send
SMS. The HTTP request will go from your application to the destination
and it will trigger SMS delivery.</p>
<p>Now we need to test this situation. This will be our very first
approach:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>As you can see it will behave as if it was on production. Your SMS with
the nasty fake test message will be delivered to non-existent users with
absent phone numbers. Sad!</p>
<p>The most popular solution is mocking. You&rsquo;re supposing that call of
<code>send_sms</code> function with the expected arguments which will return the
expected result:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mock(SmsProvider, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}} end)
</span></span><span class="line"><span class="ln">2</span><span class="cl">  assert {:ok, %Message{status: :sent}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>This approach will work, at least for this test. The problem is simple
enough - it&rsquo;s not the best solution for asynchronous tests. We have
mocked SmsProvider so it will be overriden in every next asynchronous
test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  use MyApp.DataCase, async: true
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  # ...
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  assert {:error, :wrong_phone_number} = SmsProvider.send_sms(wrong_number, to, &#34;message&#34;)</span></span></code></pre></div><p>This test will fail because <code>send_sms</code> call was already mocked in
another test earlier. The entire mocking approach is not suitable for
concurrent testing, so we need to find another one to serve this
purpose.</p>
<h2 id="asynchronous-testing">Asynchronous testing</h2>
<p>Instead of mocking we can try calling the function that will override
<code>sms_send/3</code>. Let&rsquo;s create a <code>TestProvider</code> module with the next
content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def send_sms(from, to, message) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, %Message{status: :sent, from: from, to: to, text: message}}
</span></span><span class="line"><span class="ln">4</span><span class="cl">    end
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end</span></span></code></pre></div><p>Now we can try to use this module as an adapter in our <code>SmsProvider</code>
module. It will use default adapter in development, production
environments and will use <code>TestProvider</code> in testing:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # config/test.exs
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  config :my_app, SmsProvider, adapter: TestProvider
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  # config/config.exs
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  config :my_app, SmsProvider, adapter: SmsApiService
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @adapter Application.fetch_env(:my_app, :sms_provider, :adapter)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    defdelegate send_sms(from, to, message), to: @adapter
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end</span></span></code></pre></div><p>Let&rsquo;s go straight to the test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;) # true</span></span></code></pre></div><p>Now it should work even in concurrent tests. Your SMS will not be
delivered neither to the real nor fake users, your money will be saved
and your tests will not suffer more.</p>
<h2 id="using-mox">Using Mox</h2>
<p>However, there is still a room for improvement.</p>
<p><a href="https://github.com/plataformatec/mox">Mox</a> is a relatively new
library that solves the issue of concurrent testing and mocks. It
follows the next principles:</p>
<ul>
<li>You can only create mocks based on behaviours</li>
<li>No dynamic generation of mocked modules, every mock should be defined
in tests</li>
<li>Full concurrency support</li>
<li>Use of pattern matching and function clauses for asserting</li>
</ul>
<p>Now let&rsquo;s add it to our dependencies list:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  # mix.exs
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def deps do
</span></span><span class="line"><span class="ln">3</span><span class="cl">    [
</span></span><span class="line"><span class="ln">4</span><span class="cl">      {:mox, &#34;~&gt; 0.4&#34;, only: :test}
</span></span><span class="line"><span class="ln">5</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  end</span></span></code></pre></div><p>It&rsquo;s easy as a pie to rewrite our tests with Mox. We need to create an
SMS provider behaviour and implement it for different environments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  # test_helper.exs
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  Mox.defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">  defmodule Test do
</span></span><span class="line"><span class="ln">12</span><span class="cl">    use ExUnit.Case, async: true
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    import Mox
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    # Make sure mocks are verified when the test exits
</span></span><span class="line"><span class="ln">17</span><span class="cl">    setup :verify_on_exit!
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    test &#34;returns message on success&#34; do
</span></span><span class="line"><span class="ln">20</span><span class="cl">      expect SmsProviderMock, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}}
</span></span><span class="line"><span class="ln">21</span><span class="cl">      assert {:ok, %{status: :sent}} = SmsProvider.send_sms(from, to, message)
</span></span><span class="line"><span class="ln">22</span><span class="cl">    end
</span></span><span class="line"><span class="ln">23</span><span class="cl">  end</span></span></code></pre></div><p>If you don&rsquo;t need to check expectations in test you can try
<code>stub_with/2</code> function in order to stub entire module:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @callback sent_sms(String.t) :: [%Message{}]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # test_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @behaviour SmsProvider
</span></span><span class="line"><span class="ln">10</span><span class="cl">    def send_sms(_from, _to, message), do: {:ok, %Message{status: :sent, message: message}}
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def sent_sms(number) :: [%Message{}]
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">15</span><span class="cl">  defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  stub_with(SmsProviderMock, TestProvider)</span></span></code></pre></div><p>Viola! Now your tests are all green, fast and shiny thanks to concurrent
testing and Mox :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>If you&rsquo;re definitely interested in concurrent testing, you might want to
read
<a href="http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/">excellent
article from Jose Valim</a> and dive in into
<a href="https://hexdocs.pm/mox/Mox.html">Mox documentation</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Asynchronous testing in Elixir with Mox</title>
      <link>https://neiro.io/posts/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</link>
      <pubDate>Sun, 29 Jul 2018 10:00:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2018-07-29-asyncronous-testing-in-elixir-with-mox.md/</guid>
      <description>&lt;p&gt;Testing in Elixir is pretty neat. You can easily test anything written,&#xA;you have instruments like ExUnit or ESpec, you can&#xA;&lt;a href=&#34;https://github.com/lpil/mix-test.watch&#34;&gt;practice TDD&lt;/a&gt; and more and&#xA;more. Functional programming paradigm helps you a lot to make your&#xA;testing even simpler by forcing you to use pure, small functions that&#xA;will be pleasant to test. Concurrency of Elixir allows you to run all&#xA;your tests asynchronously and blazingly fast.&lt;/p&gt;&#xA;&lt;p&gt;However, there can be some pitfalls.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>Testing in Elixir is pretty neat. You can easily test anything written,
you have instruments like ExUnit or ESpec, you can
<a href="https://github.com/lpil/mix-test.watch">practice TDD</a> and more and
more. Functional programming paradigm helps you a lot to make your
testing even simpler by forcing you to use pure, small functions that
will be pleasant to test. Concurrency of Elixir allows you to run all
your tests asynchronously and blazingly fast.</p>
<p>However, there can be some pitfalls.</p>
<h2 id="mocks-problem">Mocks problem</h2>
<p>If you&rsquo;re programming a big project then I suppose that you will be
using third-party services anyway. Imagine that you are sending SMS
through you favorite provider services. This code can look like that:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>In this case you are using some external provider API in order to send
SMS. The HTTP request will go from your application to the destination
and it will trigger SMS delivery.</p>
<p>Now we need to test this situation. This will be our very first
approach:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>As you can see it will behave as if it was on production. Your SMS with
the nasty fake test message will be delivered to non-existent users with
absent phone numbers. Sad!</p>
<p>The most popular solution is mocking. You&rsquo;re supposing that call of
<code>send_sms</code> function with the expected arguments which will return the
expected result:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  mock(SmsProvider, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}} end)
</span></span><span class="line"><span class="ln">2</span><span class="cl">  assert {:ok, %Message{status: :sent}} = SmsProvider.send_sms(from, to, &#34;message&#34;)</span></span></code></pre></div><p>This approach will work, at least for this test. The problem is simple
enough - it&rsquo;s not the best solution for asynchronous tests. We have
mocked SmsProvider so it will be overriden in every next asynchronous
test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  use MyApp.DataCase, async: true
</span></span><span class="line"><span class="ln">2</span><span class="cl">
</span></span><span class="line"><span class="ln">3</span><span class="cl">  # ...
</span></span><span class="line"><span class="ln">4</span><span class="cl">
</span></span><span class="line"><span class="ln">5</span><span class="cl">  assert {:error, :wrong_phone_number} = SmsProvider.send_sms(wrong_number, to, &#34;message&#34;)</span></span></code></pre></div><p>This test will fail because <code>send_sms</code> call was already mocked in
another test earlier. The entire mocking approach is not suitable for
concurrent testing, so we need to find another one to serve this
purpose.</p>
<h2 id="asynchronous-testing">Asynchronous testing</h2>
<p>Instead of mocking we can try calling the function that will override
<code>sms_send/3</code>. Let&rsquo;s create a <code>TestProvider</code> module with the next
content:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def send_sms(from, to, message) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, %Message{status: :sent, from: from, to: to, text: message}}
</span></span><span class="line"><span class="ln">4</span><span class="cl">    end
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end</span></span></code></pre></div><p>Now we can try to use this module as an adapter in our <code>SmsProvider</code>
module. It will use default adapter in development, production
environments and will use <code>TestProvider</code> in testing:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # config/test.exs
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  config :my_app, SmsProvider, adapter: TestProvider
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  # config/config.exs
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  config :my_app, SmsProvider, adapter: SmsApiService
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @adapter Application.fetch_env(:my_app, :sms_provider, :adapter)
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">    defdelegate send_sms(from, to, message), to: @adapter
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end</span></span></code></pre></div><p>Let&rsquo;s go straight to the test:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  assert {:ok, %Message{}} = SmsProvider.send_sms(from, to, &#34;message&#34;) # true</span></span></code></pre></div><p>Now it should work even in concurrent tests. Your SMS will not be
delivered neither to the real nor fake users, your money will be saved
and your tests will not suffer more.</p>
<h2 id="using-mox">Using Mox</h2>
<p>However, there is still a room for improvement.</p>
<p><a href="https://github.com/plataformatec/mox">Mox</a> is a relatively new
library that solves the issue of concurrent testing and mocks. It
follows the next principles:</p>
<ul>
<li>You can only create mocks based on behaviours</li>
<li>No dynamic generation of mocked modules, every mock should be defined
in tests</li>
<li>Full concurrency support</li>
<li>Use of pattern matching and function clauses for asserting</li>
</ul>
<p>Now let&rsquo;s add it to our dependencies list:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  # mix.exs
</span></span><span class="line"><span class="ln">2</span><span class="cl">  def deps do
</span></span><span class="line"><span class="ln">3</span><span class="cl">    [
</span></span><span class="line"><span class="ln">4</span><span class="cl">      {:mox, &#34;~&gt; 0.4&#34;, only: :test}
</span></span><span class="line"><span class="ln">5</span><span class="cl">    ]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  end</span></span></code></pre></div><p>It&rsquo;s easy as a pie to rewrite our tests with Mox. We need to create an
SMS provider behaviour and implement it for different environments:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  # test_helper.exs
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  Mox.defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">10</span><span class="cl">
</span></span><span class="line"><span class="ln">11</span><span class="cl">  defmodule Test do
</span></span><span class="line"><span class="ln">12</span><span class="cl">    use ExUnit.Case, async: true
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    import Mox
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">    # Make sure mocks are verified when the test exits
</span></span><span class="line"><span class="ln">17</span><span class="cl">    setup :verify_on_exit!
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">    test &#34;returns message on success&#34; do
</span></span><span class="line"><span class="ln">20</span><span class="cl">      expect SmsProviderMock, :send_sms, fn _, _, _ -&gt; {:ok, %Message{status: :sent}}
</span></span><span class="line"><span class="ln">21</span><span class="cl">      assert {:ok, %{status: :sent}} = SmsProvider.send_sms(from, to, message)
</span></span><span class="line"><span class="ln">22</span><span class="cl">    end
</span></span><span class="line"><span class="ln">23</span><span class="cl">  end</span></span></code></pre></div><p>If you don&rsquo;t need to check expectations in test you can try
<code>stub_with/2</code> function in order to stub entire module:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">  # sms_provider.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  defmodule SmsProvider do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    @callback send_sms(String.t, String.t, String.t) :: {:ok, %Message{}} | {:error, :wrong_number}
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    @callback sent_sms(String.t) :: [%Message{}]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  end
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  # test_provider.ex
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">  defmodule TestProvider do
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    @behaviour SmsProvider
</span></span><span class="line"><span class="ln">10</span><span class="cl">    def send_sms(_from, _to, message), do: {:ok, %Message{status: :sent, message: message}}
</span></span><span class="line"><span class="ln">11</span><span class="cl">    def sent_sms(number) :: [%Message{}]
</span></span><span class="line"><span class="ln">12</span><span class="cl">  end
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  # test.exs
</span></span><span class="line"><span class="ln">15</span><span class="cl">  defmock(SmsProviderMock, for: SmsProvider)
</span></span><span class="line"><span class="ln">16</span><span class="cl">  stub_with(SmsProviderMock, TestProvider)</span></span></code></pre></div><p>Viola! Now your tests are all green, fast and shiny thanks to concurrent
testing and Mox :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>If you&rsquo;re definitely interested in concurrent testing, you might want to
read
<a href="http://blog.plataformatec.com.br/2015/10/mocks-and-explicit-contracts/">excellent
article from Jose Valim</a> and dive in into
<a href="https://hexdocs.pm/mox/Mox.html">Mox documentation</a>.</p>
<p>Happy hacking, everyone!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
