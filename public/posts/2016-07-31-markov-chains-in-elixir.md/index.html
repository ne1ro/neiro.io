<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://neiro.io/images/favicon.png" />
<title>Markov chains in Elixir | neiro blog</title>
<meta name="title" content="Markov chains in Elixir" />
<meta name="description" content="Markov chains
Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.

      Figure 1: Simple Markov chain
    


For the next example we will try to build simple sentence generator
within Markov chain." />
<meta name="author" content="[neiro]" />
<meta name="keywords" content="elixir,functional," />






  





  













<meta property="og:title" content="Markov chains in Elixir" />
<meta property="og:description" content="Markov chains
Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.

      Figure 1: Simple Markov chain
    


For the next example we will try to build simple sentence generator
within Markov chain." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neiro.io/posts/2016-07-31-markov-chains-in-elixir.md/" />

<meta property="og:image" content="https://neiro.io/images/social_card_bg_hu14127928183971406719.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-07-31T10:00:00+02:00" />
<meta property="article:modified_time" content="2016-07-31T10:00:00+02:00" /><meta property="og:site_name" content="neiro" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://neiro.io/images/social_card_bg_hu14127928183971406719.webp"/>
<meta name="twitter:title" content="Markov chains in Elixir"/>
<meta name="twitter:description" content="Markov chains
Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.

      Figure 1: Simple Markov chain
    


For the next example we will try to build simple sentence generator
within Markov chain."/>



<meta itemprop="name" content="Markov chains in Elixir">
<meta itemprop="description" content="Markov chains
Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.

      Figure 1: Simple Markov chain
    


For the next example we will try to build simple sentence generator
within Markov chain."><meta itemprop="datePublished" content="2016-07-31T10:00:00+02:00" />
<meta itemprop="dateModified" content="2016-07-31T10:00:00+02:00" />
<meta itemprop="wordCount" content="915">

<meta itemprop="image" content="https://neiro.io/images/social_card_bg_hu14127928183971406719.webp"/>


<meta itemprop="keywords" content="elixir,functional," />

<meta name="referrer" content="no-referrer-when-downgrade" />

  
  <link href="/herman.min.css" rel="stylesheet">

  
    
    <link href="/syntax.min.css" rel="stylesheet">
  

  

  
</head>

<body>
  <header><a class="skip-link" href="#main-content">Skip to main content</a>

<a href="/" class="title"><h1>neiro blog</h1></a>
<nav>
  <a href="/">Home</a>

  <a href="/blog/">Blog</a>

<a href='https://neiro.io/index.xml'>RSS</a>







</nav>
</header>
  <main id="main-content">

<h1>Markov chains in Elixir</h1>
<p class="byline">
  <time datetime='2016-07-31' pubdate>
    2016-07-31
  </time>
  Â· [neiro]
</p>

<content>
  <h2 id="markov-chains">Markov chains</h2>
<p>Markov chain or Markov model is a process that undergoes transitions
from one state to another. The next state depends only on current state
and not the sequence of previous events. This allows us to use Markov
chains as statistical models for real-world processes.</p>
<figure><img src="https://upload.wikimedia.org/wikipedia/commons/7/7a/Markov_Chain_weather_model_matrix_as_a_graph.png"
    alt="Figure 1: Simple Markov chain"><figcaption>
      <p><span class="figure-number">Figure 1: </span>Simple Markov chain</p>
    </figcaption>
</figure>

<p>For the next example we will try to build simple sentence generator
within Markov chain.</p>
<h2 id="realization">Realization</h2>
<p>Let&rsquo;s create an entry point of new application:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir markov chain.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      alias ElixirMarkovChain.Model
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">      alias ElixirMarkovChain.Generator
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">      def start(_type, _args) do
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">        case File.read(Application.get_env :elixir_markov_chain, :source_file) do
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">           {:ok, body} -&gt; process_source body
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">           {:error, reason} -&gt; IO.puts reason
</span></span><span class="line"><span class="ln">10</span><span class="cl">        end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">        System.halt 0
</span></span><span class="line"><span class="ln">13</span><span class="cl">      end
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">      defp process_source do
</span></span><span class="line"><span class="ln">16</span><span class="cl">      end
</span></span><span class="line"><span class="ln">17</span><span class="cl">    end</span></span></code></pre></div><p>At first, to process the source file for output sentences, we need to
tokenize it:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">    # lib/elixir_markov_chain/tokenizer.ex
</span></span><span class="line"><span class="ln">2</span><span class="cl">    defmodule ElixirMarkovChain.Tokenizer do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      def tokenize(text) do
</span></span><span class="line"><span class="ln">4</span><span class="cl">        text
</span></span><span class="line"><span class="ln">5</span><span class="cl">          |&gt; String.downcase
</span></span><span class="line"><span class="ln">6</span><span class="cl">          |&gt; String.split(~r{\n}, trim: true) # split text to sentences
</span></span><span class="line"><span class="ln">7</span><span class="cl">          |&gt; Enum.map(&amp;String.split/1) # split sentences to words
</span></span><span class="line"><span class="ln">8</span><span class="cl">      end
</span></span><span class="line"><span class="ln">9</span><span class="cl">    end</span></span></code></pre></div><p>Next we need to realize Markov model. We&rsquo;ll use agents to share state in
application:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir_markov_chain/model.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain.Model do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      import ElixirMarkovChain.Tokenizer
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      def start_link, do: Agent.start_link(fn -&gt; %{} end) # create map for sharing through agent
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">      def populate(pid, text) do
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        for tokens &lt;- tokenize(text), do: modelize(pid, tokens) # populate model with tokens
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        pid
</span></span><span class="line"><span class="ln">10</span><span class="cl">      end
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl">      def fetch_token(state, pid) do
</span></span><span class="line"><span class="ln">13</span><span class="cl">        tokens = fetch_tokens state, pid
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl">        if length(tokens) &gt; 0 do
</span></span><span class="line"><span class="ln">16</span><span class="cl">          token = Enum.random tokens
</span></span><span class="line"><span class="ln">17</span><span class="cl">          count = tokens |&gt; Enum.count(&amp;(token == &amp;1))
</span></span><span class="line"><span class="ln">18</span><span class="cl">          {token, count / length(tokens)} # count probability of the token
</span></span><span class="line"><span class="ln">19</span><span class="cl">        else
</span></span><span class="line"><span class="ln">20</span><span class="cl">          {&#34;&#34;, 0.0}
</span></span><span class="line"><span class="ln">21</span><span class="cl">        end
</span></span><span class="line"><span class="ln">22</span><span class="cl">      end
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">      def fetch_state(tokens), do: fetch_state(tokens, length(tokens))
</span></span><span class="line"><span class="ln">25</span><span class="cl">      defp fetch_state(_tokens, id) when id == 0, do: {nil, nil}
</span></span><span class="line"><span class="ln">26</span><span class="cl">      defp fetch_state([head | _tail], id) when id == 1, do: {nil, head}
</span></span><span class="line"><span class="ln">27</span><span class="cl">      defp fetch_state(tokens, id) do
</span></span><span class="line"><span class="ln">28</span><span class="cl">        tokens
</span></span><span class="line"><span class="ln">29</span><span class="cl">          |&gt; Enum.slice(id - 2..id - 1) # fetch states by ids
</span></span><span class="line"><span class="ln">30</span><span class="cl">          |&gt; List.to_tuple
</span></span><span class="line"><span class="ln">31</span><span class="cl">      end
</span></span><span class="line"><span class="ln">32</span><span class="cl">
</span></span><span class="line"><span class="ln">33</span><span class="cl">      # Get tokens within agent
</span></span><span class="line"><span class="ln">34</span><span class="cl">      defp fetch_tokens(state, pid), do: Agent.get pid, &amp;(&amp;1[state] || [])
</span></span><span class="line"><span class="ln">35</span><span class="cl">
</span></span><span class="line"><span class="ln">36</span><span class="cl">      # Build Markov chain model using tokens
</span></span><span class="line"><span class="ln">37</span><span class="cl">      defp modelize(pid, tokens) do
</span></span><span class="line"><span class="ln">38</span><span class="cl">        for {token, id} &lt;- Enum.with_index(tokens) do
</span></span><span class="line"><span class="ln">39</span><span class="cl">          tokens |&gt; fetch_state(id) |&gt; add_state(pid, token)
</span></span><span class="line"><span class="ln">40</span><span class="cl">        end
</span></span><span class="line"><span class="ln">41</span><span class="cl">      end
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">      # Add new state within agent
</span></span><span class="line"><span class="ln">44</span><span class="cl">      defp add_state(state, pid, token) do
</span></span><span class="line"><span class="ln">45</span><span class="cl">        Agent.update pid, fn(model) -&gt;
</span></span><span class="line"><span class="ln">46</span><span class="cl">          current_state = model[state] || []
</span></span><span class="line"><span class="ln">47</span><span class="cl">          Map.put model, state, [token | current_state]
</span></span><span class="line"><span class="ln">48</span><span class="cl">        end
</span></span><span class="line"><span class="ln">49</span><span class="cl">      end
</span></span><span class="line"><span class="ln">50</span><span class="cl">    end</span></span></code></pre></div><p>When our Markov model is done, we can use it in application. For this
example, we&rsquo;ll build a random sentence generator based on text source:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # lib/elixir_markov_chain/generator.ex
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    defmodule ElixirMarkovChain.Generator do
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">      alias ElixirMarkovChain.Model
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">      def create_sentence(pid) do
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">        {sentence, prob} = build_sentence pid
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">        # Create new sentence or convert builded based on treshold value
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">        if prob &gt;= Application.get_env(:elixir_markov_chain, :treshold) do
</span></span><span class="line"><span class="ln">10</span><span class="cl">          sentence |&gt; Enum.join(&#34; &#34;) |&gt; String.capitalize
</span></span><span class="line"><span class="ln">11</span><span class="cl">        else
</span></span><span class="line"><span class="ln">12</span><span class="cl">          create_sentence pid
</span></span><span class="line"><span class="ln">13</span><span class="cl">        end
</span></span><span class="line"><span class="ln">14</span><span class="cl">      end
</span></span><span class="line"><span class="ln">15</span><span class="cl">
</span></span><span class="line"><span class="ln">16</span><span class="cl">      # Sentence is complete when it have enough length
</span></span><span class="line"><span class="ln">17</span><span class="cl">      # or when punctuation ends a sentence
</span></span><span class="line"><span class="ln">18</span><span class="cl">      defp complete?(tokens) do
</span></span><span class="line"><span class="ln">19</span><span class="cl">        length(tokens) &gt; 15 ||
</span></span><span class="line"><span class="ln">20</span><span class="cl">        (length(tokens) &gt; 3 &amp;&amp; Regex.match?(~r/[\!\?\.]\z/, List.last tokens))
</span></span><span class="line"><span class="ln">21</span><span class="cl">      end
</span></span><span class="line"><span class="ln">22</span><span class="cl">
</span></span><span class="line"><span class="ln">23</span><span class="cl">      defp build_sentence(pid), do: build_sentence(pid, [], 0.0, 0.0)
</span></span><span class="line"><span class="ln">24</span><span class="cl">      defp build_sentence(pid, tokens, prob_acc, new_tokens) do
</span></span><span class="line"><span class="ln">25</span><span class="cl">        # Fetch Markov model state through agent
</span></span><span class="line"><span class="ln">26</span><span class="cl">        {token, prob} = tokens |&gt; Model.fetch_state |&gt; Model.fetch_token(pid)
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">        case complete?(tokens) do
</span></span><span class="line"><span class="ln">29</span><span class="cl">          true -&gt;
</span></span><span class="line"><span class="ln">30</span><span class="cl">            score = case new_tokens == 0 do
</span></span><span class="line"><span class="ln">31</span><span class="cl">              true -&gt; 1.0
</span></span><span class="line"><span class="ln">32</span><span class="cl">              _ -&gt; prob_acc / new_tokens # count new probability for this word
</span></span><span class="line"><span class="ln">33</span><span class="cl">            end
</span></span><span class="line"><span class="ln">34</span><span class="cl">            {tokens, score}
</span></span><span class="line"><span class="ln">35</span><span class="cl">          _ -&gt;
</span></span><span class="line"><span class="ln">36</span><span class="cl">            # Concat sentence with new token and try to continue
</span></span><span class="line"><span class="ln">37</span><span class="cl">            build_sentence pid, tokens ++ [token], prob + prob_acc, new_tokens + 1
</span></span><span class="line"><span class="ln">38</span><span class="cl">        end
</span></span><span class="line"><span class="ln">39</span><span class="cl">      end
</span></span><span class="line"><span class="ln">40</span><span class="cl">    end</span></span></code></pre></div><p>Now, when basic logic is implemented, we need to fill <code>process_source</code>
function:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">    # lib/elixir_markov_chain.ex
</span></span><span class="line"><span class="ln">2</span><span class="cl">    defp process_source(text) do
</span></span><span class="line"><span class="ln">3</span><span class="cl">      {:ok, model} = Model.start_link
</span></span><span class="line"><span class="ln">4</span><span class="cl">      model = Model.populate model, text # populate Markov model with the source
</span></span><span class="line"><span class="ln">5</span><span class="cl">
</span></span><span class="line"><span class="ln">6</span><span class="cl">      # Generate 10 random sentences based on text source
</span></span><span class="line"><span class="ln">7</span><span class="cl">      Enum.each(1..10, fn(_) -&gt; model |&gt; Generator.create_sentence |&gt; IO.puts end)
</span></span><span class="line"><span class="ln">8</span><span class="cl">    end</span></span></code></pre></div><h2 id="result">Result</h2>
<p>Processed from <em>Thus Spoke Zarathustra</em> by <em>Friedrich Nietzsche</em>:</p>
<ul>
<li>By thee pursued, my fancy!</li>
<li>Nether-world, thou exuberant star!</li>
<li>Well then! we part here!</li>
<li>Snare for me&ndash;the desire for love&ndash;that i should like to strangle me,
thou fountain of delight!</li>
<li>As yet without meaning: a buffoon at heart.</li>
<li>Loved by overflowing hearts.</li>
<li>Growling bear, and sweeten thy soul!</li>
<li>Fountains shall rush down into his height!</li>
</ul>
<p>Processed from <em>Metamorphosis</em> by <em>Franz Kafka</em>:</p>
<ul>
<li>&ldquo;it&rsquo;s got to get up.</li>
<li>Where we have to open the door, holding himself upright as preparation
for getting through the</li>
<li>Incidental damages even if he did not know that he wouldn&rsquo;t have to
suffer the view</li>
<li>The gentlemen bent over the dishes set in front of them were blown
onto the cool,</li>
<li>Gregor then turned to look after my parents suffer!</li>
<li>&ldquo;we have to overcome it because of that.</li>
<li>Does not agree to be patient.</li>
<li>&ldquo;leave my home. now!&rdquo;, said mr.</li>
</ul>
<h2 id="conclusion">Conclusion</h2>
<p>Elixir allows to easily build Markov chains and applicate them to real
world processes. In our case we have built the random text generator,
but you can find Markov models useful for another cases. To view entire
application please visit
<a href="https://github.com/ne1ro/elixir-markov-chain">this repository</a>.</p>

</content>
<p>
  
    <a class="blog-tags" href="/tags/elixir/">#elixir</a>
  
    <a class="blog-tags" href="/tags/functional/">#functional</a>
  
</p>




  </main>
  <footer><small>
  neiro Â© 2012-2025 | Made with <a href="https://github.com/clente/hugo-bearcub">Bear Cub</a>
</small></footer>

    
</body>

</html>
