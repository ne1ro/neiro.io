<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Xtdb on neiro blog</title>
    <link>https://neiro.io/tags/xtdb/</link>
    <description>Recent content in Xtdb on neiro blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-GB</language>
    <copyright>neiro © 2012-2025</copyright>
    <lastBuildDate>Wed, 19 Jul 2023 15:45:00 +0200</lastBuildDate>
    <atom:link href="https://neiro.io/tags/xtdb/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Taming the time: how to run XTDB in production</title>
      <link>https://neiro.io/blog/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</link>
      <pubDate>Wed, 19 Jul 2023 15:45:00 +0200</pubDate>
      <guid>https://neiro.io/blog/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd&#34;&gt;The article was originally published in MarleySpoon DevBlog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-xtdb&#34;&gt;What is XTDB&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/ne1ro/series/22497&#34;&gt;In the previous articles&lt;/a&gt;, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&amp;rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.&lt;/p&gt;&#xA;&lt;h3 id=&#34;xtdb-1&#34;&gt;XTDB 1&lt;/h3&gt;&#xA;&lt;p&gt;Before we proceed, it&amp;rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.&#xA;It&amp;rsquo;s worth mentioning that your experience may vary, especially with the introduction of &lt;a href=&#34;https://www.xtdb.com/v2&#34;&gt;XTDB 2.0&lt;/a&gt; and subsequent versions.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<hr>
<p><a href="https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd">The article was originally published in MarleySpoon DevBlog</a></p>
<h2 id="what-is-xtdb">What is XTDB</h2>
<p><a href="https://dev.to/ne1ro/series/22497">In the previous articles</a>, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.</p>
<h3 id="xtdb-1">XTDB 1</h3>
<p>Before we proceed, it&rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.
It&rsquo;s worth mentioning that your experience may vary, especially with the introduction of <a href="https://www.xtdb.com/v2">XTDB 2.0</a> and subsequent versions.</p>
<h2 id="deploying-xtdb">Deploying XTDB</h2>
<p>Deploying XTDB in a production environment offers several options, each with its advantages and considerations:</p>
<ul>
<li>run as a part of your JVM application</li>
<li>run separately, but on the same server together with your application</li>
<li>run on a standalone node or in a separate container</li>
<li>run a cluster of XTDB nodes</li>
</ul>
<p>To achieve a resilient and scalable setup, I recommend running a cluster of XTDB nodes, with each node deployed as a separate Docker container managed by Kubernetes. This allows easy orchestration, automatic scaling, and simplified management of the XTDB cluster.</p>
<h3 id="containerised-xtdb">Containerised XTDB</h3>
<p>In this section, we will explore how to build and run a Docker container with a custom configured XTDB application <em>(Clojure project)</em> in a Kubernetes cluster. However, in case you don&rsquo;t need to have a custom build and can simply use a <a href="https://hub.docker.com/r/juxt/xtdb-standalone-rocksdb">standalone Docker image</a>, you can skip right to the &ldquo;Authentication&rdquo; section.</p>
<h4 id="uberjar">Uberjar</h4>
<p>If we want to run the XTDB in Docker the most fitting way to run it in a container would be to compile our preconfigured XT application into a single &ldquo;uberjar&rdquo; file.</p>
<p>This can be done by employing <a href="https://github.com/tonsky/uberdeps">Uberdeps</a> in our Clojure project:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="ss">:aliases</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"> <span class="p">{</span><span class="ss">:uberdeps</span> <span class="p">{</span><span class="ss">:replace-deps</span> <span class="p">{</span><span class="nv">uberdeps/uberdeps</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.1.0&#34;</span><span class="p">}}</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">             <span class="ss">:replace-paths</span> <span class="p">[]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">             <span class="ss">:main-opts</span> <span class="p">[</span><span class="s">&#34;-m&#34;</span> <span class="s">&#34;uberdeps.uberjar&#34;</span><span class="p">]}}</span></span></span></code></pre></div><p>Once you have it installed, you can compile your project into a single Uberjar file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">clj -M:uberdeps</span></span></code></pre></div><h4 id="dockerfile">Dockerfile</h4>
<p>We want our XTDB Docker image to be as lightweight as possible, so the best approach would be to have a multi-stage build image that builds and runs the Uberjar on the selected JVM image:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c"># Build clojure uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> clojure:openjdk-17-tools-deps-alpine AS BUILD</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">COPY</span> . /xtdb<span class="err">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk add --no-cache libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="err"></span><span class="k">RUN</span> clojure -M:uberdeps<span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err"></span><span class="c"># Copy and run uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> openjdk:17-alpine3.14</span><span class="err">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /usr/local/lib/xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk --no-cache add bash libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/resources /usr/local/lib/xtdb/resources<span class="err">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/target .<span class="err">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">MALLOC_ARENA_MAX</span><span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;java&#34;</span><span class="p">,</span> <span class="s2">&#34;-cp&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.jar&#34;</span><span class="p">,</span> <span class="s2">&#34;clojure.main&#34;</span><span class="p">,</span> <span class="s2">&#34;-m&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.core&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 3000</span></span></span></code></pre></div><h4 id="graceful-shutdown">Graceful shutdown</h4>
<p>Another requirement for running XT in Kubernetes is to gracefully shut down, e.g., on killing containers or Kubernetes deployment restart. To ensure that, we have to change our `xtdb.clj` file by adding a `SIGTERM` signal handler:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">;; Stop the system on SIGTERM</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="nf">with-handler</span> <span class="ss">:term</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;Caught SIGTERM, quitting&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="p">(</span><span class="nf">.close</span> <span class="o">@</span><span class="nv">xt-node</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;All components shut down&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">0</span><span class="p">))</span></span></span></code></pre></div><h3 id="authentication">Authentication</h3>
<p>Since we run our XTDB separately from our application containers, we might want to ensure that the requests from services to the database are properly authenticated.</p>
<p>In order to ensure that we need to change the way we start XTDB by providing JWKS (<a href="https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets">JSON Web Token key set</a>) as an environment variable to the XTDB node:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; core.clj</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.http-server/server</span> <span class="p">{</span><span class="ss">:port</span> <span class="mi">3000</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">                             <span class="ss">:jwks</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;XTDB_JWKS&#34;</span><span class="p">)}</span> <span class="nv">...</span></span></span></code></pre></div><p>The next step is to send the compatible JWT token from your application requests:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">{</span><span class="s2">&#34;Authorization&#34;</span><span class="p">,</span> <span class="s2">&#34;Bearer </span><span class="si">#{</span><span class="n">your_jwt</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">}</span></span></span></code></pre></div><h3 id="kubernetes">Kubernetes</h3>
<p>As we&rsquo;ve decided to go with the running XT nodes as Docker containers in a Kubernetes cluster, we need to prepare Kubernetes manifests for that purpose.</p>
<p>The simplest way to achieve that is to create a Kubernetes stateful set of multiple XT containers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-headless</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">      </span><span class="nt">terminationGracePeriodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">$REGISTRY/xtdb:1.21.0</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Always</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">          </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">            </span><span class="nt">tcpSocket</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">              </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">120</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">            </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w">          </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w">            </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">              </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">                </span>- <span class="l">bash</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">                </span><span class="c"># custom readiness check script</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">                </span>- <span class="l">scripts/readiness.sh</span><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">            </span>- <span class="nt">secretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-secrets</span></span></span></code></pre></div><p>As for the configuration, you can create a configmap with environment variables required for configuring XTDB and a secrets resource for providing secrets to your XT nodes.</p>
<h2 id="running-xt-in-production">Running XT in production</h2>
<p>XTDB is an <em>unbundled database</em> which means that it has a lot of components that can be swapped or changed — and it might work with different technologies and other databases.</p>
<p>In general, it consists of 3 parts:</p>
<ol>
<li>Transaction log</li>
<li>Document store</li>
<li>Index store</li>
</ol>
<p>We had an experience using PostgreSQL and JDBC adapter for our XTDB setup, as well as experimenting with Kafka for transaction log — and using RocksDB as an index storage.</p>
<p>However, there are many more other ways and modules to setup the database — you can find them in <a href="https://docs.xtdb.com/administration/configuring/">the documentation.</a></p>
<h3 id="jdbc">JDBC</h3>
<p>The transaction log and document store are considered to be <strong>golden stores</strong> in XTDB — which means that they should be reliably persisted, unlike the index storage that can be rebuilt from scratch on node restart.</p>
<p>XT supports JDBC (Java Database Connectivity) which allows us to connect to various SQL databases like PostgreSQL, MySQL, SQLite, and others.
In our example, we were using PostgreSQL + JDBC for both transaction log and document store.</p>
<p>To use PostgreSQL and JDBC together, you have to provide these modules in your <em>deps.edn</em> first:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="ss">:deps</span> <span class="p">{</span><span class="nv">org.postgresql/postgresql</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;42.2.18&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">        <span class="nv">com.xtdb/xtdb-jdbc</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">       <span class="nv">...</span></span></span></code></pre></div><p>If you want to use environment variables for connecting to PostgreSQL from the XTDB deployment you can also pass them in <strong>core.clj</strong> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="p">{</span><span class="ss">:host</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_HOST&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="ss">:port</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;POSTGRES_PORT&#34;</span> <span class="s">&#34;5432&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="ss">:dbname</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_DB&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="ss">:user</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_USER&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="ss">:password</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_PASSWORD&#34;</span><span class="p">)})</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.jdbc/connection-pool</span> <span class="p">{</span><span class="ss">:dialect</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc.psql/-&gt;dialect</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                               <span class="ss">:pool-opts</span> <span class="p">{</span><span class="ss">:maximumPoolSize</span> <span class="mi">10</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                               <span class="ss">:db-spec</span> <span class="nv">db-spec</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">   <span class="ss">:xtdb/tx-log</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;tx-log</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                 <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">   <span class="ss">:xtdb/document-store</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;document-store</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                         <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}})</span></span></span></code></pre></div><p>That way we can also re-use the same connection pool for both transaction and document store.</p>
<h3 id="kafka">Kafka</h3>
<p>However, the recommended option (and also most often used in production) is to leverage Kafka for the transaction store.</p>
<p>During node restarts <em>(e.g. on new deployments)</em> XTDB has to rebuild the transaction log from zero or the latest saved checkpoint, which means reading the whole transaction table in PostgreSQL — and in our experience, this process was slower than expected.</p>
<p>Kafka seems to be a better fit for the very purpose of the transaction log because:</p>
<ul>
<li>it&rsquo;s basically a log of events</li>
<li>we only need to use just one partition and one topic</li>
<li>the transactions can be consumed very quickly</li>
</ul>
<p>Thus, the most optimal and performant setup for us looked like:</p>
<ul>
<li>using Kafka as a transaction log</li>
<li>using JDBC and relational database as a document store</li>
<li>using RocksDB as an index store</li>
</ul>
<p>That way, we can ensure that the transactions can be created quickly, the log can be re-consumed fast, and the document storage is performant enough and resilient.</p>
<h3 id="checkpoints">Checkpoints</h3>
<p>If we want to rebuild the query indices (e.g. on node restart), XT might need to replay the transaction log — which sometimes might be not so fast especially if you have a long history of changes.</p>
<p>As we run our XTDB in a cluster, it&rsquo;s vital that the readiness time — when the XT instance is ready to serve DB requests — is as low as possible.
Fortunately, XTDB has a solution for that problem called <strong>checkpoints</strong>.</p>
<p>Right now, there are three ways to persist the local query indices state:</p>
<ul>
<li>local files (using Java&rsquo;s NIO file system)</li>
<li>AWS S3</li>
<li>GPC&rsquo;s cloud storage</li>
</ul>
<h4 id="aws-s3">AWS S3</h4>
<p>In our case, we&rsquo;ve decided to go with the AWS setup in order to have a centralised and already configured storage for the checkpoints.
However, it also requires some additional dependencies to be installed:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"> <span class="ss">:deps</span> <span class="p">{</span><span class="nv">com.xtdb/xtdb-s3</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="nv">software.amazon.awssdk/aws-core</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;2.10.91&#34;</span><span class="p">}</span></span></span></code></pre></div><p>Additional setup in the node configuration is also required.</p>
<p>As we&rsquo;ve experienced some requests to S3 taking a long time, we&rsquo;ve also decided to build a custom AWS S3 HTTP client:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="kd">defn- </span><span class="nv">make-s3-client</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="s">&#34;Increases timeouts for AWS S3 HTTP calls&#34;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">[]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">timeout</span> <span class="p">(</span><span class="nf">Duration/ofSeconds</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="nv">http-client-builder</span> <span class="p">(</span><span class="nf">-&gt;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                             <span class="p">(</span><span class="nf">NettyNioAsyncHttpClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionAcquisitionTimeout</span> <span class="nv">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionTimeout</span> <span class="nv">timeout</span><span class="p">))]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">S3AsyncClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">(</span><span class="nf">.httpClientBuilder</span> <span class="nv">http-client-builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="nv">.build</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-name</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;CHECKPOINT_NAME&#34;</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-config</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="c1">; Checkpoints are not enabled on a local machine where we don&#39;t have the env</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">str/blank?</span> <span class="nv">checkpoint-name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.checkpoint/-&gt;checkpointer</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">     <span class="ss">:store</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">     <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.s3.checkpoint/-&gt;cp-store</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">      <span class="ss">:bucket</span> <span class="nv">checkpoint-name</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">      <span class="ss">:configurator</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">reify</span> <span class="nv">S3Configurator</span> <span class="p">(</span><span class="nf">makeClient</span> <span class="p">[</span><span class="nv">_this</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-s3-client</span><span class="p">))))}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">     <span class="ss">:Keep-dir-on-close?</span> <span class="nv">false</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">     <span class="ss">:approx-frequency</span> <span class="p">(</span><span class="nf">Duration/ofHours</span> <span class="mi">2</span><span class="p">)}))</span></span></span></code></pre></div><p>Once configured, XT will persist the current index state to S3 every 2 hours. One might want to adjust S3&rsquo;s bucket policy so it archives or removes the obsolete checkpoints files.</p>
<h2 id="caveats">Caveats</h2>
<h3 id="memory-consumption">Memory consumption</h3>
<p>JVM-based applications tend to consume quite a significant amount of memory budget — in our case, running XT with allowed 4GB of memory wasn&rsquo;t always enough so we&rsquo;ve decided to increase the memory limits in Kubernetes up to 8 gigabytes.</p>
<p>Another consideration we&rsquo;ve observed is that the vertical scaling works better for an XTDB cluster — unlike the horizontal scaling, where we need to wait until the new node restores from the checkpoints or processes the transactions log.</p>
<h3 id="rocksdb-tuning">RocksDB tuning</h3>
<p>RocksDB is being used by XT as an index store, and as the result, it might consume quite a significant amount of resources.
In order to avoid possible issues with the memory budgeting, it&rsquo;s recommended to <a href="https://github.com/facebook/rocksdb/wiki/Setup-Options-and-Basic-Tuning#block-cache-size">set RocksDB block cache to 1/3 of available memory</a> which can be done in XTDB configuration.</p>
<h3 id="readiness-probes">Readiness probes</h3>
<p>Depending on your technology stack that you use for XTDB deployment, consuming the transaction log even with the checkpoints feature enabled can take some time — and even though the starting node is able to handle REST API requests, they won&rsquo;t be processed until the node finishes the consumption.</p>
<p>To avoid that, you might need to check the difference between the last submitted and last completed transactions, e.g. from a bash script:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="c1"># scripts/readiness.sh: A script that compares the latest submitted and indexed transactions</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="nb">set</span> -e
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="nv">THRESHOLD</span><span class="o">=</span><span class="m">1000</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"># Assumes that you have jq and curl installed</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="nv">submitted_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-submitted-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nv">completed_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-completed-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nv">diff</span><span class="o">=</span>$<span class="o">[</span>submitted_tx - completed_tx<span class="o">]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">if</span> <span class="o">((</span>diff &gt; THRESHOLD<span class="o">))</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is not ready&#34;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is ready&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="k">fi</span></span></span></code></pre></div><h3 id="load-balancing-and-xt-cluster">Load balancing and XT cluster</h3>
<p>The index storage is not shared between XTDB nodes — so every node might have a slightly different data representation. To ensure integrity, we might need to use <em>await-tx</em> or <em>sync</em> functions whenever we submit a transaction.</p>
<p>However, when we use REST API in a distributed cluster of nodes, it might be that the load balancer that stands in front of the nodes distributes requests to the database randomly — and when we submit a transaction to one node, we can end up reading data from another, which might have not processed that transaction yet.</p>
<p>If we want to prevent such situation, we might need to implement sticky sessions or use <a href="https://dev.to/marleyspoon/taming-the-time-how-to-install-develop-with-xtdb-2lbf#http2">HTTP2</a> connections between your applications and database nodes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>XTDB embraces the bitemporality concept and provides powerful capabilities of handling your data in an immutable way.</p>
<p>However, this also implies that during your journey with XT, you might face some technical challenges caused by its unbundled database concept — and resolve them by reasoning about the selected components, technology stack, and implications.</p>
<p>The new milestone in XTDB&rsquo;s development — <a href="https://www.xtdb.com/v2">XTDB 2.0</a> — looks very promising for us as it has a more flexible and scalable architecture as well as the first-class SQL support — and can be used by PostgreSQL clients.</p>
<p>We look forward to trying out the new version and hope that you&rsquo;ve enjoyed our series of articles about XT.</p>
<p>Happy hacking, and stay tuned!</p>
]]></content:encoded>
    </item>
    <item>
      <title>Taming the time: how to run XTDB in production</title>
      <link>https://neiro.io/posts/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</link>
      <pubDate>Wed, 19 Jul 2023 15:45:00 +0200</pubDate>
      <guid>https://neiro.io/posts/2023-07-19-taming-the-time-how-we-run-xtdb-in-production/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd&#34;&gt;The article was originally published in MarleySpoon DevBlog&lt;/a&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;what-is-xtdb&#34;&gt;What is XTDB&lt;/h2&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://dev.to/ne1ro/series/22497&#34;&gt;In the previous articles&lt;/a&gt;, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&amp;rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.&lt;/p&gt;&#xA;&lt;h3 id=&#34;xtdb-1&#34;&gt;XTDB 1&lt;/h3&gt;&#xA;&lt;p&gt;Before we proceed, it&amp;rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.&#xA;It&amp;rsquo;s worth mentioning that your experience may vary, especially with the introduction of &lt;a href=&#34;https://www.xtdb.com/v2&#34;&gt;XTDB 2.0&lt;/a&gt; and subsequent versions.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<hr>
<p><a href="https://dev.to/marleyspoon/taming-time-how-to-run-xtdb-in-production-2lgd">The article was originally published in MarleySpoon DevBlog</a></p>
<h2 id="what-is-xtdb">What is XTDB</h2>
<p><a href="https://dev.to/ne1ro/series/22497">In the previous articles</a>, we explored the concept of bitemporality and discussed how to get started with XTDB, a bitemporal immutable database. Now, let&rsquo;s dive into the technical details of deploying XTDB and running it in production. This blog post aims to provide valuable insights and considerations to keep in mind during this process.</p>
<h3 id="xtdb-1">XTDB 1</h3>
<p>Before we proceed, it&rsquo;s important to note that the experiences shared in this article are based on working with XTDB version 1.21.
It&rsquo;s worth mentioning that your experience may vary, especially with the introduction of <a href="https://www.xtdb.com/v2">XTDB 2.0</a> and subsequent versions.</p>
<h2 id="deploying-xtdb">Deploying XTDB</h2>
<p>Deploying XTDB in a production environment offers several options, each with its advantages and considerations:</p>
<ul>
<li>run as a part of your JVM application</li>
<li>run separately, but on the same server together with your application</li>
<li>run on a standalone node or in a separate container</li>
<li>run a cluster of XTDB nodes</li>
</ul>
<p>To achieve a resilient and scalable setup, I recommend running a cluster of XTDB nodes, with each node deployed as a separate Docker container managed by Kubernetes. This allows easy orchestration, automatic scaling, and simplified management of the XTDB cluster.</p>
<h3 id="containerised-xtdb">Containerised XTDB</h3>
<p>In this section, we will explore how to build and run a Docker container with a custom configured XTDB application <em>(Clojure project)</em> in a Kubernetes cluster. However, in case you don&rsquo;t need to have a custom build and can simply use a <a href="https://hub.docker.com/r/juxt/xtdb-standalone-rocksdb">standalone Docker image</a>, you can skip right to the &ldquo;Authentication&rdquo; section.</p>
<h4 id="uberjar">Uberjar</h4>
<p>If we want to run the XTDB in Docker the most fitting way to run it in a container would be to compile our preconfigured XT application into a single &ldquo;uberjar&rdquo; file.</p>
<p>This can be done by employing <a href="https://github.com/tonsky/uberdeps">Uberdeps</a> in our Clojure project:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="ss">:aliases</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl"> <span class="p">{</span><span class="ss">:uberdeps</span> <span class="p">{</span><span class="ss">:replace-deps</span> <span class="p">{</span><span class="nv">uberdeps/uberdeps</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.1.0&#34;</span><span class="p">}}</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">             <span class="ss">:replace-paths</span> <span class="p">[]</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">             <span class="ss">:main-opts</span> <span class="p">[</span><span class="s">&#34;-m&#34;</span> <span class="s">&#34;uberdeps.uberjar&#34;</span><span class="p">]}}</span></span></span></code></pre></div><p>Once you have it installed, you can compile your project into a single Uberjar file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln">1</span><span class="cl">clj -M:uberdeps</span></span></code></pre></div><h4 id="dockerfile">Dockerfile</h4>
<p>We want our XTDB Docker image to be as lightweight as possible, so the best approach would be to have a multi-stage build image that builds and runs the Uberjar on the selected JVM image:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-dockerfile" data-lang="dockerfile"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="c"># Build clojure uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> clojure:openjdk-17-tools-deps-alpine AS BUILD</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="err"></span><span class="k">COPY</span> . /xtdb<span class="err">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk add --no-cache libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="err"></span><span class="k">RUN</span> clojure -M:uberdeps<span class="err">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="err"></span><span class="c"># Copy and run uberjar</span><span class="err">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="err"></span><span class="k">FROM</span><span class="s"> openjdk:17-alpine3.14</span><span class="err">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="err"></span><span class="k">WORKDIR</span><span class="s"> /usr/local/lib/xtdb</span><span class="err">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="err"></span><span class="k">RUN</span> apk --no-cache add bash libstdc++<span class="err">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/resources /usr/local/lib/xtdb/resources<span class="err">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="err"></span><span class="k">COPY</span> --from<span class="o">=</span>BUILD /xtdb/target .<span class="err">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="err"></span><span class="k">ENV</span> <span class="nv">MALLOC_ARENA_MAX</span><span class="o">=</span><span class="m">2</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="k">CMD</span> <span class="p">[</span><span class="s2">&#34;java&#34;</span><span class="p">,</span> <span class="s2">&#34;-cp&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.jar&#34;</span><span class="p">,</span> <span class="s2">&#34;clojure.main&#34;</span><span class="p">,</span> <span class="s2">&#34;-m&#34;</span><span class="p">,</span> <span class="s2">&#34;xtdb.core&#34;</span><span class="p">]</span><span class="err">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="err"></span><span class="k">EXPOSE</span><span class="s"> 3000</span></span></span></code></pre></div><h4 id="graceful-shutdown">Graceful shutdown</h4>
<p>Another requirement for running XT in Kubernetes is to gracefully shut down, e.g., on killing containers or Kubernetes deployment restart. To ensure that, we have to change our `xtdb.clj` file by adding a `SIGTERM` signal handler:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">;; Stop the system on SIGTERM</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="nf">with-handler</span> <span class="ss">:term</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;Caught SIGTERM, quitting&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">  <span class="p">(</span><span class="nf">.close</span> <span class="o">@</span><span class="nv">xt-node</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">5</span><span class="cl">  <span class="p">(</span><span class="nf">log/info</span> <span class="s">&#34;All components shut down&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">6</span><span class="cl">  <span class="p">(</span><span class="nf">System/exit</span> <span class="mi">0</span><span class="p">))</span></span></span></code></pre></div><h3 id="authentication">Authentication</h3>
<p>Since we run our XTDB separately from our application containers, we might want to ensure that the requests from services to the database are properly authenticated.</p>
<p>In order to ensure that we need to change the way we start XTDB by providing JWKS (<a href="https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets">JSON Web Token key set</a>) as an environment variable to the XTDB node:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; core.clj</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.http-server/server</span> <span class="p">{</span><span class="ss">:port</span> <span class="mi">3000</span>
</span></span><span class="line"><span class="ln">4</span><span class="cl">                             <span class="ss">:jwks</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;XTDB_JWKS&#34;</span><span class="p">)}</span> <span class="nv">...</span></span></span></code></pre></div><p>The next step is to send the compatible JWT token from your application requests:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-elixir" data-lang="elixir"><span class="line"><span class="ln">1</span><span class="cl"><span class="p">{</span><span class="s2">&#34;Authorization&#34;</span><span class="p">,</span> <span class="s2">&#34;Bearer </span><span class="si">#{</span><span class="n">your_jwt</span><span class="si">}</span><span class="s2">&#34;</span><span class="p">}</span></span></span></code></pre></div><h3 id="kubernetes">Kubernetes</h3>
<p>As we&rsquo;ve decided to go with the running XT nodes as Docker containers in a Kubernetes cluster, we need to prepare Kubernetes manifests for that purpose.</p>
<p>The simplest way to achieve that is to create a Kubernetes stateful set of multiple XT containers:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="nn">---</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="w"></span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 3</span><span class="cl"><span class="w"></span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">StatefulSet</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="w"></span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="w">  </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 6</span><span class="cl"><span class="w">  </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="w">    </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="w"></span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="w">  </span><span class="nt">serviceName</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-headless</span><span class="w">
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="w">  </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">3</span><span class="w">
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="w">  </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="w">    </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">14</span><span class="cl"><span class="w">  </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="w">    </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">16</span><span class="cl"><span class="w">      </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="w">      </span><span class="nt">app.kubernetes.io/name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">18</span><span class="cl"><span class="w">    </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">19</span><span class="cl"><span class="w">      </span><span class="nt">terminationGracePeriodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">20</span><span class="cl"><span class="w">      </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">21</span><span class="cl"><span class="w">        </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb</span><span class="w">
</span></span></span><span class="line"><span class="ln">22</span><span class="cl"><span class="w">          </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">$REGISTRY/xtdb:1.21.0</span><span class="w">
</span></span></span><span class="line"><span class="ln">23</span><span class="cl"><span class="w">          </span><span class="nt">imagePullPolicy</span><span class="p">:</span><span class="w"> </span><span class="l">Always</span><span class="w">
</span></span></span><span class="line"><span class="ln">24</span><span class="cl"><span class="w">          </span><span class="nt">ports</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">25</span><span class="cl"><span class="w">            </span>- <span class="nt">containerPort</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">26</span><span class="cl"><span class="w">          </span><span class="nt">livenessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">27</span><span class="cl"><span class="w">            </span><span class="nt">tcpSocket</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">28</span><span class="cl"><span class="w">              </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">3000</span><span class="w">
</span></span></span><span class="line"><span class="ln">29</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">10</span><span class="w">
</span></span></span><span class="line"><span class="ln">30</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">120</span><span class="w">
</span></span></span><span class="line"><span class="ln">31</span><span class="cl"><span class="w">            </span><span class="nt">timeoutSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">32</span><span class="cl"><span class="w">          </span><span class="nt">readinessProbe</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">33</span><span class="cl"><span class="w">            </span><span class="nt">exec</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">34</span><span class="cl"><span class="w">              </span><span class="nt">command</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">35</span><span class="cl"><span class="w">                </span>- <span class="l">bash</span><span class="w">
</span></span></span><span class="line"><span class="ln">36</span><span class="cl"><span class="w">                </span><span class="c"># custom readiness check script</span><span class="w">
</span></span></span><span class="line"><span class="ln">37</span><span class="cl"><span class="w">                </span>- <span class="l">scripts/readiness.sh</span><span class="w">
</span></span></span><span class="line"><span class="ln">38</span><span class="cl"><span class="w">            </span><span class="nt">initialDelaySeconds</span><span class="p">:</span><span class="w"> </span><span class="m">30</span><span class="w">
</span></span></span><span class="line"><span class="ln">39</span><span class="cl"><span class="w">            </span><span class="nt">periodSeconds</span><span class="p">:</span><span class="w"> </span><span class="m">15</span><span class="w">
</span></span></span><span class="line"><span class="ln">40</span><span class="cl"><span class="w">          </span><span class="nt">envFrom</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">41</span><span class="cl"><span class="w">            </span>- <span class="nt">secretRef</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="ln">42</span><span class="cl"><span class="w">                </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">xtdb-secrets</span></span></span></code></pre></div><p>As for the configuration, you can create a configmap with environment variables required for configuring XTDB and a secrets resource for providing secrets to your XT nodes.</p>
<h2 id="running-xt-in-production">Running XT in production</h2>
<p>XTDB is an <em>unbundled database</em> which means that it has a lot of components that can be swapped or changed — and it might work with different technologies and other databases.</p>
<p>In general, it consists of 3 parts:</p>
<ol>
<li>Transaction log</li>
<li>Document store</li>
<li>Index store</li>
</ol>
<p>We had an experience using PostgreSQL and JDBC adapter for our XTDB setup, as well as experimenting with Kafka for transaction log — and using RocksDB as an index storage.</p>
<p>However, there are many more other ways and modules to setup the database — you can find them in <a href="https://docs.xtdb.com/administration/configuring/">the documentation.</a></p>
<h3 id="jdbc">JDBC</h3>
<p>The transaction log and document store are considered to be <strong>golden stores</strong> in XTDB — which means that they should be reliably persisted, unlike the index storage that can be rebuilt from scratch on node restart.</p>
<p>XT supports JDBC (Java Database Connectivity) which allows us to connect to various SQL databases like PostgreSQL, MySQL, SQLite, and others.
In our example, we were using PostgreSQL + JDBC for both transaction log and document store.</p>
<p>To use PostgreSQL and JDBC together, you have to provide these modules in your <em>deps.edn</em> first:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="ss">:deps</span> <span class="p">{</span><span class="nv">org.postgresql/postgresql</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;42.2.18&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl">        <span class="nv">com.xtdb/xtdb-jdbc</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">       <span class="nv">...</span></span></span></code></pre></div><p>If you want to use environment variables for connecting to PostgreSQL from the XTDB deployment you can also pass them in <strong>core.clj</strong> file:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">db-spec</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="p">{</span><span class="ss">:host</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_HOST&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">   <span class="ss">:port</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;POSTGRES_PORT&#34;</span> <span class="s">&#34;5432&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">   <span class="ss">:dbname</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_DB&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">   <span class="ss">:user</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_USER&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">   <span class="ss">:password</span> <span class="p">(</span><span class="nf">System/getenv</span> <span class="s">&#34;POSTGRES_PASSWORD&#34;</span><span class="p">)})</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">config</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">  <span class="p">{</span><span class="ss">:xtdb.jdbc/connection-pool</span> <span class="p">{</span><span class="ss">:dialect</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc.psql/-&gt;dialect</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">                               <span class="ss">:pool-opts</span> <span class="p">{</span><span class="ss">:maximumPoolSize</span> <span class="mi">10</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">                               <span class="ss">:db-spec</span> <span class="nv">db-spec</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">   <span class="ss">:xtdb/tx-log</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;tx-log</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">                 <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">   <span class="ss">:xtdb/document-store</span> <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.jdbc/-&gt;document-store</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">                         <span class="ss">:connection-pool</span> <span class="ss">:xtdb.jdbc/connection-pool</span><span class="p">}})</span></span></span></code></pre></div><p>That way we can also re-use the same connection pool for both transaction and document store.</p>
<h3 id="kafka">Kafka</h3>
<p>However, the recommended option (and also most often used in production) is to leverage Kafka for the transaction store.</p>
<p>During node restarts <em>(e.g. on new deployments)</em> XTDB has to rebuild the transaction log from zero or the latest saved checkpoint, which means reading the whole transaction table in PostgreSQL — and in our experience, this process was slower than expected.</p>
<p>Kafka seems to be a better fit for the very purpose of the transaction log because:</p>
<ul>
<li>it&rsquo;s basically a log of events</li>
<li>we only need to use just one partition and one topic</li>
<li>the transactions can be consumed very quickly</li>
</ul>
<p>Thus, the most optimal and performant setup for us looked like:</p>
<ul>
<li>using Kafka as a transaction log</li>
<li>using JDBC and relational database as a document store</li>
<li>using RocksDB as an index store</li>
</ul>
<p>That way, we can ensure that the transactions can be created quickly, the log can be re-consumed fast, and the document storage is performant enough and resilient.</p>
<h3 id="checkpoints">Checkpoints</h3>
<p>If we want to rebuild the query indices (e.g. on node restart), XT might need to replay the transaction log — which sometimes might be not so fast especially if you have a long history of changes.</p>
<p>As we run our XTDB in a cluster, it&rsquo;s vital that the readiness time — when the XT instance is ready to serve DB requests — is as low as possible.
Fortunately, XTDB has a solution for that problem called <strong>checkpoints</strong>.</p>
<p>Right now, there are three ways to persist the local query indices state:</p>
<ul>
<li>local files (using Java&rsquo;s NIO file system)</li>
<li>AWS S3</li>
<li>GPC&rsquo;s cloud storage</li>
</ul>
<h4 id="aws-s3">AWS S3</h4>
<p>In our case, we&rsquo;ve decided to go with the AWS setup in order to have a centralised and already configured storage for the checkpoints.
However, it also requires some additional dependencies to be installed:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln">1</span><span class="cl"><span class="c1">; deps.edn</span>
</span></span><span class="line"><span class="ln">2</span><span class="cl"> <span class="ss">:deps</span> <span class="p">{</span><span class="nv">com.xtdb/xtdb-s3</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;1.21.0&#34;</span><span class="p">}</span>
</span></span><span class="line"><span class="ln">3</span><span class="cl">        <span class="nv">software.amazon.awssdk/aws-core</span> <span class="p">{</span><span class="ss">:mvn/version</span> <span class="s">&#34;2.10.91&#34;</span><span class="p">}</span></span></span></code></pre></div><p>Additional setup in the node configuration is also required.</p>
<p>As we&rsquo;ve experienced some requests to S3 taking a long time, we&rsquo;ve also decided to build a custom AWS S3 HTTP client:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-clojure" data-lang="clojure"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="p">(</span><span class="kd">defn- </span><span class="nv">make-s3-client</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">  <span class="s">&#34;Increases timeouts for AWS S3 HTTP calls&#34;</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="p">[]</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">timeout</span> <span class="p">(</span><span class="nf">Duration/ofSeconds</span> <span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">        <span class="nv">http-client-builder</span> <span class="p">(</span><span class="nf">-&gt;</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">                             <span class="p">(</span><span class="nf">NettyNioAsyncHttpClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionAcquisitionTimeout</span> <span class="nv">timeout</span><span class="p">)</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">                             <span class="p">(</span><span class="nf">.connectionTimeout</span> <span class="nv">timeout</span><span class="p">))]</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    <span class="p">(</span><span class="nb">-&gt; </span><span class="p">(</span><span class="nf">S3AsyncClient/builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl">        <span class="p">(</span><span class="nf">.httpClientBuilder</span> <span class="nv">http-client-builder</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">        <span class="nv">.build</span><span class="p">)))</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">
</span></span><span class="line"><span class="ln">13</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-name</span> <span class="p">(</span><span class="nb">get </span><span class="p">(</span><span class="nf">System/getenv</span><span class="p">)</span> <span class="s">&#34;CHECKPOINT_NAME&#34;</span> <span class="s">&#34;&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="p">(</span><span class="k">def </span><span class="nv">checkpoint-config</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="c1">; Checkpoints are not enabled on a local machine where we don&#39;t have the env</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="p">(</span><span class="k">if </span><span class="p">(</span><span class="nf">str/blank?</span> <span class="nv">checkpoint-name</span><span class="p">)</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">    <span class="p">{}</span>
</span></span><span class="line"><span class="ln">19</span><span class="cl">    <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.checkpoint/-&gt;checkpointer</span>
</span></span><span class="line"><span class="ln">20</span><span class="cl">     <span class="ss">:store</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">     <span class="p">{</span><span class="ss">:xtdb/module</span> <span class="ss">&#39;xtdb.s3.checkpoint/-&gt;cp-store</span>
</span></span><span class="line"><span class="ln">22</span><span class="cl">      <span class="ss">:bucket</span> <span class="nv">checkpoint-name</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">      <span class="ss">:configurator</span> <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">_</span><span class="p">]</span> <span class="p">(</span><span class="nf">reify</span> <span class="nv">S3Configurator</span> <span class="p">(</span><span class="nf">makeClient</span> <span class="p">[</span><span class="nv">_this</span><span class="p">]</span> <span class="p">(</span><span class="nf">make-s3-client</span><span class="p">))))}</span>
</span></span><span class="line"><span class="ln">24</span><span class="cl">     <span class="ss">:Keep-dir-on-close?</span> <span class="nv">false</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">     <span class="ss">:approx-frequency</span> <span class="p">(</span><span class="nf">Duration/ofHours</span> <span class="mi">2</span><span class="p">)}))</span></span></span></code></pre></div><p>Once configured, XT will persist the current index state to S3 every 2 hours. One might want to adjust S3&rsquo;s bucket policy so it archives or removes the obsolete checkpoints files.</p>
<h2 id="caveats">Caveats</h2>
<h3 id="memory-consumption">Memory consumption</h3>
<p>JVM-based applications tend to consume quite a significant amount of memory budget — in our case, running XT with allowed 4GB of memory wasn&rsquo;t always enough so we&rsquo;ve decided to increase the memory limits in Kubernetes up to 8 gigabytes.</p>
<p>Another consideration we&rsquo;ve observed is that the vertical scaling works better for an XTDB cluster — unlike the horizontal scaling, where we need to wait until the new node restores from the checkpoints or processes the transactions log.</p>
<h3 id="rocksdb-tuning">RocksDB tuning</h3>
<p>RocksDB is being used by XT as an index store, and as the result, it might consume quite a significant amount of resources.
In order to avoid possible issues with the memory budgeting, it&rsquo;s recommended to <a href="https://github.com/facebook/rocksdb/wiki/Setup-Options-and-Basic-Tuning#block-cache-size">set RocksDB block cache to 1/3 of available memory</a> which can be done in XTDB configuration.</p>
<h3 id="readiness-probes">Readiness probes</h3>
<p>Depending on your technology stack that you use for XTDB deployment, consuming the transaction log even with the checkpoints feature enabled can take some time — and even though the starting node is able to handle REST API requests, they won&rsquo;t be processed until the node finishes the consumption.</p>
<p>To avoid that, you might need to check the difference between the last submitted and last completed transactions, e.g. from a bash script:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="cp">#!/bin/bash
</span></span></span><span class="line"><span class="ln"> 2</span><span class="cl"><span class="cp"></span><span class="c1"># scripts/readiness.sh: A script that compares the latest submitted and indexed transactions</span>
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">
</span></span><span class="line"><span class="ln"> 4</span><span class="cl"><span class="nb">set</span> -e
</span></span><span class="line"><span class="ln"> 5</span><span class="cl"><span class="nv">THRESHOLD</span><span class="o">=</span><span class="m">1000</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">
</span></span><span class="line"><span class="ln"> 7</span><span class="cl"><span class="c1"># Assumes that you have jq and curl installed</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl"><span class="nv">submitted_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-submitted-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="nv">completed_tx</span><span class="o">=</span><span class="sb">`</span>curl http://localhost:3000/_xtdb/latest-completed-tx -H <span class="s2">&#34;Accept: application/json&#34;</span> -f <span class="p">|</span> jq .txId<span class="sb">`</span>
</span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="nv">diff</span><span class="o">=</span>$<span class="o">[</span>submitted_tx - completed_tx<span class="o">]</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">
</span></span><span class="line"><span class="ln">12</span><span class="cl"><span class="k">if</span> <span class="o">((</span>diff &gt; THRESHOLD<span class="o">))</span><span class="p">;</span> <span class="k">then</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is not ready&#34;</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">    <span class="nb">exit</span> <span class="m">1</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl"><span class="k">else</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">    <span class="nb">echo</span> <span class="s2">&#34;Node is ready&#34;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="k">fi</span></span></span></code></pre></div><h3 id="load-balancing-and-xt-cluster">Load balancing and XT cluster</h3>
<p>The index storage is not shared between XTDB nodes — so every node might have a slightly different data representation. To ensure integrity, we might need to use <em>await-tx</em> or <em>sync</em> functions whenever we submit a transaction.</p>
<p>However, when we use REST API in a distributed cluster of nodes, it might be that the load balancer that stands in front of the nodes distributes requests to the database randomly — and when we submit a transaction to one node, we can end up reading data from another, which might have not processed that transaction yet.</p>
<p>If we want to prevent such situation, we might need to implement sticky sessions or use <a href="https://dev.to/marleyspoon/taming-the-time-how-to-install-develop-with-xtdb-2lbf#http2">HTTP2</a> connections between your applications and database nodes.</p>
<h2 id="conclusion">Conclusion</h2>
<p>XTDB embraces the bitemporality concept and provides powerful capabilities of handling your data in an immutable way.</p>
<p>However, this also implies that during your journey with XT, you might face some technical challenges caused by its unbundled database concept — and resolve them by reasoning about the selected components, technology stack, and implications.</p>
<p>The new milestone in XTDB&rsquo;s development — <a href="https://www.xtdb.com/v2">XTDB 2.0</a> — looks very promising for us as it has a more flexible and scalable architecture as well as the first-class SQL support — and can be used by PostgreSQL clients.</p>
<p>We look forward to trying out the new version and hope that you&rsquo;ve enjoyed our series of articles about XT.</p>
<p>Happy hacking, and stay tuned!</p>
]]></content:encoded>
    </item>
  </channel>
</rss>
