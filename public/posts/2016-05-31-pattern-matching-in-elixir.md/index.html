<!DOCTYPE html>
<html lang="en-GB">

<head>
  <meta http-equiv="X-Clacks-Overhead" content="GNU Terry Pratchett" />
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="shortcut icon" href="https://neiro.io/images/favicon.png" />
<title>Pattern matching in Elixir | neiro blog</title>
<meta name="title" content="Pattern matching in Elixir" />
<meta name="description" content="Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.
Match operator
Most of programming languages have assign operator: var x = 10 . In
Elixir equals sign is actually match operator. Using this operator we
can assign and match values:" />
<meta name="author" content="[neiro]" />
<meta name="keywords" content="elixir,functional," />






  





  













<meta property="og:title" content="Pattern matching in Elixir" />
<meta property="og:description" content="Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.
Match operator
Most of programming languages have assign operator: var x = 10 . In
Elixir equals sign is actually match operator. Using this operator we
can assign and match values:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://neiro.io/posts/2016-05-31-pattern-matching-in-elixir.md/" />

<meta property="og:image" content="https://neiro.io/images/social_card_bg_hu13030445083873728212.webp"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-31T10:00:00+02:00" />
<meta property="article:modified_time" content="2016-05-31T10:00:00+02:00" /><meta property="og:site_name" content="neiro" />




<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://neiro.io/images/social_card_bg_hu13030445083873728212.webp"/>
<meta name="twitter:title" content="Pattern matching in Elixir"/>
<meta name="twitter:description" content="Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.
Match operator
Most of programming languages have assign operator: var x = 10 . In
Elixir equals sign is actually match operator. Using this operator we
can assign and match values:"/>



<meta itemprop="name" content="Pattern matching in Elixir">
<meta itemprop="description" content="Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.
Match operator
Most of programming languages have assign operator: var x = 10 . In
Elixir equals sign is actually match operator. Using this operator we
can assign and match values:"><meta itemprop="datePublished" content="2016-05-31T10:00:00+02:00" />
<meta itemprop="dateModified" content="2016-05-31T10:00:00+02:00" />
<meta itemprop="wordCount" content="507">

<meta itemprop="image" content="https://neiro.io/images/social_card_bg_hu13030445083873728212.webp"/>


<meta itemprop="keywords" content="elixir,functional," />

<meta name="referrer" content="no-referrer-when-downgrade" />

  
  <link href="/herman.min.css" rel="stylesheet">

  
    
    <link href="/syntax.min.css" rel="stylesheet">
  

  

  
</head>

<body>
  <header><a class="skip-link" href="#main-content">Skip to main content</a>

<a href="/" class="title"><h1>neiro blog</h1></a>
<nav>
  <a href="/">Home</a>

  <a href="/blog/">Blog</a>

<a href='https://neiro.io/index.xml'>RSS</a>







</nav>
</header>
  <main id="main-content">

<h1>Pattern matching in Elixir</h1>
<p class="byline">
  <time datetime='2016-05-31' pubdate>
    2016-05-31
  </time>
  · [neiro]
</p>

<content>
  <p>Pattern matching is a key feature of functional programming. It allows
you to check a given sequence of tokens for the presence of the
constituents of some pattern. Using pattern matching you can easily
operate with complex data structures in most expressive and eloquent
way. Elixir provides pattern matching like any other functional
programming language.</p>
<h2 id="match-operator">Match operator</h2>
<p>Most of programming languages have assign operator: <code>var x = 10</code> . In
Elixir equals sign is actually <em>match operator</em>. Using this operator we
can assign and match values:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  1 = x
</span></span><span class="line"><span class="ln">3</span><span class="cl">  x # 1</span></span></code></pre></div><p>But if we will provide invalid pattern?</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  2 = x # ** (MatchError) no match of right hand side value: 1</span></span></code></pre></div><p>As you see, Elixir raises <code>MatchError</code> because left and right sides of
match operator are different - they don&rsquo;t match. You can assign variable
only on the left side of match operator:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  true = undefined # * (CompileError) undefined function undefined/0</span></span></code></pre></div><h2 id="pattern-matching">Pattern matching</h2>
<p>You can use match operator not for assign only - it&rsquo;s useful for
destructuring operations:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln"> 1</span><span class="cl">    # Lists
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">    list = [1, 2]
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">    [1 | tail] = list
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">    tail # [2]
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">    [1 | _] = list # [1, 2]
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">    [2 | _] = list # ** (MatchError) no match of right hand side value: [1, 2]
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">    # Tuples
</span></span><span class="line"><span class="ln"> 9</span><span class="cl">    { res, val } = { :ok, 1 } # res =&gt; :ok, val =&gt; 1
</span></span><span class="line"><span class="ln">10</span><span class="cl">    { :ok, val } = { :ok, 1 } # val =&gt; 1
</span></span><span class="line"><span class="ln">11</span><span class="cl">    { :ok, val } = { :fail, 1 } # ** (MatchError) no match of right hand side value: {:fail, 1}
</span></span><span class="line"><span class="ln">12</span><span class="cl">    { :ok, val } = { :fail } # ** (MatchError) no match of right hand side value: {:fail}
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">    # Maps
</span></span><span class="line"><span class="ln">15</span><span class="cl">    %{ foo: res } = %{ foo: &#34;bar&#34; } # res =&gt; &#34;foo&#34;
</span></span><span class="line"><span class="ln">16</span><span class="cl">    %{ bar: res } = %{ foo: &#34;bar&#34; } # ** (MatchError) no match of right hand side value: %{foo: &#34;bar&#34;}</span></span></code></pre></div><p>You can also use pattern matching with functions:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  defmodule HelloWorld do
</span></span><span class="line"><span class="ln">2</span><span class="cl">    def hello(:world), do: &#34;Hello, world!&#34;
</span></span><span class="line"><span class="ln">3</span><span class="cl">    def hello(name), do: &#34;Hello, #{ name }!&#34;
</span></span><span class="line"><span class="ln">4</span><span class="cl">    def hello, do: &#34;Hello!&#34;
</span></span><span class="line"><span class="ln">5</span><span class="cl">  end
</span></span><span class="line"><span class="ln">6</span><span class="cl">
</span></span><span class="line"><span class="ln">7</span><span class="cl">  HelloWorld.hello :world # &#34;Hello, world!&#34;
</span></span><span class="line"><span class="ln">8</span><span class="cl">  HelloWorld.hello &#34;Elixir&#34; # &#34;Hello, Elixir!&#34;
</span></span><span class="line"><span class="ln">9</span><span class="cl">  HelloWorld.hello # &#34;Hello!&#34;</span></span></code></pre></div><h2 id="pin-operator">Pin operator</h2>
<p>You can rebound Elixir&rsquo;s variables:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  x = 2
</span></span><span class="line"><span class="ln">3</span><span class="cl">  x # 2</span></span></code></pre></div><p>If you want to provide existing variable&rsquo;s value in pattern matching,
then you should use <em>pin operator</em>:</p>





<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="ln">1</span><span class="cl">  x = 1
</span></span><span class="line"><span class="ln">2</span><span class="cl">  ^x = 2 # MatchError because 1 != 2
</span></span><span class="line"><span class="ln">3</span><span class="cl">  [^x, y] = [1, 2] # [1, 2]
</span></span><span class="line"><span class="ln">4</span><span class="cl">  y # 2
</span></span><span class="line"><span class="ln">5</span><span class="cl">  [2, ^y] = [2, 1] # ** (MatchError) no match of right hand side value: [2, 1]
</span></span><span class="line"><span class="ln">6</span><span class="cl">  [_, ^y] = [3, 2] # [3, 2]</span></span></code></pre></div><h2 id="conclusion">Conclusion</h2>
<p>Elixir comes with match and pin operators that provide support of
pattern matching. It allows you to write simple and elegant code to
operate basic values, complex data structures or even functions.</p>

</content>
<p>
  
    <a class="blog-tags" href="/tags/elixir/">#elixir</a>
  
    <a class="blog-tags" href="/tags/functional/">#functional</a>
  
</p>




  </main>
  <footer><small>
  neiro © 2012-2025 | Made with <a href="https://github.com/clente/hugo-bearcub">Bear Cub</a>
</small></footer>

    
</body>

</html>
